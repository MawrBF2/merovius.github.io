<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Why doesn't Go have variance in its type system? | Mero's Blog</title><meta name=keywords content="golang,programming"><meta name=description content="I explain what co-, contra- and invariance are and what the implications for Go&rsquo;s type system would be. In particular, why it&rsquo;s impossible to have variance in slices."><meta name=author content><link rel=canonical href=https://blog.merovius.de/posts/2018-06-03-why-doesnt-go-have-variance-in/><link crossorigin=anonymous href=/assets/css/stylesheet.min.48a18943c2fc15c38a372b8dde1f5e5dc0bc64fa6cb90f5a817d2f8c76b7f3ae.css integrity="sha256-SKGJQ8L8FcOKNyuN3h9eXcC8ZPpsuQ9agX0vjHa3864=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.4dcb3c4f38462f66c6b6137227726f5543cb934cca9788f041c087e374491df2.js integrity="sha256-Tcs8TzhGL2bGthNyJ3JvVUPLk0zKl4jwQcCH43RJHfI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://blog.merovius.de/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.merovius.de/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.merovius.de/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.merovius.de/apple-touch-icon.png><link rel=mask-icon href=https://blog.merovius.de/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Why doesn't Go have variance in its type system?"><meta property="og:description" content="I explain what co-, contra- and invariance are and what the implications for Go&rsquo;s type system would be. In particular, why it&rsquo;s impossible to have variance in slices."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.merovius.de/posts/2018-06-03-why-doesnt-go-have-variance-in/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-06-03T23:20:00+00:00"><meta property="article:modified_time" content="2018-06-03T23:20:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Why doesn't Go have variance in its type system?"><meta name=twitter:description content="I explain what co-, contra- and invariance are and what the implications for Go&rsquo;s type system would be. In particular, why it&rsquo;s impossible to have variance in slices."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.merovius.de/posts/"},{"@type":"ListItem","position":2,"name":"Why doesn't Go have variance in its type system?","item":"https://blog.merovius.de/posts/2018-06-03-why-doesnt-go-have-variance-in/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Why doesn't Go have variance in its type system?","name":"Why doesn\u0027t Go have variance in its type system?","description":"I explain what co-, contra- and invariance are and what the implications for Go\u0026rsquo;s type system would be. In particular, why it\u0026rsquo;s impossible to have variance in slices.","keywords":["golang","programming"],"articleBody":"tl;dr: I explain what co-, contra- and invariance are and what the implications for Go’s type system would be. In particular, why it’s impossible to have variance in slices.\nA question that comes up relatively often with Go newcomers is “why can’t I pass e.g. an []int to a func([]interface{})”? In this post I want to explore this question and its implications for Go. But the concept of variance (which this is about) is also useful in other languages.\nVariance describes what happens to subtype relationships, when they are used in composite types. In this context, “A is a subtype of B” means that a value of type A can always be used, where a value of type B is required. Go doesn’t have explicit subtype relationships - the closest it has is assignability which mostly determines whether types can be used interchangeably. Probably the most important case of this is given by interfaces: If a type T (whether its a concrete type, or itself an interface) implements an interface I, then T can be viewed as a subtype of I. In that sense, *bytes.Buffer is a subtype of io.ReadWriter, which is a subtype of io.Reader. And every type is a subtype of interface{}.\nThe easiest way to understand what variance means, is to look at function types. Let’s assume, we have a type and a subtype - for example, let’s look at *bytes.Buffer as a subtype of io.Reader. Say, we have a func() *bytes.Buffer. We could also use this like a func() io.Reader - we just reinterpret the return value as an io.Reader. The reverse is not true: We can’t treat a func() io.Reader as a func() *bytes.Buffer, because not every io.Reader is a *bytes.Buffer. So, function return values could preserve the direction of subtyping relationships: If A is a subtype of B, func() A could be a subtype of func() B. This is called covariance.\nfunc F() io.Reader { \treturn new(bytes.Buffer) }  func G() *bytes.Buffer { \treturn new(bytes.Buffer) }  func Use(f func() io.Reader) { \tuseReader(f()) }  func main() { \tUse(F) // Works  \tUse(G) // Doesn't work right now; but *could* be made equivalent to… \tUse(func() io.Reader { return G() }) } On the other hand, say we have a func(*bytes.Buffer). Now we can’t use that as a func(io.Reader): You can’t call it with an io.Reader. But we can do the reverse. If we have a *bytes.Buffer, we can call a func(io.Reader) with it. Thus, function arguments reverse the subtype relationship: If A is a subtype of B, then func(B) could be a subtype of func(A). This is called contravariance.\nfunc F(r io.Reader) { \tuseReader(r) }  func G(r *bytes.Buffer) { \tuseReader(r) }  func Use(f func(*bytes.Buffer)) { \tb := new(bytes.Buffer) \tf(b) }  func main() { \tUse(F) // Doesn't work right now; but *could* be made equivalent to… \tUse(func(r *bytes.Buffer) { F(r) })  \tUse(G) // Works } So, func is contravariant for arguments and covariant for return values. Of course, we can combine the two: If A and C are subtypes of B and D respectively, we can make func(B) C a subtype of func(A) D, by converting like this:\n// *os.PathError implements error  func F(r io.Reader) *os.PathError { \t// ... }  func Use(f func(*bytes.Buffer) error) { \tb := new(bytes.Buffer) \terr := f(b) \tuseError(err) }  func main() { \tUse(F) // Could be made to be equivalent to \tUse(func(r *bytes.Buffer) error { return F(r) }) } However, func(A) C and func(B) D are incompatible. Neither can be a subtype of the other:\nfunc F(r *bytes.Buffer) *os.PathError { \t// ... }  func UseF(f func(io.Reader) error) { \tb := strings.NewReader(\"foobar\") \terr := f(b) \tuseError(err) }  func G(r io.Reader) error { \t// ... }  func UseG(f func(*bytes.Buffer) *os.PathErorr) { \tb := new(bytes.Buffer) \terr := f() \tusePathError(err) }  func main() { \tUseF(F) // Can't work, because: \tUseF(func(r io.Reader) error { \treturn F(r) // type-error: io.Reader is not *bytes.Buffer \t})  \tUseG(G) // Can't work, because: \tUseG(func(r *bytes.Buffer) *os.PathError { \treturn G(r) // type-error: error is not *os.PathError \t}) } So in this case, there just is not relationship between the composite types. This is called invariance.\n Now, we can get back to our opening question: Why can’t you use []int as []interface{}? This really is the question “Why are slice-types invariant”?. The questioner assumes that because int is a subtype of interface{}, we should also make []int a subtype of []interface{}. However, we can now see a simple problem with that. Slices support (among other things) two fundamental operations, that we can roughly translate into function calls:\nas := make([]A, 10) a := as[0] // func Get(as []A, i int) A as[1] = a // func Set(as []A, i int, a A) This shows a clear problem: The type A appears both as an argument and as a return type. So it appears both covariantly and contravariantly. So while with functions there is a relatively clear-cut answer to how variance might work, it just doesn’t make a lot of sense for slices. Reading from it would require covariance but writing to it would require contravariance. In other words: If you’d make []int a subtype of []interface{} you’d need to explain how this code would work:\nfunc G() { \tv := []int{1,2,3} \tF(v) \tfmt.Println(v) }  func F(v []interface{}) { \t// string is a subtype of interface{}, so this should be valid \tv[0] = \"Oops\" } Channels give another interesting perspective here. The bidirectional channel type has the same issue as slices: Receiving requires covariance, whereas sending requires contravariance. But you can restrict the directionality of a channel and only allow send- or receive-operations respectively. So while chan A and chan B would not be related, we could make a subtype of . And chana subtype of chan.\nIn that sense, read-only types have the potential to at least theoretically allow variance for slices. While []int still wouldn’t be a subtype of []interface{}, we could make ro []int a subtype of ro []interface{} (borrowing the syntax from the proposal).\n Lastly, I want to emphasize that all of these are just the theoretical issues with adding variance to Go’s type system. I consider them harder, but even if we could solve them we would still run into practical issues. The most pressing of which is that subtypes have different memory representations:\nvar ( \t// super pseudo-code to illustrate \tx *bytes.Buffer // unsafe.Pointer \ty io.ReadWriter // struct{ itable *itab; value unsafe.Pointer } \t// where itable has two entries \tz io.Reader\t// struct{ itable *itab; value unsafe.Pointer } \t// where itable has one entry ) So even though you might think that all interfaces have the same memory representation, they actually don’t, because the method tables have a different assumed layout. So in code like this\nfunc Do(f func() io.Reader) { \tr := f() \tr.Read(buf) }  func F() io.Reader { \treturn new(bytes.Buffer) }  func G() io.ReadWriter { \treturn new(bytes.Buffer) }  func H() *bytes.Buffer { \treturn new(bytes.Buffer) }  func main() { \t// All of F, G, H should be subtypes of func() io.Reader \tDo(F) \tDo(G) \tDo(H) } there still needs to be a place where the return value of H is wrapped into an io.Reader and there needs to be a place where the itable of the return value of G is transformed into the correct format expected for an io.Reader. This isn’t a huge problem for func: The compiler can generate the appropriate wrappers at the call site in main. There is a performance overhead, but only code that actually uses this form of subtyping needs to pay it. However, it becomes significant problem for slices.\nFor slices, we must either a) convert the []int into an []interface{} when passing it, meaning an allocation and complete copy. Or b) delay the conversion between int and interface{} until the access, which would mean that every slice access now has to go through an indirect function call - just in case anyone would ever pass us a subtype of what we are expecting. Both options seem prohibitively expensive for Go’s goals.\n","wordCount":"1333","inLanguage":"en","datePublished":"2018-06-03T23:20:00Z","dateModified":"2018-06-03T23:20:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.merovius.de/posts/2018-06-03-why-doesnt-go-have-variance-in/"},"publisher":{"@type":"Organization","name":"Mero's Blog","logo":{"@type":"ImageObject","url":"https://blog.merovius.de/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.merovius.de/ accesskey=h title="Mero's Blog (Alt + H)">Mero's Blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Why doesn't Go have variance in its type system?</h1><div class=post-meta><span title="2018-06-03 23:20:00 +0000 UTC">June 3, 2018</span></div></header><div class=post-content><p><strong>tl;dr: I explain what co-, contra- and invariance are and what the
implications for Go&rsquo;s type system would be. In particular, why it&rsquo;s impossible
to have variance in slices.</strong></p><p>A question that comes up relatively often with Go newcomers is &ldquo;why can&rsquo;t I
pass e.g. an <code>[]int</code> to a <code>func([]interface{})</code>&rdquo;? In this post I want to
explore this question and its implications for Go. But the concept of
variance (which this is about) is also useful in other languages.</p><p>Variance describes what happens to subtype relationships, when they are
used in composite types. In this context, &ldquo;A is a subtype of B&rdquo; means
that a value of type A can always be used, where a value of type B is required.
Go doesn&rsquo;t have explicit subtype relationships - the closest it has is
<a href=https://golang.org/ref/spec#Assignability>assignability</a> which mostly
determines whether types can be used interchangeably. Probably the most
important case of this is given by interfaces: If a type T (whether its a
concrete type, or itself an interface) implements an interface I, then T can be
viewed as a subtype of I. In that sense,
<a href=https://godoc.org/bytes#Buffer><code>*bytes.Buffer</code></a> is a subtype of
<a href=https://godoc.org/io#ReadWriter>io.ReadWriter</a>, which is a subtype of
<a href=https://godoc.org/io#Reader>io.Reader</a>. And every type is a subtype of
<code>interface{}</code>.</p><p>The easiest way to understand what variance means, is to look at function
types. Let&rsquo;s assume, we have a type and a subtype - for example, let&rsquo;s look at
<code>*bytes.Buffer</code> as a subtype of <code>io.Reader</code>. Say, we have a <code>func() *bytes.Buffer</code>. We could also use this like a <code>func() io.Reader</code> - we just
reinterpret the return value as an <code>io.Reader</code>. The reverse is not true: We
can&rsquo;t treat a <code>func() io.Reader</code> as a <code>func() *bytes.Buffer</code>, because not every
<code>io.Reader</code> is a <code>*bytes.Buffer</code>. So, function return values could <em>preserve</em>
the direction of subtyping relationships: If A is a subtype of B, <code>func() A</code>
could be a subtype of <code>func() B</code>. This is called <em>covariance</em>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>F</span>() <span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>Reader</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> new(<span style=color:#a6e22e>bytes</span>.<span style=color:#a6e22e>Buffer</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>G</span>() <span style=color:#f92672>*</span><span style=color:#a6e22e>bytes</span>.<span style=color:#a6e22e>Buffer</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> new(<span style=color:#a6e22e>bytes</span>.<span style=color:#a6e22e>Buffer</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Use</span>(<span style=color:#a6e22e>f</span> <span style=color:#66d9ef>func</span>() <span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>Reader</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>useReader</span>(<span style=color:#a6e22e>f</span>())
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Use</span>(<span style=color:#a6e22e>F</span>) <span style=color:#75715e>// Works
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Use</span>(<span style=color:#a6e22e>G</span>) <span style=color:#75715e>// Doesn&#39;t work right now; but *could* be made equivalent to…
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>Use</span>(<span style=color:#66d9ef>func</span>() <span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>Reader</span> { <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>G</span>() })
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>On the other hand, say we have a <code>func(*bytes.Buffer)</code>. Now we can&rsquo;t use that
as a <code>func(io.Reader)</code>: You can&rsquo;t call it with an <code>io.Reader</code>. But we <em>can</em> do
the reverse. If we have a <code>*bytes.Buffer</code>, we can call a <code>func(io.Reader)</code> with
it. Thus, function arguments <em>reverse</em> the subtype relationship: If A is a
subtype of B, then <code>func(B)</code> could be a subtype of <code>func(A)</code>. This is called
<em>contravariance</em>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>F</span>(<span style=color:#a6e22e>r</span> <span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>Reader</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>useReader</span>(<span style=color:#a6e22e>r</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>G</span>(<span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>bytes</span>.<span style=color:#a6e22e>Buffer</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>useReader</span>(<span style=color:#a6e22e>r</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Use</span>(<span style=color:#a6e22e>f</span> <span style=color:#66d9ef>func</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>bytes</span>.<span style=color:#a6e22e>Buffer</span>)) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>b</span> <span style=color:#f92672>:=</span> new(<span style=color:#a6e22e>bytes</span>.<span style=color:#a6e22e>Buffer</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>f</span>(<span style=color:#a6e22e>b</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Use</span>(<span style=color:#a6e22e>F</span>) <span style=color:#75715e>// Doesn&#39;t work right now; but *could* be made equivalent to…
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>Use</span>(<span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>bytes</span>.<span style=color:#a6e22e>Buffer</span>) { <span style=color:#a6e22e>F</span>(<span style=color:#a6e22e>r</span>) })
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Use</span>(<span style=color:#a6e22e>G</span>) <span style=color:#75715e>// Works
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>So, <code>func</code> is contravariant for arguments and covariant for return values. Of
course, we can combine the two: If A and C are subtypes of B and D
respectively, we can make <code>func(B) C</code> a subtype of <code>func(A) D</code>, by converting
like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// *os.PathError implements error
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>F</span>(<span style=color:#a6e22e>r</span> <span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>Reader</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>PathError</span> {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Use</span>(<span style=color:#a6e22e>f</span> <span style=color:#66d9ef>func</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>bytes</span>.<span style=color:#a6e22e>Buffer</span>) <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>b</span> <span style=color:#f92672>:=</span> new(<span style=color:#a6e22e>bytes</span>.<span style=color:#a6e22e>Buffer</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>f</span>(<span style=color:#a6e22e>b</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>useError</span>(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Use</span>(<span style=color:#a6e22e>F</span>) <span style=color:#75715e>// Could be made to be equivalent to
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>Use</span>(<span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>bytes</span>.<span style=color:#a6e22e>Buffer</span>) <span style=color:#66d9ef>error</span> { <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>F</span>(<span style=color:#a6e22e>r</span>) })
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>However, <code>func(A) C</code> and <code>func(B) D</code> are incompatible. Neither can be a subtype
of the other:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>F</span>(<span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>bytes</span>.<span style=color:#a6e22e>Buffer</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>PathError</span> {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>UseF</span>(<span style=color:#a6e22e>f</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>Reader</span>) <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>b</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>strings</span>.<span style=color:#a6e22e>NewReader</span>(<span style=color:#e6db74>&#34;foobar&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>f</span>(<span style=color:#a6e22e>b</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>useError</span>(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>G</span>(<span style=color:#a6e22e>r</span> <span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>Reader</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>UseG</span>(<span style=color:#a6e22e>f</span> <span style=color:#66d9ef>func</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>bytes</span>.<span style=color:#a6e22e>Buffer</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>PathErorr</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>b</span> <span style=color:#f92672>:=</span> new(<span style=color:#a6e22e>bytes</span>.<span style=color:#a6e22e>Buffer</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>f</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>usePathError</span>(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>UseF</span>(<span style=color:#a6e22e>F</span>) <span style=color:#75715e>// Can&#39;t work, because:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>UseF</span>(<span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>r</span> <span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>Reader</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>F</span>(<span style=color:#a6e22e>r</span>) <span style=color:#75715e>// type-error: io.Reader is not *bytes.Buffer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	})
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>UseG</span>(<span style=color:#a6e22e>G</span>) <span style=color:#75715e>// Can&#39;t work, because:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>UseG</span>(<span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>bytes</span>.<span style=color:#a6e22e>Buffer</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>PathError</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>G</span>(<span style=color:#a6e22e>r</span>) <span style=color:#75715e>// type-error: error is not *os.PathError
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	})
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>So in this case, there just <em>is</em> not relationship between the composite types.
This is called <em>invariance</em>.</p><hr><p>Now, we can get back to our opening question: Why can&rsquo;t you use <code>[]int</code> as
<code>[]interface{}</code>? This really is the question &ldquo;Why are slice-types invariant&rdquo;?.
The questioner assumes that because <code>int</code> is a subtype of <code>interface{}</code>, we
should also make <code>[]int</code> a subtype of <code>[]interface{}</code>. However, we can now see
a simple problem with that. Slices support (among other things) two fundamental
operations, that we can roughly translate into function calls:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>as</span> <span style=color:#f92672>:=</span> make([]<span style=color:#a6e22e>A</span>, <span style=color:#ae81ff>10</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>a</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>as</span>[<span style=color:#ae81ff>0</span>] 		<span style=color:#75715e>// func Get(as []A, i int) A
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>as</span>[<span style=color:#ae81ff>1</span>] = <span style=color:#a6e22e>a</span>  		<span style=color:#75715e>// func Set(as []A, i int, a A)
</span></span></span></code></pre></div><p>This shows a clear problem: The type A appears <em>both</em> as an argument <em>and</em>
as a return type. So it appears both covariantly and contravariantly. So while
with functions there is a relatively clear-cut answer to how variance might
work, it just doesn&rsquo;t make a lot of sense for slices. Reading from it would
require covariance but writing to it would require contravariance. In other
words: If you&rsquo;d make <code>[]int</code> a subtype of <code>[]interface{}</code> you&rsquo;d need to explain
how this code would work:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>G</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>F</span>(<span style=color:#a6e22e>v</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>v</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>F</span>(<span style=color:#a6e22e>v</span> []<span style=color:#66d9ef>interface</span>{}) {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// string is a subtype of interface{}, so this should be valid
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>v</span>[<span style=color:#ae81ff>0</span>] = <span style=color:#e6db74>&#34;Oops&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Channels give another interesting perspective here. The bidirectional channel
type has the same issue as slices: Receiving requires covariance, whereas
sending requires contravariance. But you can restrict the directionality of a
channel and only allow send- or receive-operations respectively. So while <code>chan A</code> and <code>chan B</code> would not be related, we could make <code>&lt;-chan A</code> a subtype of
<code>&lt;-chan B</code>. And <code>chan&lt;- B</code> a subtype of <code>chan&lt;- A</code>.</p><p>In that sense, <a href=https://github.com/golang/go/issues/22876>read-only types</a>
have the potential to at least theoretically allow variance for slices. While
<code>[]int</code> still wouldn&rsquo;t be a subtype of <code>[]interface{}</code>, we could make <code>ro []int</code> a subtype of <code>ro []interface{}</code> (borrowing the syntax from the
proposal).</p><hr><p>Lastly, I want to emphasize that all of these are just the <em>theoretical</em> issues
with adding variance to Go&rsquo;s type system. I consider them harder, but even if
we <em>could</em> solve them we would still run into practical issues. The most
pressing of which is that subtypes have different memory representations:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> (
</span></span><span style=display:flex><span>	<span style=color:#75715e>// super pseudo-code to illustrate
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>x</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>bytes</span>.<span style=color:#a6e22e>Buffer</span> <span style=color:#75715e>// unsafe.Pointer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>y</span> <span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>ReadWriter</span> <span style=color:#75715e>// struct{ itable *itab; value unsafe.Pointer }
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>					<span style=color:#75715e>// where itable has two entries
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>z</span> <span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>Reader</span>		<span style=color:#75715e>// struct{ itable *itab; value unsafe.Pointer }
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>					<span style=color:#75715e>// where itable has one entry
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>)
</span></span></code></pre></div><p>So even though you might think that all interfaces have the same memory
representation, they actually don&rsquo;t, because the method tables have a different
assumed layout. So in code like this</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Do</span>(<span style=color:#a6e22e>f</span> <span style=color:#66d9ef>func</span>() <span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>Reader</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>r</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>f</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>Read</span>(<span style=color:#a6e22e>buf</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>F</span>() <span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>Reader</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> new(<span style=color:#a6e22e>bytes</span>.<span style=color:#a6e22e>Buffer</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>G</span>() <span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>ReadWriter</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> new(<span style=color:#a6e22e>bytes</span>.<span style=color:#a6e22e>Buffer</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>H</span>() <span style=color:#f92672>*</span><span style=color:#a6e22e>bytes</span>.<span style=color:#a6e22e>Buffer</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> new(<span style=color:#a6e22e>bytes</span>.<span style=color:#a6e22e>Buffer</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// All of F, G, H should be subtypes of func() io.Reader
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>Do</span>(<span style=color:#a6e22e>F</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Do</span>(<span style=color:#a6e22e>G</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Do</span>(<span style=color:#a6e22e>H</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>there still needs to be a place where the return value of <code>H</code> is wrapped into
an <code>io.Reader</code> and there needs to be a place where the itable of the return
value of <code>G</code> is transformed into the correct format expected for an
<code>io.Reader</code>. This isn&rsquo;t a <em>huge</em> problem for <code>func</code>: The compiler can
generate the appropriate wrappers at the call site in <code>main</code>.
There is a performance overhead, but only code that actually uses this form of
subtyping needs to pay it. However, it becomes significant problem for slices.</p><p>For slices, we must either a) convert the <code>[]int</code> into an <code>[]interface{}</code> when
passing it, meaning an allocation and complete copy. Or b) delay the conversion
between <code>int</code> and <code>interface{}</code> until the access, which would mean that every
slice access now has to go through an indirect function call - just <em>in case</em>
anyone would ever pass us a subtype of what we are expecting. Both options
seem prohibitively expensive for Go&rsquo;s goals.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.merovius.de/tags/golang/>golang</a></li><li><a href=https://blog.merovius.de/tags/programming/>programming</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://blog.merovius.de/>Mero's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>