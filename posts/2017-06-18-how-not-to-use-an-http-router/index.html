<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>How to not use an http-router in go | Mero's Blog</title><meta name=keywords content="golang,programming"><meta name=description content="Trying to provide some advice on how to do easy, readable, scalable routing in go, without relying on any muxers/routers (or writing your own)."><meta name=author content><link rel=canonical href=https://blog.merovius.de/posts/2017-06-18-how-not-to-use-an-http-router/><link crossorigin=anonymous href=/assets/css/stylesheet.min.48a18943c2fc15c38a372b8dde1f5e5dc0bc64fa6cb90f5a817d2f8c76b7f3ae.css integrity="sha256-SKGJQ8L8FcOKNyuN3h9eXcC8ZPpsuQ9agX0vjHa3864=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.4dcb3c4f38462f66c6b6137227726f5543cb934cca9788f041c087e374491df2.js integrity="sha256-Tcs8TzhGL2bGthNyJ3JvVUPLk0zKl4jwQcCH43RJHfI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://blog.merovius.de/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.merovius.de/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.merovius.de/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.merovius.de/apple-touch-icon.png><link rel=mask-icon href=https://blog.merovius.de/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="How to not use an http-router in go"><meta property="og:description" content="Trying to provide some advice on how to do easy, readable, scalable routing in go, without relying on any muxers/routers (or writing your own)."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.merovius.de/posts/2017-06-18-how-not-to-use-an-http-router/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-06-18T22:57:21+00:00"><meta property="article:modified_time" content="2017-06-18T22:57:21+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="How to not use an http-router in go"><meta name=twitter:description content="Trying to provide some advice on how to do easy, readable, scalable routing in go, without relying on any muxers/routers (or writing your own)."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.merovius.de/posts/"},{"@type":"ListItem","position":2,"name":"How to not use an http-router in go","item":"https://blog.merovius.de/posts/2017-06-18-how-not-to-use-an-http-router/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"How to not use an http-router in go","name":"How to not use an http-router in go","description":"Trying to provide some advice on how to do easy, readable, scalable routing in go, without relying on any muxers/routers (or writing your own).","keywords":["golang","programming"],"articleBody":"If you don’t write web-thingies in go you can stop reading now. Also, I am somewhat snarky in this article. I intend that to be humorous but am probably failing. Sorry for that\nAs everyone™ knows, people need to stop writing routers/muxs in go. Some people attribute the abundance of routers to the fact that the net/http package fails to provide a sufficiently powerful router, so people roll their own. This is also reflected in this post, in which a gopher complains about how complex and hard to maintain it would be to route requests using net/http alone.\nI disagree with both of these. I don’t believe the problem is a lack of a powerful enough router in the stdlib. I also disagree that routing based purely on net/http has to be complicated or hard to maintain.\nHowever, I do believe that the community currently lacks good guidance on how to properly route requests using net/http. The default result seems to be that people assume they are supposed to use http.ServeMux and get frustrated by it. In this post I want to explain why routers in general - including http.ServeMux - should be avoided and what I consider simple, maintainable and scalable routing using nothing but the stdlib.\nBut why? Why do I believe that routers should not be used? I have three arguments for that: They need to be very complex to be useful, they introduce strong coupling and they make it hard to understand how requests are flowing.\nThe basic idea of a router/mux is, that you have a single component which looks at a request and decides what handler to dispatch it to. In your func main() you then create your router, you define all your routes with all your handlers and then you call Serve(l, router) and everything’s peachy.\nBut since URLs can encode a lot of important information to base your routing decisions on, doing it this way requires a lot of extra features. The stdlib ServeMux is an incredibly simple router but even that contains a certain amount of magic in its routing decisions; depending on whether a pattern contains a trailing slash or not it might either be matched as a prefix or as a complete URL and longer patterns take precedence over shorter ones and oh my. But the stdlib router isn’t even powerful enough. Many people need to match URLs like \"/articles/{category}/{id:[0-9]+}\" in their router and while we’re at it also extract those nifty arguments. So they’re using gorilla/mux instead. An awful lot of code to route requests.\nNow, without cheating (and actually knowing that package counts as cheating), tell me for each of these requests:\n GET /foo GET /foo/bar GET /foo/baz POST /foo PUT /foo PUT /foo/bar POST /foo/123  What handler they map to and what status code do they return (“OK”? “Bad Request”? “Not Found”? “Method not allowed”?) in this routing setup?\nr := mux.NewRouter() r.PathPrefix(\"/foo\").Methods(\"GET\").HandlerFunc(Foo) r.PathPrefix(\"/foo/bar\").Methods(\"GET\").HandlerFunc(FooBar) r.PathPrefix(\"/foo/{user:[a-z]+}\").Methods(\"GET\").HandlerFunc(FooUser) r.PathPrefix(\"/foo\").Methods(\"POST\").HandlerFunc(PostFoo) What if you permute the lines in the routing-setup?\nYou might guess correctly. You might not. There are multiple sane routing strategies that you could base your guess on. The routes might be tried in source order. The routes might be tried in order of specificity. Or a complicated mixture of all of them. The router might realize that it could match a Route if the method were different and return a 405. Or it might not not. Or that /foo/123 is, technically, an illegal argument, not a missing page. I couldn’t really find a good answer to any of these questions in the documentation of gorilla/mux for what it’s worth. Which meant that when my web app suddenly didn’t route requests correctly, I was stumped and needed to dive into code.\nYou could say that people just have to learn how gorilla/mux decides it’s routing (I believe it’s “as defined in source order”, by the way). But there are at least fifteen thousand routers for go and no newcomer to your application will ever know all of them. When a request does the wrong thing, I don’t want to have to debug your router first to find out what handler it is actually going to and then debug that handler. I want to be able to follow the request through your code, even if I have next to zero familiarity with it.\nLastly, this kind of setup requires that all the routing decisions for your application are done in a central place. That introduces edit-contention, it introduces strong coupling (the router needs to be aware of all the paths and packages needed in the whole application) and it becomes unmaintainable after a while. You can alleviate that by delegating to subrouters though; which really is the basis of how I prefer to do all of this these days.\nHow to use the stdlib to route Let’s build the toy example from this medium post. It’s not terribly complicated but it serves nicely to illustrate the general idea. The author intended to show that using the stdlib for routing would be too complicated and wouldn’t scale. But my thesis is that the issue is that they are effectively trying to write a router. They are trying to encapsulate all the routing decisions into one single component. Instead, separate concerns and make small, easily understandable routing decisions locally.\nRemember how I told you that we’re going to use only the stdlib for routing?\nWe are going to use this one helper function:\n// ShiftPath splits off the first component of p, which will be cleaned of // relative components before processing. head will never contain a slash and // tail will always be a rooted path without trailing slash. func ShiftPath(p string) (head, tail string) { \tp = path.Clean(\"/\" + p) \ti := strings.Index(p[1:], \"/\") + 1 \tif i  0 { \treturn p[1:], \"/\" \t} \treturn p[1:i], p[i:] } Let’s build our app. We start by defining a handler type. The premise of this approach is that handlers are strictly separated in their concerns. They either correctly handle a request with the correct status code or they delegate to another handler which will do that. They only need to know about the immediate handlers they delegate to and they only need to know about the sub-path they are rooted at:\ntype App struct { \t// We could use http.Handler as a type here; using the specific type has \t// the advantage that static analysis tools can link directly from \t// h.UserHandler.ServeHTTP to the correct definition. The disadvantage is \t// that we have slightly stronger coupling. Do the tradeoff yourself. \tUserHandler *UserHandler }  func (h *App) ServeHTTP(res http.ResponseWriter, req *http.Request) { \tvar head string \thead, req.URL.Path = ShiftPath(req.URL.Path) \tif head == \"user\" { \th.UserHandler.ServeHTTP(res, req) \treturn \t} \thttp.Error(res, \"Not Found\", http.StatusNotFound) }  type UserHandler struct { }  func (h *UserHandler) ServeHTTP(res http.ResponseWriter, req *http.Request) { \tvar head string \thead, req.URL.Path = ShiftPath(req.URL.Path) \tid, err := strconv.Atoi(head) \tif err != nil { \thttp.Error(res, fmt.Sprintf(\"Invalid user id %q\", head), http.StatusBadRequest) \treturn \t} \tswitch req.Method { \tcase \"GET\": \th.handleGet(id) \tcase \"PUT\": \th.handlePut(id) \tdefault: \thttp.Error(res, \"Only GET and PUT are allowed\", http.StatusMethodNotAllowed) \t} }  func main() { \ta := \u0026App{ \tUserHandler: new(UserHandler), \t} \thttp.ListenAndServe(\":8000\", a) } This seems very simple to me (not necessarily in “lines of code” but definitely in “understandability”). You don’t need to know anything about any routers. If you want to understand how the request is routed you start by looking at main. You see that (*App).ServeHTTP is used to serve any request so you :GoDef to its definition. You see that it decides to dispatch to UserHandler, you go to its ServeHTTP method and you see directly how it parses the URL and what the decisions are that it made on its base.\nWe still need to add some patterns to our application. Let’s add a profile handler:\ntype UserHandler struct{ \tProfileHandler *ProfileHandler }  func (h *UserHandler) ServeHTTP(res http.ResponseWriter, req *http.Request) { \tvar head string \thead, req.URL.Path = ShiftPath(req.URL.Path) \tid, err := strconv.Atoi(head) \tif err != nil { \thttp.Error(res, fmt.Sprintf(\"Invalid user id %q\", head), http.StatusBadRequest) \treturn \t}  \tif req.URL.Path != \"/\" { \thead, tail := ShiftPath(req.URL.Path) \tswitch head { \tcase \"profile\": \t// We can't just make ProfileHandler an http.Handler; it needs the \t// user id. Let's instead… \th.ProfileHandler.Handler(id).ServeHTTP(res, req) \tcase \"account\": \t// Left as an exercise to the reader. \tdefault: \thttp.Error(res, \"Not Found\", http.StatusNotFound) \t} \treturn \t} \t// As before \t... }  type ProfileHandler struct { }  func (h *ProfileHandler) Handler(id int) http.Handler { \treturn http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) { \t// Do whatever \t}) } This may, again, seem complicated but it has the cool advantage that the dependencies of ProfileHandler are clear at compile time. It needs a user id which needs to come from somewhere. Providing it via this kind of method ensures this is the case. When you refactor your code, you won’t accidentally forget to provide it; it’s impossible to miss!\nThere are two potential alternatives to this if you prefer them: You could put the user-id into req.Context() or you could be super-hackish and add them to req.Form. But I prefer it this way.\nYou might argue that App still needs to know all the transitive dependencies (because they are members, transitively) so we haven’t actually reduced coupling. But that’s not true. Its UserHandler could be created by a NewUserHandler function which gets passed its dependencies via the mechanism of your choice (flags, dependency injection,…) and gets wired up in main. All App needs to know is the API of the handlers it’s directly invoking.\nConclusion I hope I convinced you that routers in and of itself are harmful. Pulling the routing into one component means that that component needs to encapsulate an awful lot of complexity, making it hard to debug. And as no single existing router will contain all the complicated cleverness you want to base your routing decisions on, you are tempted to write your own. Which everyone does.\nInstead, split your routing decisions into small, independent chunks and express them in their own handlers. And wire the dependencies up at compile time, using the type system of go, and reduce coupling.\n","wordCount":"1690","inLanguage":"en","datePublished":"2017-06-18T22:57:21Z","dateModified":"2017-06-18T22:57:21Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.merovius.de/posts/2017-06-18-how-not-to-use-an-http-router/"},"publisher":{"@type":"Organization","name":"Mero's Blog","logo":{"@type":"ImageObject","url":"https://blog.merovius.de/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.merovius.de/ accesskey=h title="Mero's Blog (Alt + H)">Mero's Blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>How to not use an http-router in go</h1><div class=post-meta><span title="2017-06-18 22:57:21 +0000 UTC">June 18, 2017</span></div></header><div class=post-content><p><strong>If you don&rsquo;t write web-thingies in go you can stop reading now. Also, I am
somewhat snarky in this article. I intend that to be humorous but am probably
failing. Sorry for that</strong></p><p>As everyone™ knows, people need to <a href=https://twitter.com/bketelsen/status/875435750770089984>stop writing
routers/muxs</a> in go.
Some people
<a href=https://twitter.com/markbates/status/875517884931473409>attribute</a> the
abundance of routers to the fact that the <code>net/http</code> package fails to provide a
sufficiently powerful router, so people roll their own. This is also reflected
in <a href=https://medium.com/@joeybloggs/gos-std-net-http-is-all-you-need-right-1c5555a9f2f6>this post</a>,
in which a gopher complains about how complex and hard to maintain it would be
to route requests using <code>net/http</code> alone.</p><p>I disagree with both of these. I don&rsquo;t believe the problem is a lack of a
powerful enough router in the stdlib. I also disagree that routing based purely
on <code>net/http</code> has to be complicated or hard to maintain.</p><p>However, I <em>do</em> believe that the community currently lacks good guidance on
<em>how</em> to properly route requests using <code>net/http</code>. The default result seems to
be that people assume they are supposed to use <code>http.ServeMux</code> and get
frustrated by it. In this post I want to explain why routers <em>in general</em> -
including <code>http.ServeMux</code> - should be avoided and what I consider simple,
maintainable and scalable routing using nothing but the stdlib.</p><h2 id=but-why>But why?<a hidden class=anchor aria-hidden=true href=#but-why>#</a></h2><p><img loading=lazy src=https://i.giphy.com/1M9fmo1WAFVK0.webp alt="But why?"></p><p>Why do I believe that routers should not be used? I have three arguments for
that: They need to be very complex to be useful, they introduce strong coupling
and they make it hard to understand how requests are flowing.</p><p>The basic idea of a router/mux is, that you have a single component which
looks at a request and decides what handler to dispatch it to. In your <code>func main()</code> you then create your router, you define all your routes with all your
handlers and then you call <code>Serve(l, router)</code> and everything&rsquo;s peachy.</p><p>But since URLs can encode a lot of important information to base your routing
decisions on, doing it this way requires a lot of extra features. The <a href=https://godoc.org/net/http#ServeMux>stdlib
ServeMux</a> is an incredibly simple router
but even that contains a certain amount of magic in its routing decisions;
depending on whether a pattern contains a trailing slash or not it might either
be matched as a prefix or as a complete URL and longer patterns take precedence
over shorter ones and oh my. But the stdlib router isn&rsquo;t even powerful enough.
Many people need to match URLs like <code>"/articles/{category}/{id:[0-9]+}"</code> in
their router and while we&rsquo;re at it also extract those nifty arguments. So
they&rsquo;re using <a href=https://godoc.org/github.com/gorilla/mux>gorilla/mux</a> instead.
An awful lot of code to route requests.</p><p>Now, without cheating (and actually knowing that package counts as cheating),
tell me for each of these requests:</p><ul><li><code>GET /foo</code></li><li><code>GET /foo/bar</code></li><li><code>GET /foo/baz</code></li><li><code>POST /foo</code></li><li><code>PUT /foo</code></li><li><code>PUT /foo/bar</code></li><li><code>POST /foo/123</code></li></ul><p>What handler they map to and what status code do they return (&ldquo;OK&rdquo;? &ldquo;Bad
Request&rdquo;? &ldquo;Not Found&rdquo;? &ldquo;Method not allowed&rdquo;?) in this routing setup?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>r</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>mux</span>.<span style=color:#a6e22e>NewRouter</span>()
</span></span><span style=display:flex><span><span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>PathPrefix</span>(<span style=color:#e6db74>&#34;/foo&#34;</span>).<span style=color:#a6e22e>Methods</span>(<span style=color:#e6db74>&#34;GET&#34;</span>).<span style=color:#a6e22e>HandlerFunc</span>(<span style=color:#a6e22e>Foo</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>PathPrefix</span>(<span style=color:#e6db74>&#34;/foo/bar&#34;</span>).<span style=color:#a6e22e>Methods</span>(<span style=color:#e6db74>&#34;GET&#34;</span>).<span style=color:#a6e22e>HandlerFunc</span>(<span style=color:#a6e22e>FooBar</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>PathPrefix</span>(<span style=color:#e6db74>&#34;/foo/{user:[a-z]+}&#34;</span>).<span style=color:#a6e22e>Methods</span>(<span style=color:#e6db74>&#34;GET&#34;</span>).<span style=color:#a6e22e>HandlerFunc</span>(<span style=color:#a6e22e>FooUser</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>PathPrefix</span>(<span style=color:#e6db74>&#34;/foo&#34;</span>).<span style=color:#a6e22e>Methods</span>(<span style=color:#e6db74>&#34;POST&#34;</span>).<span style=color:#a6e22e>HandlerFunc</span>(<span style=color:#a6e22e>PostFoo</span>)
</span></span></code></pre></div><p>What if you permute the lines in the routing-setup?</p><p>You might guess correctly. You might not. There are multiple sane routing
strategies that you could base your guess on. The routes might be tried in
source order. The routes might be tried in order of specificity. Or a
complicated mixture of all of them. The router might realize that it could
match a Route if the method were different and return a 405. Or it might not not. Or that
<code>/foo/123</code> is, technically, an illegal argument, not a missing page. I couldn&rsquo;t
really find a good answer to any of these questions in the documentation of
<code>gorilla/mux</code> for what it&rsquo;s worth. Which meant that when my web app suddenly
didn&rsquo;t route requests correctly, I was stumped and needed to dive into code.</p><p>You could say that people just have to learn how <code>gorilla/mux</code> decides it&rsquo;s
routing (I believe it&rsquo;s &ldquo;as defined in source order&rdquo;, by the way). But there
are at least fifteen thousand routers for go and no newcomer to your
application will ever know all of them. When a request does the wrong thing, I
don&rsquo;t want to have to debug your router first to find out what handler it is
actually going to and then debug that handler. I want to be able to follow the
request through your code, even if I have next to zero familiarity with it.</p><p>Lastly, this kind of setup requires that all the routing decisions for your
application are done in a central place. That introduces edit-contention, it
introduces strong coupling (the router needs to be aware of all the paths and
packages needed in the whole application) and it becomes unmaintainable after a
while. You can alleviate that by delegating to subrouters though; which really
is the basis of how I prefer to do all of this these days.</p><h2 id=how-to-use-the-stdlib-to-route>How to use the stdlib to route<a hidden class=anchor aria-hidden=true href=#how-to-use-the-stdlib-to-route>#</a></h2><p>Let&rsquo;s build the toy example from <a href=https://medium.com/@joeybloggs/gos-std-net-http-is-all-you-need-right-1c5555a9f2f6>this medium post</a>.
It&rsquo;s not terribly complicated but it serves nicely to illustrate the general
idea. The author intended to show that using the stdlib for routing would be
too complicated and wouldn&rsquo;t scale. But my thesis is that the issue is that
<em>they are effectively trying to write a router</em>. They are trying to
encapsulate all the routing decisions into one single component. Instead,
separate concerns and make small, easily understandable routing decisions
locally.</p><p>Remember how I told you that we&rsquo;re going to use only the stdlib for routing?</p><p><img loading=lazy src=https://i.giphy.com/l4FGmlJviGJcYM2sM.webp alt="Those where lies, plain and simple"></p><p>We are going to use this one helper function:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// ShiftPath splits off the first component of p, which will be cleaned of
</span></span></span><span style=display:flex><span><span style=color:#75715e>// relative components before processing. head will never contain a slash and
</span></span></span><span style=display:flex><span><span style=color:#75715e>// tail will always be a rooted path without trailing slash.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>ShiftPath</span>(<span style=color:#a6e22e>p</span> <span style=color:#66d9ef>string</span>) (<span style=color:#a6e22e>head</span>, <span style=color:#a6e22e>tail</span> <span style=color:#66d9ef>string</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>p</span> = <span style=color:#a6e22e>path</span>.<span style=color:#a6e22e>Clean</span>(<span style=color:#e6db74>&#34;/&#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>p</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>strings</span>.<span style=color:#a6e22e>Index</span>(<span style=color:#a6e22e>p</span>[<span style=color:#ae81ff>1</span>:], <span style=color:#e6db74>&#34;/&#34;</span>) <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>p</span>[<span style=color:#ae81ff>1</span>:], <span style=color:#e6db74>&#34;/&#34;</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>p</span>[<span style=color:#ae81ff>1</span>:<span style=color:#a6e22e>i</span>], <span style=color:#a6e22e>p</span>[<span style=color:#a6e22e>i</span>:]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Let&rsquo;s build our app. We start by defining a handler type. The premise of this
approach is that handlers are strictly separated in their concerns. They either
correctly handle a request with the correct status code or they delegate to
another handler which will do that. They only need to know about the immediate
handlers they delegate to and they only need to know about the sub-path they
are rooted at:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>App</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// We could use http.Handler as a type here; using the specific type has
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// the advantage that static analysis tools can link directly from
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// h.UserHandler.ServeHTTP to the correct definition. The disadvantage is
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// that we have slightly stronger coupling. Do the tradeoff yourself.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>UserHandler</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>UserHandler</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>h</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>App</span>) <span style=color:#a6e22e>ServeHTTP</span>(<span style=color:#a6e22e>res</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>req</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>head</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>head</span>, <span style=color:#a6e22e>req</span>.<span style=color:#a6e22e>URL</span>.<span style=color:#a6e22e>Path</span> = <span style=color:#a6e22e>ShiftPath</span>(<span style=color:#a6e22e>req</span>.<span style=color:#a6e22e>URL</span>.<span style=color:#a6e22e>Path</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>head</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;user&#34;</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>UserHandler</span>.<span style=color:#a6e22e>ServeHTTP</span>(<span style=color:#a6e22e>res</span>, <span style=color:#a6e22e>req</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Error</span>(<span style=color:#a6e22e>res</span>, <span style=color:#e6db74>&#34;Not Found&#34;</span>, <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>StatusNotFound</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>UserHandler</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>h</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>UserHandler</span>) <span style=color:#a6e22e>ServeHTTP</span>(<span style=color:#a6e22e>res</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>req</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>head</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>head</span>, <span style=color:#a6e22e>req</span>.<span style=color:#a6e22e>URL</span>.<span style=color:#a6e22e>Path</span> = <span style=color:#a6e22e>ShiftPath</span>(<span style=color:#a6e22e>req</span>.<span style=color:#a6e22e>URL</span>.<span style=color:#a6e22e>Path</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>id</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>strconv</span>.<span style=color:#a6e22e>Atoi</span>(<span style=color:#a6e22e>head</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Error</span>(<span style=color:#a6e22e>res</span>, <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Sprintf</span>(<span style=color:#e6db74>&#34;Invalid user id %q&#34;</span>, <span style=color:#a6e22e>head</span>), <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>StatusBadRequest</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>req</span>.<span style=color:#a6e22e>Method</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#34;GET&#34;</span>:
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>handleGet</span>(<span style=color:#a6e22e>id</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#34;PUT&#34;</span>:
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>handlePut</span>(<span style=color:#a6e22e>id</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>default</span>:
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Error</span>(<span style=color:#a6e22e>res</span>, <span style=color:#e6db74>&#34;Only GET and PUT are allowed&#34;</span>, <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>StatusMethodNotAllowed</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>a</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>App</span>{
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>UserHandler</span>: new(<span style=color:#a6e22e>UserHandler</span>),
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ListenAndServe</span>(<span style=color:#e6db74>&#34;:8000&#34;</span>, <span style=color:#a6e22e>a</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This seems very simple to me (not necessarily in &ldquo;lines of code&rdquo; but
definitely in &ldquo;understandability&rdquo;). You don&rsquo;t need to know anything about any
routers. If you want to understand how the request is routed you start by
looking at <code>main</code>. You see that <code>(*App).ServeHTTP</code> is used to serve any
request so you <code>:GoDef</code> to its definition. You see that it decides to dispatch
to <code>UserHandler</code>, you go to its <code>ServeHTTP</code> method and you see directly how it
parses the URL and what the decisions are that it made on its base.</p><p>We still need to add some patterns to our application. Let&rsquo;s add a profile
handler:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>UserHandler</span> <span style=color:#66d9ef>struct</span>{
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ProfileHandler</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>ProfileHandler</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>h</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>UserHandler</span>) <span style=color:#a6e22e>ServeHTTP</span>(<span style=color:#a6e22e>res</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>req</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>head</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>head</span>, <span style=color:#a6e22e>req</span>.<span style=color:#a6e22e>URL</span>.<span style=color:#a6e22e>Path</span> = <span style=color:#a6e22e>ShiftPath</span>(<span style=color:#a6e22e>req</span>.<span style=color:#a6e22e>URL</span>.<span style=color:#a6e22e>Path</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>id</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>strconv</span>.<span style=color:#a6e22e>Atoi</span>(<span style=color:#a6e22e>head</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Error</span>(<span style=color:#a6e22e>res</span>, <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Sprintf</span>(<span style=color:#e6db74>&#34;Invalid user id %q&#34;</span>, <span style=color:#a6e22e>head</span>), <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>StatusBadRequest</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>req</span>.<span style=color:#a6e22e>URL</span>.<span style=color:#a6e22e>Path</span> <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#34;/&#34;</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>head</span>, <span style=color:#a6e22e>tail</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ShiftPath</span>(<span style=color:#a6e22e>req</span>.<span style=color:#a6e22e>URL</span>.<span style=color:#a6e22e>Path</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>head</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#34;profile&#34;</span>:
</span></span><span style=display:flex><span>			<span style=color:#75715e>// We can&#39;t just make ProfileHandler an http.Handler; it needs the
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#75715e>// user id. Let&#39;s instead…
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>ProfileHandler</span>.<span style=color:#a6e22e>Handler</span>(<span style=color:#a6e22e>id</span>).<span style=color:#a6e22e>ServeHTTP</span>(<span style=color:#a6e22e>res</span>, <span style=color:#a6e22e>req</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#34;account&#34;</span>:
</span></span><span style=display:flex><span>			<span style=color:#75715e>// Left as an exercise to the reader.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>default</span>:
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Error</span>(<span style=color:#a6e22e>res</span>, <span style=color:#e6db74>&#34;Not Found&#34;</span>, <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>StatusNotFound</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#75715e>// As before
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>ProfileHandler</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>h</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>ProfileHandler</span>) <span style=color:#a6e22e>Handler</span>(<span style=color:#a6e22e>id</span> <span style=color:#66d9ef>int</span>) <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Handler</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>HandlerFunc</span>(<span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>res</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>req</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Do whatever
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	})
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This may, again, seem complicated but it has the cool advantage that the
dependencies of <code>ProfileHandler</code> are clear at compile time. It needs a user id
which needs to come from <em>somewhere</em>. Providing it via this kind of method
ensures this is the case. When you refactor your code, you won&rsquo;t accidentally
forget to provide it; it&rsquo;s impossible to miss!</p><p>There are two potential alternatives to this if you prefer them: You could put
the user-id into <code>req.Context()</code> or you could be super-hackish and add them to
<code>req.Form</code>. But I prefer it this way.</p><p>You might argue that <code>App</code> still needs to know all the transitive dependencies
(because they are members, transitively) so we haven&rsquo;t actually reduced
coupling. But that&rsquo;s not true. Its <code>UserHandler</code> could be created by a
<code>NewUserHandler</code> function which gets passed its dependencies via the mechanism
of your choice (flags, dependency injection,…) and gets wired up in <code>main</code>. All
<code>App</code> needs to know is the API of the handlers it&rsquo;s <em>directly</em> invoking.</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>I hope I convinced you that routers <em>in and of itself</em> are harmful. Pulling
the routing into one component means that that component needs to encapsulate
an awful lot of complexity, making it hard to debug. And as no single existing
router will contain all the complicated cleverness you want to base your
routing decisions on, you are tempted to write your own. Which everyone does.</p><p>Instead, split your routing decisions into small, independent chunks and
express them in their own handlers. And wire the dependencies up at compile
time, using the type system of go, and reduce coupling.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.merovius.de/tags/golang/>golang</a></li><li><a href=https://blog.merovius.de/tags/programming/>programming</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://blog.merovius.de/>Mero's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>