<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Backwards compatibility in go | Mero's Blog</title><meta name=keywords content="golang,programming"><meta name=description content="There are next to no &ldquo;backwards compatible API changes&rdquo; in go. You should explicitely name your compatibility-guarantees."><meta name=author content><link rel=canonical href=https://blog.merovius.de/posts/2015-07-29-backwards-compatibility-in-go/><link crossorigin=anonymous href=/assets/css/stylesheet.min.48a18943c2fc15c38a372b8dde1f5e5dc0bc64fa6cb90f5a817d2f8c76b7f3ae.css integrity="sha256-SKGJQ8L8FcOKNyuN3h9eXcC8ZPpsuQ9agX0vjHa3864=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.4dcb3c4f38462f66c6b6137227726f5543cb934cca9788f041c087e374491df2.js integrity="sha256-Tcs8TzhGL2bGthNyJ3JvVUPLk0zKl4jwQcCH43RJHfI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://blog.merovius.de/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.merovius.de/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.merovius.de/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.merovius.de/apple-touch-icon.png><link rel=mask-icon href=https://blog.merovius.de/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Backwards compatibility in go"><meta property="og:description" content="There are next to no &ldquo;backwards compatible API changes&rdquo; in go. You should explicitely name your compatibility-guarantees."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.merovius.de/posts/2015-07-29-backwards-compatibility-in-go/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2015-07-29T01:10:11+00:00"><meta property="article:modified_time" content="2015-07-29T01:10:11+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Backwards compatibility in go"><meta name=twitter:description content="There are next to no &ldquo;backwards compatible API changes&rdquo; in go. You should explicitely name your compatibility-guarantees."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.merovius.de/posts/"},{"@type":"ListItem","position":2,"name":"Backwards compatibility in go","item":"https://blog.merovius.de/posts/2015-07-29-backwards-compatibility-in-go/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Backwards compatibility in go","name":"Backwards compatibility in go","description":"There are next to no \u0026ldquo;backwards compatible API changes\u0026rdquo; in go. You should explicitely name your compatibility-guarantees.","keywords":["golang","programming"],"articleBody":"tl;dr: There are next to no “backwards compatible API changes” in go. You should explicitely name your compatibility-guarantees.\nI really love go, I really hate vendoring and up until now I didn’t really get, why anyone would think go should need something like that. After all, go seems to be predestined to be used with automatically checked semantic versioning. You can enumerate all possible changes to an API in go and the list is quite short. By looking at vcs-tags giving semantic versions and diffing the API, you can automatically check that you never break compatibility (the go compiler and stdlib actually do something like that). Heck, in theory you could even write a package manager that automatically (without any further annotations) determines the latest version of a package that still builds all your stuff or gives you the minimum set of packages that need changes to reconcile conflicts.\nThis thought lead me to contemplate what makes an API change a breaking change. After a bit of thought, my conclusion is that almost every API change is a breaking change, which might surprise you.\nFor this discussion we first need to make some assumptions about what constitutes breakage. We will use the go1 compatibility promise. The main gist is: Stuff that builds before is guaranteed to build after. Notable exceptions (apart from necessary breakages due to security or other bugs) are unkeyed struct literals and dot-imports.\n[edit] I should clarify, that whenever I talk about an API-change, I mean your exported API as defined by Code (as opposed to comments/documentation). This includes the public identifiers exported by your package, including type information. It excludes API-requirements specified in documentation, like on io.Writer. These are just too complex to talk about in a meaningful way and must be dealt with separately anyway. [/edit]\nSo, given this definition of breakage, we can start enumerating all the possible changes you could do to an API and check whether they are breaking under the definition of the go1 compatibility promise:\nAdding func/type/var/const at package scope This is the only thing that seems to be fine under the stability guarantee. It turns out the go authors thought about this one and put the exception of dot-imports into the compatibility promise, which is great.\ndot-imports are imports of the form . import \"foo\". They import every package-level identifier of package foo into the scope of the current file.\nAbsence of dot-imports means, every identifier at your package scope must be referenced with a selector-expression (i.e. foo.Bar) which can’t be redeclared by downstream. It also means that you should never use dot-imports in your packages (which is a bad idea for other reasons too). Treat dot-imports as a historic artifact which is completely deprecated. An exception is the need to use a separate foo_test package for your tests to break dependency cycles. In that case it is widely deemed acceptable to . import \"foo\" to save typing and add clarity.\nRemoving func/type/var/const at package scope Downstream might use the removed function/type/variable/constant, so this is obviously a breaking change.\nAdding a method to an interface Downstream might want to create an implementation of your interface and try to pass it. After you add a method, this type doesn’t implement your interface anymore and downstreams code will break.\nRemoving a method from an interface Downstream might want to call this method on a value of your interface type, so this is obviously a breaking change.\nAdding a field to a struct This is perhaps surprising, but adding a field to a struct is a breaking change. The reason is, that downstream might embed two types into a struct. If one of them has a field or method Bar and the other is a struct you added the Field Bar to, downstream will fail to build (because of an ambiguous selector expression).\nSo, e.g.:\n// foo/foo.go package foo  type Foo struct { \tFoo string \tBar int // Added after the fact }  // bar/bar.go package bar  type Baz struct { \tBar int }  type Spam struct { \tfoo.Foo \tBaz }  func Eggs() { \tvar s Spam \ts.Bar = 42 // ambiguous selector s.Bar } This is what the compatibility might refer to with the following quote:\n Code that uses unkeyed struct literals (such as pkg.T{3, “x”}) to create values of these types would fail to compile after such a change. However, code that uses keyed literals (pkg.T{A: 3, B: “x”}) will continue to compile after such a change. We will update such data structures in a way that allows keyed struct literals to remain compatible, although unkeyed literals may fail to compile. (There are also more intricate cases involving nested data structures or interfaces, but they have the same resolution.)\n (emphasis is mine). By “the same resolution” they might refer to only accessing embedded Fields via a keyed selector (so e.g. s.Baz.Bar in above example). If so, that is pretty obscure and it makes struct-embedding pretty much useless. Every usage of a field or method of an embedded type must be explicitly Keyed, which means you can just not embed it after all. You need to write the selector and wrap every embedded method anyway.\nI hope we all agree that type embedding is awesome and shouldn’t need to be avoided :)\nRemoving a field from a struct Downstream might use the now removed field, so this is obviously a breaking change.\nAdding a method to a type The argument is pretty much the same as adding a field to a struct: Downstream might embed your type and suddenly get ambiguities.\nRemoving a method from a type Downstream might call the now removed method, so this is obviously a breaking change.\nChanging a function/method signature Most changes are obviously breaking. But as it turns out you can’t do any change to a function or method signature. This includes adding a variadic argument which looks backwards compatible on the surface. After all, every call site will still be correct, right?\nThe reason is, that downstream might save your function or method in a variable of the old type, which will break because of nonassignable types.\nConclusion It looks to me like anything that isn’t just adding a new Identifier to the package-scope will potentially break some downstream. This severely limits the kind of changes you can do to your API if you want to claim backwards compatibility.\nThis of course doesn’t mean that you should never ever make any changes to your API ever. But you should think about it and you should clearly document, what kind of compatibility guarantees you make. When you do any changes named in this document, you should check your downstreams, whether they are affected by it. If you claim a similar level of compatibility as the go standard library, you should definitely be aware of the implications and what you can and can’t do.\nWe, the go community, should probably come up with some coherent definition of what changes we deem backwards compatible and which we don’t. A tool to automatically looks up all your (public) importerts on godoc.org, downloads the latest version and tries to build them with your changes should be fairly simple to write in go (and may even already exist). We should make it a standard check (like go vet and golint) for upstream package authors to do that kind of thing before push to prevent frustrated downstreams.\nOf course there is still the possibility, that my reading of the go1 compatibility promise is wrong or inaccurate. I would welcome comments on that, just like on everything else in this post :)\n","wordCount":"1270","inLanguage":"en","datePublished":"2015-07-29T01:10:11Z","dateModified":"2015-07-29T01:10:11Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.merovius.de/posts/2015-07-29-backwards-compatibility-in-go/"},"publisher":{"@type":"Organization","name":"Mero's Blog","logo":{"@type":"ImageObject","url":"https://blog.merovius.de/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.merovius.de/ accesskey=h title="Mero's Blog (Alt + H)">Mero's Blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Backwards compatibility in go</h1><div class=post-meta><span title="2015-07-29 01:10:11 +0000 UTC">July 29, 2015</span></div></header><div class=post-content><p><strong>tl;dr: There are next to no &ldquo;backwards compatible API changes&rdquo; in go. You
should explicitely name your compatibility-guarantees.</strong></p><p>I really love go, I really hate vendoring and up until now I didn&rsquo;t really get,
why anyone would think go should need something like that. After all, go seems
to be predestined to be used with automatically checked semantic versioning.
You can enumerate all possible changes to an API in go and the list is quite
short. By looking at vcs-tags giving semantic versions and diffing the API, you
can automatically check that you never break compatibility (the go compiler and
stdlib actually do something like that). Heck, in theory you could even write a
package manager that automatically (without any further annotations) determines
the latest version of a package that still builds all your stuff or gives you
the minimum set of packages that need changes to reconcile conflicts.</p><p>This thought lead me to contemplate what makes an API change a breaking
change. After a bit of thought, my conclusion is that almost every API change
is a breaking change, which might surprise you.</p><p>For this discussion we first need to make some assumptions about what
constitutes breakage. We will use the <a href=http://golang.org/doc/go1compat>go1 compatibility promise</a>.
The main gist is: Stuff that builds before is guaranteed to build after.
Notable exceptions (apart from necessary breakages due to security or other
bugs) are unkeyed struct literals and dot-imports.</p><p><strong>[edit]</strong>
I should clarify, that whenever I talk about an API-change, I mean
your exported API as defined by Code (as opposed to comments/documentation).
This includes the public identifiers exported by your package, including type
information. It excludes API-requirements specified in documentation, like on
<a href=http://golang.org/pkg/io/#Writer>io.Writer</a>. These are just too complex to
talk about in a meaningful way and must be dealt with separately anyway.
<strong>[/edit]</strong></p><p>So, given this definition of breakage, we can start enumerating all the
possible changes you could do to an API and check whether they are breaking
under the definition of the go1 compatibility promise:</p><h2 id=adding-functypevarconst-at-package-scope>Adding func/type/var/const at package scope<a hidden class=anchor aria-hidden=true href=#adding-functypevarconst-at-package-scope>#</a></h2><p>This is the only thing that seems to be fine under the stability guarantee. It
turns out the go authors thought about this one and put the exception of
dot-imports into the compatibility promise, which is great.</p><p>dot-imports are imports of the form <code>. import "foo"</code>. They import every
package-level identifier of package <code>foo</code> into the scope of the current file.</p><p>Absence of dot-imports means, every identifier at your package scope must be
referenced with a selector-expression (i.e. <code>foo.Bar</code>) which can&rsquo;t be redeclared
by downstream. It also means that you should never use dot-imports in your
packages (which is a bad idea for other reasons too). Treat dot-imports as a
historic artifact which is completely deprecated. An exception is the need
to use a separate <code>foo_test</code> package for your tests to break dependency cycles.
In that case it is widely deemed acceptable to <code>. import "foo"</code> to save typing
and add clarity.</p><h2 id=removing-functypevarconst-at-package-scope>Removing func/type/var/const at package scope<a hidden class=anchor aria-hidden=true href=#removing-functypevarconst-at-package-scope>#</a></h2><p>Downstream might use the removed function/type/variable/constant, so this is
obviously a breaking change.</p><h2 id=adding-a-method-to-an-interface>Adding a method to an interface<a hidden class=anchor aria-hidden=true href=#adding-a-method-to-an-interface>#</a></h2><p>Downstream might want to create an implementation of your interface and try to
pass it. After you add a method, this type doesn&rsquo;t implement your interface
anymore and downstreams code will break.</p><h2 id=removing-a-method-from-an-interface>Removing a method from an interface<a hidden class=anchor aria-hidden=true href=#removing-a-method-from-an-interface>#</a></h2><p>Downstream might want to call this method on a value of your interface type, so
this is obviously a breaking change.</p><h2 id=adding-a-field-to-a-struct>Adding a field to a struct<a hidden class=anchor aria-hidden=true href=#adding-a-field-to-a-struct>#</a></h2><p>This is perhaps surprising, but adding a field to a struct is a breaking
change. The reason is, that downstream might embed two types into a struct. If
one of them has a field or method Bar and the other is a struct you added the
Field Bar to, downstream will fail to build (because of an ambiguous selector
expression).</p><p>So, e.g.:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// foo/foo.go
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>package</span> <span style=color:#a6e22e>foo</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Foo</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Foo</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Bar</span> <span style=color:#66d9ef>int</span> <span style=color:#75715e>// Added after the fact
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// bar/bar.go
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>package</span> <span style=color:#a6e22e>bar</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Baz</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Bar</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Spam</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>foo</span>.<span style=color:#a6e22e>Foo</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Baz</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Eggs</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>s</span> <span style=color:#a6e22e>Spam</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>Bar</span> = <span style=color:#ae81ff>42</span> <span style=color:#75715e>// ambiguous selector s.Bar
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>This is what the compatibility <em>might</em> refer to with the following quote:</p><blockquote><p>Code that uses unkeyed struct literals (such as pkg.T{3, &ldquo;x&rdquo;}) to create values
of these types would fail to compile after such a change. However, code that
uses keyed literals (pkg.T{A: 3, B: &ldquo;x&rdquo;}) will continue to compile after such a
change. We will update such data structures in a way that allows keyed struct
literals to remain compatible, although unkeyed literals may fail to compile.
(<strong>There are also more intricate cases involving nested data structures or
interfaces</strong>, but they have the same resolution.)</p></blockquote><p>(emphasis is mine). By &ldquo;the same resolution&rdquo; they <em>might</em> refer to only accessing
embedded Fields via a keyed selector (so e.g. <code>s.Baz.Bar</code> in above example). If
so, that is pretty obscure and it makes struct-embedding pretty much
useless. Every usage of a field or method of an embedded type must be
explicitly Keyed, which means you can just <em>not</em> embed it after all. You need
to write the selector and wrap every embedded method anyway.</p><p>I hope we all agree that type embedding is awesome and shouldn&rsquo;t need to be
avoided :)</p><h2 id=removing-a-field-from-a-struct>Removing a field from a struct<a hidden class=anchor aria-hidden=true href=#removing-a-field-from-a-struct>#</a></h2><p>Downstream might use the now removed field, so this is obviously a breaking change.</p><h2 id=adding-a-method-to-a-type>Adding a method to a type<a hidden class=anchor aria-hidden=true href=#adding-a-method-to-a-type>#</a></h2><p>The argument is pretty much the same as adding a field to a struct: Downstream
might embed your type and suddenly get ambiguities.</p><h2 id=removing-a-method-from-a-type>Removing a method from a type<a hidden class=anchor aria-hidden=true href=#removing-a-method-from-a-type>#</a></h2><p>Downstream might call the now removed method, so this is obviously a breaking change.</p><h2 id=changing-a-functionmethod-signature>Changing a function/method signature<a hidden class=anchor aria-hidden=true href=#changing-a-functionmethod-signature>#</a></h2><p>Most changes are obviously breaking. But as it turns out you can&rsquo;t do <em>any</em>
change to a function or method signature. This includes adding a variadic
argument which <em>looks</em> backwards compatible on the surface. After all, every
call site will still be correct, right?</p><p>The reason is, that downstream might save your function or method in a variable
of the old type, which will break because of nonassignable types.</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>It looks to me like anything that isn&rsquo;t just adding a new Identifier to the
package-scope will potentially break <em>some</em> downstream. This severely limits
the kind of changes you can do to your API if you want to claim backwards
compatibility.</p><p>This of course doesn&rsquo;t mean that you should never ever make any changes to your
API ever. But you should think about it and you should clearly document, what
kind of compatibility guarantees you make. When you do any changes named in
this document, you should check your downstreams, whether they are affected by
it. If you claim a similar level of compatibility as the go standard library,
you should definitely be aware of the implications and what you can and can&rsquo;t
do.</p><p>We, the go community, should probably come up with some coherent definition of
what changes we deem backwards compatible and which we don&rsquo;t. A tool to
automatically looks up all your (public) importerts on
<a href=https://godoc.org/>godoc.org</a>, downloads the latest version and tries to
build them with your changes should be fairly simple to write in go (and may
even already exist). We should make it a standard check (like go vet and
golint) for upstream package authors to do that kind of thing before push to
prevent frustrated downstreams.</p><p>Of course there is still the possibility, that my reading of the go1
compatibility promise is wrong or inaccurate. I would welcome comments on that,
just like on everything else in this post :)</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.merovius.de/tags/golang/>golang</a></li><li><a href=https://blog.merovius.de/tags/programming/>programming</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://blog.merovius.de/>Mero's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>