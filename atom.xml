<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-us"><generator uri="https://gohugo.io/" version="0.96.0">Hugo</generator><title type="html">Mero's Blog</title><link href="https://blog.merovius.de/"/><link type="application/atom+xml" rel="self" href="https://blog.merovius.de/atom.xml"/><updated>2022-04-06T10:35:35+00:00</updated><id>https://blog.merovius.de/</id><author><name>Axel Wagner</name></author><entry><title type="html">Parametric context</title><link href="https://blog.merovius.de/posts/2020-07-20-parametric-context/" rel="alternate" type="text/html"/><id>https://blog.merovius.de//2020/07/20/parametric-context.html</id><published>2020-07-20T00:00:00+00:00</published><updated>2020-07-20T00:00:00+00:00</updated><content type="html"><![CDATA[<p><strong>tl;dr: Go&rsquo;s Context.Value is controversial because of a lack of type-safety. I design a solution for that based on the new generics design draft.</strong></p>
<p>If you are following what&rsquo;s happening with Go, you are aware that recently
<a href="https://blog.golang.org/generics-next-step">an updated design draft for generics has dropped</a>.
What makes this particularly notable is that it comes with an actual prototype
implementation of the draft, including a <a href="https://go2goplay.golang.org/">playground</a>.
This means for the first time, people get to actually try out how a Go with
generics might feel, once they get in. It is a good opportunity to look at
common Go code lacking type-safety and evaluate if and how generics can help
address them.</p>
<p>One area I&rsquo;d like to look at here is <a href="https://godoc.org/context#Context.Value">Context.Value</a>. It is often criticized
for not being explicit enough about the dependencies a function has and some
people even go so far as to discourage its use altogether. On the other hand,
I&rsquo;m on record <a href="/posts/2017-08-14-why-context-value-matters-and-how-to-improve-it/">saying that it is too useful to ignore</a>. Generics
might be a way to bring together these viewpoints.</p>
<p>We want to be able to declare dependency on a functionality in
<code>context.Context</code> via a function&rsquo;s signature and make it impossible to call it
without providing that functionality, while also preserving the ability to pass
it through APIs that don&rsquo;t know anything about it. As an example of such
functionality, I will use logging. Let&rsquo;s start by creating a fictional little
library to do that (the names are not ideal, but let&rsquo;s not worry about that):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">logctx</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;context&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;log&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">LogContext</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// We embed a context.Context, to say that we are augmenting it with
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// additional functionality.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Logf logs the given values in the given format.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">Logf</span>(<span style="color:#a6e22e">format</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">values</span> <span style="color:#f92672">...</span><span style="color:#66d9ef">interface</span>{})
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">WithLog</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>, <span style="color:#a6e22e">l</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Logger</span>) <span style="color:#a6e22e">LogContext</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">logContext</span>{<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">l</span>}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// logContext is unexported, to ensure it can&#39;t be modified.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">logContext</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">l</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Logger</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">logContext</span>) <span style="color:#a6e22e">Logf</span>(<span style="color:#a6e22e">format</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">values</span> <span style="color:#f92672">...</span><span style="color:#66d9ef">interface</span>{}) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#a6e22e">format</span>, <span style="color:#a6e22e">values</span><span style="color:#f92672">...</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>You might notice that we are not actually using <code>Value()</code> here. This is
fundamental to the idea of getting compiler-checks - we need some
compiler-known way to &ldquo;tag&rdquo; functionality and that can&rsquo;t be <code>Value</code>. However,
we provide the same functionality, by essentially adding an <a href="/posts/2017-07-30-the-trouble-with-optional-interfaces/">optional
interface</a> to <code>context.Context</code>.</p>
<p>If we want to use this, we could write</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Foo</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">logctx</span>.<span style="color:#a6e22e">LogContext</span>, <span style="color:#a6e22e">v</span> <span style="color:#66d9ef">int</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">Logf</span>(<span style="color:#e6db74">&#34;Foo(%v)&#34;</span>, <span style="color:#a6e22e">v</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ctx</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">logctx</span>.<span style="color:#a6e22e">WithLog</span>(<span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Background</span>(), <span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">New</span>(<span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Stderr</span>, <span style="color:#e6db74">&#34;&#34;</span>, <span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">LstdFlags</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Foo</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#ae81ff">42</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>However, this has a huge problem: What if we want more than one functionality
(each not knowing about the other)? We might try the same trick, say</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">tracectx</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;context&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;github.com/opentracing/opentracing-go&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">TraceContext</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Tracer</span>() <span style="color:#a6e22e">opentracing</span>.<span style="color:#a6e22e">Tracer</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">WithTracer</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>, <span style="color:#a6e22e">t</span> <span style="color:#a6e22e">opentracing</span>.<span style="color:#a6e22e">Tracer</span>) <span style="color:#a6e22e">TraceContext</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">traceContext</span>{<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">t</span>}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">traceContext</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">t</span> <span style="color:#a6e22e">opentracing</span>.<span style="color:#a6e22e">Tracer</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">traceContext</span>) <span style="color:#a6e22e">Tracer</span>() <span style="color:#a6e22e">opentracing</span>.<span style="color:#a6e22e">Tracer</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">t</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>But because a <code>context.Context</code> is embedded, only those methods explicitly
mentioned in that interface are added to <code>traceContext</code>. The <code>Logf</code> method is
erased. After all, that is <a href="/posts/2017-07-30-the-trouble-with-optional-interfaces/">the trouble with optional interfaces</a>.</p>
<p>This is where generics come in. We can change our wrapper-types and -functions like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">LogContext</span>(<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">parent</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>) <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// the type-parameter is lower case, so the field is not exported.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">parent</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">l</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Logger</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">WithLog</span>(<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Parent</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>) (<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">Parent</span>, <span style="color:#a6e22e">l</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Logger</span>) <span style="color:#a6e22e">LogContext</span>(<span style="color:#a6e22e">Parent</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">LogContext</span>(<span style="color:#a6e22e">parent</span>){<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">l</span>}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>By adding a type-parameter and embedding it, we actually get <em>all</em> methods of
the parent context on <code>LogContext</code>. We are no longer erasing them. After giving
the <code>tracectx</code> package the same treatment, we can use them like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// FooContext encapsulates all the dependencies of Foo in a context.Context.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">FooContext</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Logf</span>(<span style="color:#a6e22e">format</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">values</span> <span style="color:#f92672">...</span><span style="color:#66d9ef">interface</span>{})
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Tracer</span>() <span style="color:#a6e22e">opentracing</span>.<span style="color:#a6e22e">Tracer</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Foo</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">FooContext</span>, <span style="color:#a6e22e">v</span> <span style="color:#66d9ef">int</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">span</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">Tracer</span>().<span style="color:#a6e22e">StartSpan</span>(<span style="color:#e6db74">&#34;Foo&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">span</span>.<span style="color:#a6e22e">Finish</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">Logf</span>(<span style="color:#e6db74">&#34;Foo(%v)&#34;</span>, <span style="color:#a6e22e">v</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">l</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">New</span>(<span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Stderr</span>, <span style="color:#e6db74">&#34;&#34;</span>, <span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">LstdFlags</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">t</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">opentracing</span>.<span style="color:#a6e22e">GlobalTracer</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ctx has type TraceContext(LogContext(context.Context)),
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//    which embeds a LogContext(context.Context),
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//    which embeds a context.Context
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// So it has all the required methods
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">ctx</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">tracectx</span>.<span style="color:#a6e22e">WithTracer</span>(<span style="color:#a6e22e">logctx</span>.<span style="color:#a6e22e">WithLog</span>(<span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Background</span>(), <span style="color:#a6e22e">l</span>), <span style="color:#a6e22e">t</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Foo</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#ae81ff">42</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>Foo</code> has now fully declared its dependencies on a logger and a tracectx, without
requiring any type-assertions or runtime-checks. The logging- and
tracing-libraries don&rsquo;t know about each other and yet are able to wrap each
other without loss of type-information. Constructing the context is not
particularly ergonomic though. We require a long chained function call, because
the values returned by the functions have no longer a unified type
<code>context.Context</code> (so the <code>ctx</code> variable can&rsquo;t be re-used).</p>
<p>Another thing to note is that we exported <code>LogContext</code> as a struct, instead of
an interface. This is necessary, because we can&rsquo;t embed type-parameters into
interfaces, but we <em>can</em> embed them as struct-fields. So this is the only way
we can express that the returned type has all the methods the parameter type
has. The downside is that we are making this a concrete type, which isn&rsquo;t
always what we want<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>.</p>
<p>We have now succeeded in annotating <code>context.Context</code> with dependencies, but
this alone is not super useful of course. We also need to be able to pass it
through agnostic APIs (the fundamental problem <code>Context.Value</code> solves).
However, this is easy enough to do.</p>
<p>First, let&rsquo;s change the <code>context</code> API to use the same form of generic wrappers.
This isn&rsquo;t backwards compatible, of course, but this entire blog post is a
thought experiment, so we are ignoring that. I don&rsquo;t provide the full code
here, for brevity&rsquo;s sake, but the basic API would change into this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">context</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// CancelContext is the generic version of the currently unexported cancelCtx.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">CancelContext</span>(<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">parent</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>) <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">parent</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// other fields
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">WithCancel</span>(<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Parent</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>) (<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">Parent</span>) (<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">CancelContext</span>(<span style="color:#a6e22e">Parent</span>), <span style="color:#a6e22e">cancel</span> <span style="color:#a6e22e">CancelFunc</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>This change is necessary to enable <code>WithCancel</code> to also preserve methods of the
parent context. We can now use this in an API that passes through a parametric
context.  For example, say we want to have an <a href="https://godoc.org/golang.org/x/sync/errgroup">errgroup</a> package, that passes
the context through to the argument to <code>(*Group).Go</code>, instead of returning it
from <code>WithContext</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// Derived from the current errgroup code.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// A Group is a collection of goroutines working on subtasks that are part of the same overall task.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// A zero Group is invalid (as opposed to the original errgroup).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Group</span>(<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Context</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>) <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ctx</span>    <span style="color:#a6e22e">Context</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">cancel</span> <span style="color:#66d9ef">func</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">wg</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">errOnce</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">Once</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">err</span>     <span style="color:#66d9ef">error</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">WithContext</span>(<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">C</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>) (<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">C</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">Group</span>(<span style="color:#a6e22e">C</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">cancel</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">WithCancel</span>(<span style="color:#a6e22e">ctx</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Group</span>(<span style="color:#a6e22e">C</span>){<span style="color:#a6e22e">ctx</span>: <span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">cancel</span>: <span style="color:#a6e22e">cancel</span>}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">g</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Group</span>(<span style="color:#a6e22e">Context</span>)) <span style="color:#a6e22e">Wait</span>() <span style="color:#66d9ef">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">g</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Group</span>(<span style="color:#a6e22e">Context</span>)) <span style="color:#a6e22e">Go</span>(<span style="color:#a6e22e">f</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">Context</span>) <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">ctx</span>); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">errOnce</span>.<span style="color:#a6e22e">Do</span>(<span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>            })
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Note that the code here has barely changed. It can be used as</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Foo</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">FooContext</span>) <span style="color:#66d9ef">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">span</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">Tracer</span>().<span style="color:#a6e22e">StartSpan</span>(<span style="color:#e6db74">&#34;Foo&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">span</span>.<span style="color:#a6e22e">Finish</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">Logf</span>(<span style="color:#e6db74">&#34;Foo was called&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">FooContext</span> = <span style="color:#a6e22e">newFooContext</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">eg</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">errgroup</span>.<span style="color:#a6e22e">WithContext</span>(<span style="color:#a6e22e">ctx</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">20</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">eg</span>.<span style="color:#a6e22e">Go</span>(<span style="color:#a6e22e">Foo</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">eg</span>.<span style="color:#a6e22e">Wait</span>(); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Fatal</span>(<span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>After playing around with this for a couple of days, I feel pretty confident
that these patterns make it possible to get a fully type-safe version of
<code>context.Context</code>, while preserving the ability to have APIs that pass it
through untouched or augmented.</p>
<p>A completely different question, of course, is whether all of this is a good
idea. Personally, I am on the fence about it. It is definitely valuable, to
have a type-safe version of <code>context.Context</code>. And I think it is impressive how
small the impact of it is on the <em>users</em> of APIs written this way. The
type-argument can almost always be inferred and writing code to make use of this
is very natural - you just declare a suitable context-interface and take it as
an argument. You can also freely pass it to functions taking a pure
<code>context.Context</code> unimpeded.</p>
<p>On the other hand, I am not completely convinced the cost is worth it. As soon
as you do non-trivial things with a context, it becomes a pretty &ldquo;infectious&rdquo;
change. For example, I played around with a <a href="https://go2goplay.golang.org/p/9-xQZufcGp_k">mock gRPC API</a> to allow
interceptors to take a parametric context and it requires almost all types and
functions involved to take a type-parameter. And this doesn&rsquo;t even touch on the
fact that gRPC itself might want to add annotations to the context, which adds
even more types. I am not sure if the additional machinery is really worth the
benefit of some type-safety - especially as it&rsquo;s not always super intuitive and
easily understandable. And even more so, if it needs to be combined with other
type-parameters, to achieve other goals.</p>
<p>I think this is an example of what I tend to dislike about generics and powerful
type-systems in general. They tempt you to write a lot of extra machinery and
types in a way that isn&rsquo;t necessarily semantically meaningful, but only used to
encode some invariant in a way the compiler understands.</p>
<hr>
<p>I don&rsquo;t actually think there is much of a performance problem with
<code>context.Value</code> in practice, but if there is, this could solve that.</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>One <em>upside</em> however, is that this could actually address
the <em>other</em> criticism of <code>context.Value</code>: Its performance. If we consequently embed the
parent-context as values in struct fields, the final context will be a flat
struct. The interface-table of all the extra methods we add will point at the
concrete implementations. There&rsquo;s no longer any need for a linear search to
find a context value.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
]]></content></entry><entry><title type="html">A bird's eye view of Go</title><link href="https://blog.merovius.de/posts/2019-06-12-birdseye-go/" rel="alternate" type="text/html"/><id>https://blog.merovius.de//2019/06/12/birdseye-go.html</id><published>2019-06-12T00:00:00+00:00</published><updated>2019-06-12T00:00:00+00:00</updated><content type="html"><![CDATA[<p><strong>tl;dr: I provide a very high-level overview of what Go-the-language means vs. Go-the-ecosystem vs. Go-an-implementation. I also try to provide specific references to what documentation is most useful for what purpose. See the bottom-most section for that.</strong></p>
<p>When we talk about &ldquo;Go&rdquo;, depending on context, we can mean very different
things. This is my attempt at providing a very high-level overview of the
language and ecosystem and to link to the relevant documentation about how each
part fits together (it&rsquo;s also a bit of a hodgepodge though, addressing
individual random questions I encountered recently). So, let&rsquo;s dive in:</p>
<h2 id="the-go-programming-language">The Go programming language</h2>
<p>The bottom turtle is Go, the programming language. It defines the format and
meaning of source code and the authoritative source is
<a href="https://golang.org/ref/spec">the Go language specification</a>. If something
doesn&rsquo;t conform to the spec, it&rsquo;s not &ldquo;Go&rdquo;. And conversely, if something
<em>isn&rsquo;t</em> mentioned in the spec it&rsquo;s not part of the language. The language spec
is maintained by the Go team and versioned, with a new release roughly every
six months. At the time I wrote this post, the newest release was version
<code>1.12</code>.</p>
<p>The domain of the spec are</p>
<ul>
<li>The grammar of the language</li>
<li>Types, values and their semantics</li>
<li>What identifiers are predeclared and what their meaning is</li>
<li>How Go programs get executed</li>
<li>The special package <a href="https://golang.org/ref/spec#Package_unsafe">unsafe</a>
(though not all of its semantics)</li>
</ul>
<p>The spec alone <em>should</em> enable you to write a compiler for Go. And indeed,
there are many different compilers.</p>
<h2 id="a-go-compiler-and-runtime">A Go compiler and runtime</h2>
<p>The language spec is a text document, which is not useful in and of itself.
For that you need software that actually implements these semantics. This is
done by a compiler (which analyzes and checks the source code and
transforms it into an executable format) and a runtime (which provides the
necessary environment to actually run the code). There are many such
combinations and they all differ a bit more or a bit less. Examples are</p>
<ul>
<li><code>gc</code>, a compiler and runtime written in pure Go (with some assembly) by the
Go team themselves and versioned and released together with the language.
Unlike other such tools, <code>gc</code> doesn&rsquo;t <em>strictly</em> separate the compiler,
assembler and linker - they end up sharing a lot of code and some of the
classical responsibilities move or are shared between them. As such, it&rsquo;s in
general not possible to e.g. link packages compiled by different versions of
<code>gc</code>.</li>
<li><a href="https://golang.org/doc/install/gccgo">gccgo and libgo</a>, a frontend for gcc
and a runtime. It&rsquo;s written in C and maintained by the Go team. It lives in
the gcc organization though and is released according to the gcc release
schedule and thus often lags a bit behind the &ldquo;latest&rdquo; version of the Go
spec.</li>
<li><a href="https://llvm.org/svn/llvm-project/llgo/trunk/README.TXT">llgo</a>, a frontend
for LLVM. I don&rsquo;t know much else about it.</li>
<li><a href="https://github.com/gopherjs/gopherjs">gopherjs</a>, compiling Go code into
javascript and using a javascript VM plus some custom code as a runtime.
Long-term, it&rsquo;ll probably be made obsolete by <code>gc</code> gaining native support for
WebAssembly.</li>
<li><a href="https://tinygo.org/">tinygo</a>, an incomplete implementation targeting small
code size. Runs on either bare-metal micro-controllers or WebAssembly VMs,
with a custom runtime. Due to its limitations it doesn&rsquo;t <em>technically</em>
implement Go - notably, it doesn&rsquo;t include a garbage collector, concurrency
or reflection.</li>
</ul>
<p>There are more, but this gives you an overview over the variety
of implementations. Each of these made potentially different choices
for how to implement the language and have their own idiosyncrasies.
Examples (some of them a bit exotic, to illustrate) where they might differ are:</p>
<ul>
<li>Size of <code>int</code>/<code>uint</code> - the language allows them to be either 32 or 64 bit wide.</li>
<li>How fundamental functionalities of the runtime, like allocation, garbage
collection or concurrency are implemented.</li>
<li>The order of ranging over a <code>map</code> isn&rsquo;t defined in the language - <code>gc</code>
famously explicitly randomizes it, <code>gopherjs</code> uses (last time I checked)
whatever the javascript implementation you are running on uses.</li>
<li>How much extra space <code>append</code> allocates if it needs to - <em>not</em> however,
<em>when</em> it allocates extra space.</li>
<li>How conversions between <code>unsafe.Pointer</code> and <code>uintptr</code> happen. <code>gc</code>, in
particular, comes with its own <a href="https://godoc.org/unsafe#Pointer">set of rules</a>
regarding when these conversions are valid and when they aren&rsquo;t. In general,
the <code>unsafe</code> package is virtual and implemented in the compiler.</li>
</ul>
<p>In general, relying on details not mentioned in the spec (in particular the
ones mentioned here) makes your program <em>compile</em> with different compilers, but
not <em>work</em> as expected. So you should avoid it if possible.</p>
<p>If you install Go via a &ldquo;normal&rdquo; way (by downloading it from the website, or
installing it via a package manager), you&rsquo;ll get <code>gc</code> and the official
runtime by the Go team. And if the context doesn&rsquo;t imply otherwise, when
we talk about how &ldquo;Go does things&rdquo;, we usually refer to <code>gc</code>. It&rsquo;s the main
implementation.</p>
<h2 id="the-standard-library">The standard library</h2>
<p><a href="https://golang.org/pkg/#stdlib">The standard library</a> is a set of packages
that come with Go and can be relied upon to immediately build useful
applications with. It too is maintained by the Go team and versioned and
released together with the language and compiler. In general the standard
library of one implementation will only work with the compiler it comes with.
The reason is that most (but not all) of the runtime is part of the standard
library (mainly in the packages <code>runtime</code>, <code>reflect</code>, <code>syscall</code>). As the
compiler needs to generate code compatible with the used runtime, both need to
come from the same version.  The <em>API</em> of the standard library is stable and
won&rsquo;t change in incompatible ways, so a Go program written against a given
version of the standard library will continue to work as expected with future
versions of the compiler.</p>
<p>Some implementations use their own version of some or all of the standard
library - in particular, the <code>runtime</code>, <code>reflect</code>, <code>unsafe</code> and <code>syscall</code>
packages are completely implementation-defined. As an example, I believe that
<a href="https://cloud.google.com/appengine/docs/standard/go/">AppEngine Standard</a> used
to re-define parts of the standard library for security and safety. In general,
implementations try to make that transparent to the user.</p>
<p>There is also a <a href="https://golang.org/pkg/#subrepo">separate set of repositories</a>,
colloquially referred to as <code>x</code> or &ldquo;the subrepositories&rdquo;. They contain packages
which are developed and maintained by the Go team with all the same processes,
but are <em>not</em> on the same release schedule as the language and have less strict
compatibility guarantees (and commitment to maintainership) than <a href="https://golang.org/doc/go1compat">Go itself</a>.
The packages in there are either experimental (for potential future inclusion
in the standard library), not widely useful enough to be included in the
standard library or, in rare cases, a way for people on the Go team to work on
code using the same review processes they are used to.</p>
<p>Again, when referring to &ldquo;the standard library&rdquo; devoid of extra context, we
mean the officially maintained and distributed one, hosted on
<a href="https://golang.org/pkg">golang.org</a>.</p>
<h2 id="the-build-tool">The build tool</h2>
<p>To make the language user-friendly, you need a build tool. The primary role of
this tool is to find the package you want to compile, find all of its
dependencies, and execute the compiler and linker with the arguments necessary
to build them. Go (the language) has <a href="https://golang.org/ref/spec#Packages">support for packages</a>,
which combine multiple source files into one unit of compilation. And it
defines how to import and use other packages. But importantly, it doesn&rsquo;t
define how import paths map to source files or how they are laid out on disk.
As such, each build tool comes with its own ideas for this. It&rsquo;s possible to
use a generic build tool (like Make) for this purpose, but there are a bunch of
Go-specific ones:</p>
<ul>
<li><a href="https://golang.org/cmd/go/">The go tool</a><sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup> is the build tool officially maintained
by the Go team. It is versioned and released with the language (and
<code>gc</code> and the standard library). It expects a directory called <code>GOROOT</code> (from
an environment variable, with a compiled default) to contain the compiler,
the standard library and various other tools. And it expects all source code
in a single directory called <code>GOPATH</code> (from an environment variable,
defaulting to <code>$HOME/go</code> or equivalent). Specifically, package <code>a/b</code> is
expected to have its source at <code>$GOPATH/src/a/b/c.go</code> etc. And
<code>$GOPATH/src/a/b</code> is expected to <em>only</em> contain source files of one package.
It also has a mechanism to
<a href="https://golang.org/cmd/go/#hdr-Remote_import_paths">download a package and its dependencies recursively from an arbitrary server</a>,
in a fully decentralized scheme, though it does not support versioning or
verification of downloads. The go tool also contains extra tooling for
testing Go code, reading documentation (<a href="https://golang.org">golang.org</a> is
served by the Go tool), file bugs, run various tools…</li>
<li><a href="https://github.com/gopherjs/gopherjs">gopherjs</a> comes with its own build
tool, that largely mimics the Go tool.</li>
<li><a href="https://github.com/golang/go/wiki/Mobile">gomobile</a> is a build tool
specifically to build Go code for mobile operating systems.</li>
<li><a href="https://github.com/golang/dep">dep</a>, <a href="https://getgb.io/">gb</a>,
<a href="https://glide.sh/">glide</a>,… are community-developed build-tools and
dependency managers, each with their own approach to file layout (some are
compatible with the go tool, some aren&rsquo;t) and dependency declarations.</li>
<li><a href="https://bazel.build/">bazel</a> is the open source version of Google&rsquo;s own
build system. While it&rsquo;s not actually Go-specific, I&rsquo;m mentioning it
explicitly due to common claims that idiosyncrasies of the go tool are
intended to serve Google&rsquo;s own use cases, in conflict with the needs of the
community. However, the go tool (and many public tools) can&rsquo;t be used at
Google, because bazel uses an incompatible file layout.</li>
</ul>
<p>The build tool is what most users directly interface with and as such, it&rsquo;s
what largely determines aspects of the <em>Go ecosystem</em> and how packages can be
combined and thus how different Go programmers interact. As above, the go tool
is what&rsquo;s implicitly referred to (unless other context is specified) and thus its
design decisions significantly influence public opinion about &ldquo;Go&rdquo;. While there
are alternative tools and they have wide adoption for use cases like
company-internal code, the open source community <em>in general</em> expects code to
conform to the expectations of the go tool, which (among other things) means:</p>
<ul>
<li>Be available as source code. The go tool has little support for binary
distribution of packages, and what little it has is going to be removed soon.</li>
<li>Be documented according to <a href="https://blog.golang.org/godoc-documenting-go-code">the godoc format</a>.</li>
<li><a href="https://golang.org/pkg/testing/#pkg-overview">Have tests</a> that can be run via <code>go test</code>.</li>
<li>Be fully compilable by a <code>go build</code> (together with the next one, this is
usually called being &ldquo;go-gettable&rdquo;). In particular, to use <a href="https://golang.org/pkg/cmd/go/internal/generate/">go generate</a>
if generating source-code or metaprogramming is required and commit the generated
artifacts.</li>
<li>Namespace import paths with a domain-name as the first component and have
that domain-name either be a well-known code hoster or have a webserver
running on it, so that <a href="https://golang.org/cmd/go/#hdr-Remote_import_paths">go get works</a>
and can find the source code of dependencies.</li>
<li>Have one package per directory and use <a href="https://golang.org/pkg/go/build/#hdr-Build_Constraints">build constraints</a>
for conditional compilation.</li>
</ul>
<p>The <a href="https://golang.org/cmd/go">documentation of the go tool</a> is very
comprehensive and probably a good starting point to learn how Go implements
various ecosystem aspects.</p>
<h2 id="tools">Tools</h2>
<p>Go&rsquo;s standard library includes <a href="https://golang.org/pkg/go/">several packages to interact with Go source code</a>
and the <a href="https://godoc.org/golang.org/x/tools/go">x/tools subrepo contains even more</a>.
As a result (and due to a strong desire to keep the canonical Go distribution
lean), Go has developed a strong culture of developing third-party tools. In
general, these tools need to know where to find source code, and might
need access to type information. The <a href="https://golang.org/pkg/go/build/">go/build</a>
package implements the conventions used by the Go tool, and can thus also serve
as documentation for parts of its build process. The downside is that tools
built on top of it sometimes don&rsquo;t work with code relying on other build tools.
That&rsquo;s why there is a <a href="https://godoc.org/golang.org/x/tools/go/packages">new package in development</a>
which integrates nicely with other build tools.</p>
<p>By its nature the list of Go tools is long and everybody has their own
preferences. But broadly, they contain:</p>
<ul>
<li><a href="https://golang.org/cmd/">Tools developed by the Go team and released as part of the distribution</a>.</li>
<li>This includes tools for <a href="https://golang.org/cmd/gofmt/">automatically formatting source code</a>,
<a href="https://golang.org/cmd/cover/">coverage testing</a>,
<a href="https://golang.org/cmd/trace/">runtime tracing</a> and
<a href="https://golang.org/cmd/pprof/">profiling</a>, a <a href="https://golang.org/cmd/vet/">static analyzer for common mistakes</a>
and <a href="https://golang.org/cmd/fix/">a mostly obsolete tool to migrate code to new Go versions</a>.
These are generally accesed via <code>go tool &lt;cmd&gt;</code>.</li>
<li><a href="https://godoc.org/golang.org/x/tools/cmd">Tools developed by the Go team and maintained out-of-tree</a>.
This includes tools to
<a href="https://godoc.org/golang.org/x/tools/cmd/present">write blog posts and presentations</a>,
<a href="https://godoc.org/golang.org/x/tools/cmd/eg">easily do large refactors</a>,
<a href="https://godoc.org/golang.org/x/tools/cmd/goimports">automatically find and fix import paths</a>
and a <a href="https://godoc.org/golang.org/x/tools/cmd/gopls">language server</a>.</li>
<li>Third-party tools - too many to count. There are many lists of these;
<a href="https://github.com/avelino/awesome-go#tools">here is one</a>.</li>
</ul>
<h2 id="in-summary">In Summary</h2>
<p>I wanted to end this with a short list of references for beginners who feel lost.
So this is where you should go, if you:</p>
<ul>
<li><a href="https://tour.golang.org/welcome/1">Want to start learning Go</a>.</li>
<li><a href="https://golang.org/doc/effective_go.html">Want to understand how a specific language construct works</a>.</li>
<li><a href="https://golang.org/ref/spec">Want to nitpick what is or is not valid Go and why</a>.</li>
<li><a href="https://golang.org/cmd/go/">Want documentation about what the go tool does</a>
Also available via <code>go help</code>. It sometimes references other topics, that you can also
<a href="https://golang.org/pkg/cmd/go/internal/help/">see on the web</a>, but not nicely.</li>
<li><a href="https://github.com/golang/go/wiki/CodeReviewComments">Want to write code that adheres to community standards</a>.</li>
<li><a href="https://golang.org/pkg/testing/#pkg-overview">Want to test your code</a>.</li>
<li><a href="https://godoc.org/">Want to find new packages or look at documentation of public packages</a>.</li>
</ul>
<p>There are many more useful supplementary documents, but this should serve as a good start.
Please <a href="https://twitter.com/TheMerovius">let me know on Twitter</a>
if you are a beginner and there&rsquo;s an area of Go you are missing from this
overview (I might follow this up with more specific topics), or a specific
reference you found helpful. You can also drop me a note if you&rsquo;re a more
experienced Gopher and think I missed something important (but keep in mind
that I intentionally left out most references, so as to keep the ways
forward crisp and clear :) ).</p>
<hr>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>The Go team is currently rolling out support for <em>modules</em>, which is
a unit of code distribution above packages, including support for versioning
and more infrastructure to solve some issues with the &ldquo;traditional&rdquo; go
tool. With that, basically everything in that paragraph becomes obsolete.
However, <em>for now</em> the module support exists but is opt-in. And as the
point of this article is to provide an overview of the separation of
concerns, which doesn&rsquo;t actually change, I felt it was better to stay
within ye olden days - <em>for now</em>.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
]]></content></entry><entry><title type="html">Using roughtime as a "cryptographic notary"</title><link href="https://blog.merovius.de/posts/2018-10-10-using-roughtime-as-a-cryptographic-notary/" rel="alternate" type="text/html"/><id>https://blog.merovius.de//2018/10/18/using-roughtime-as-a-cryptographic-notary.html</id><published>2018-10-10T23:22:40+00:00</published><updated>2018-10-10T23:22:40+00:00</updated><content type="html"><![CDATA[<p><strong>tl;dr: Roughtime can be (ab)used for <a href="https://en.wikipedia.org/wiki/Trusted_timestamping#Trusted_(digital)_timestamping">Trusted Timestamping</a>. I wrote a
<a href="https://github.com/Merovius/notary">simple tool</a> as a PoC</strong></p>
<p>Recently, <a href="https://blog.cloudflare.com/roughtime/">Cloudflare announced</a> that they are now running a
<a href="https://roughtime.googlesource.com/roughtime/">roughtime</a> server. Roughtime is a cryptographically secured
time-synchronization protocol - think NTP with signatures. For an actual
description of how it works, I recommend reading the Cloudflare blog post. But
at it&rsquo;s very core (oversimplification ahead), the user chooses an arbitrary
(usually randomly generated) nonce and the server signs it, plus the current
time.</p>
<p>One thing roughtime adds on top of this, is the ability to build a chain of
requests. This is achieved by taking a hash of a response, combining it with a
randomly generated &ldquo;blind&rdquo; and using the combined hash as a nonce to the next
request. The intended use-case of this is that if a server provides the wrong
time or otherwise misbehaves, you can obtain cryptographic proof of that fact
by getting a timestamped signature of its response from a different server. By
storing the initial nonce, generated blinds and responses, the entire chain can
be validated later.</p>
<p>When I saw Cloudflares announcement, my first thought was that it should be
possible to use a roughtime server as a <a href="https://en.wikipedia.org/wiki/Trusted_timestamping#Trusted_(digital)_timestamping">Time Stamping Authority</a>. The
goal is, to obtain a cryptographic proof, that you owned a particular document
at the current point in time - for example to ensure you can proof original
authorship without publishing the document itself.</p>
<p>The simplest way to achieve this using roughtime is to use the SHA512 hash of
the file as an initial nonce. That way, the roughtime server signs that hash
together with the current time with their private key. By using the roughtime
chain protocol, you can get that proof corroborated by multiple servers.</p>
<p>You can also think of extending this, to get stronger properties. Using the
hash of the file as a nonce only proves that the file existed <em>before</em> that
specific point in time. It also doesn&rsquo;t actually prove that you had the file,
but only the hash. This can be remediated though. If we run a regular roughtime
request, the resulting response is unpredictable (to us) and signs the current
time. Thus, if we use a hash of that response as a prefix &ldquo;salt&rdquo; of the file
itself, the resulting hash proofs that we knew the file <em>after</em> that chain
ran. We can then use that hash as a nonce for another roughtime chain and get a
proof that we had the file at a specific point (or rather, a small interval) in
time. Furthermore, we can opt to use the file-hash not as the nonce itself, but
as a blind. The advantage is, that the blind is never transmitted over the
network, so the actual proof is only available to us (if we use it as a nonce,
an eavesdropper could intercept the proof). I illustrated these options in a
<a href="https://docs.google.com/presentation/d/1quTJfXHvBZCjKJgL6HjUFb_jhDF-PghBwm_lTFLAjdg/edit#slide=id.g43c753f2a5_1_542">recent talk</a> I gave on the subject.</p>
<p>These ideas are mostly academic. I&rsquo;m not sure how useful these properties are
in practice. Nevertheless, the idea intriguiged me enough to <a href="https://github.com/Merovius/notary">implement it</a>
in a simple tool. It&rsquo;s in a pretty rough, proof-of-concept like shape and I
don&rsquo;t know if I will ever progress it from there. It also comes with a client
implementation of the roughtime protocol in Go - initially I was not aware that
there already was a Go implementation, but that also is not go-gettable. Either
way, it was fun to implement it myself :)</p>
]]></content></entry><entry><title type="html">Scrapping contracts</title><link href="https://blog.merovius.de/posts/2018-09-05-scrapping_contracts/" rel="alternate" type="text/html"/><id>https://blog.merovius.de//2018/09/05/scrapping_contracts.html</id><published>2018-09-05T04:00:00+00:00</published><updated>2018-09-05T04:00:00+00:00</updated><content type="html"><![CDATA[<p><strong>tl;dr: I describe a way to simplify the generics design. The ideas are not
particularly novel and have been expressed to various degrees by other people
as well. I hope to provide a more complete view of the design though.</strong></p>
<p>Recently a <a href="https://go.googlesource.com/proposal/+/master/design/go2draft-generics-overview.md">Problem Overview</a>
and <a href="https://go.googlesource.com/proposal/+/master/design/go2draft-contracts.md">Draft Design</a>
for generics in Go have dropped. Since then, predictably,
there has been a bunch of chatter on the intertubez about it. This is a
summary of my thoughts, so far, on the subject - after a bunch of discussions
on Twitter and Reddit.</p>
<p>Note: The design is called &ldquo;Contracts&rdquo;, but I will refer to it as &ldquo;the design
doc&rdquo; here.  When I say &ldquo;contracts&rdquo;, I will refer to the specific part of the
design to express constraints.</p>
<h2 id="contracts-vs-interfaces">Contracts vs. Interfaces</h2>
<p>First, there is a common observation of overlap between generics and interfaces.
To untangle that, we can say that when we use &ldquo;generics&rdquo;, what we mean is
<em>constrained parametric polymorphism</em>. Go already allows polymorphism by using
interfaces. This desgn doc adds two things: One, a way to add <em>type-parameters</em> to
functions and types. And two, a syntax to constrain those type-parameters to a
subset that allows specific operations, via <em>contracts</em>.</p>
<p>The latter is where the overlap lies: Interfaces <em>already</em> allow you to
constrain arguments to types that allow certain operations. In a way, what
contracts add to this, is that those operations can not only be method calls,
but also allow (and constrain) builtin operators and functions to be used and
to allow or disallow certain composite types (though that mainly affects <code>map</code>).</p>
<p>Contracts allow that by the way they are specified: You write a function body
(including arguments, whose notational type becomes the type-variable of the
contract) containing all the statements/expressions you wish to be able
to do. When instantiating a generic type/function with a given set of
type-arguments, the compiler will try to substitute the corresponding
type-variable in the contract body and allow the instantiation, if that body
type-checks.</p>
<h2 id="the-cost-of-contracts">The cost of contracts</h2>
<p>After talking a bit through some examples, I feel that contracts optimize for
the wrong thing. The analogy I came up with is vocabulary vs. grammar.</p>
<p>The contracts design is appealing to a good degree, because it uses familiar
<em>syntax</em>: You don&rsquo;t have to learn any new syntax or language to express your
contract. Just write natural Go code and have that express your constraints for
you. I call this the &ldquo;grammar&rdquo; of constraints: The structure that you use to
input them.</p>
<p>On the other hand, for the <em>user</em> of Go, the relevant question is what
constraints are possible to express and how to express them. They might be
interested in deduplicating values in their algorithm, which requires
equality-operations. Or they might want to do comparisons (e.g. <code>Max</code>), which
requires <code>&gt;</code>. I call this the <em>vocabulary</em>: What is the correct way to express
the set of constraints that my algorithm needs?</p>
<p>The issue now, is that while the grammar of constraints might be obvious, it is
not always clear what the actual semantic constraints that generates <em>are</em>. A
simple example is map-keys. The design doc uses the contract</p>
<pre tabindex="0"><code>contract comparable (t T) {
   t == t
}
</code></pre><p>to specify types that are valid map-keyes. But to a beginner, it is not
immediately obvious, what comparisons have to do with maps. An alternative
would be</p>
<pre tabindex="0"><code>contract mapkey (t T) {
  var _ map[t]bool
}
</code></pre><p>But which is better? Similarly, these two contracts</p>
<pre tabindex="0"><code>contract mult (t T) {
  t = t * t
}

contract add (t T) {
  t = t + t
}
</code></pre><p>seem very similar, but they are, in theory at least, fundamentally different.
Not only because <code>add</code> allows <code>string</code>, while <code>mult</code> doesn&rsquo;t. But also, because
<em>technically</em> any type that supports <code>*</code> also supports <code>-</code> and <code>/</code>. And then there&rsquo;s</p>
<pre tabindex="0"><code>contract div (t T) {
  t = t % t
}
</code></pre><p>which creates another completely different set of types and allowed operators.</p>
<p>A third example is</p>
<pre tabindex="0"><code>contract stringlike (t T) {
  append([]byte(nil), t...)
}
</code></pre><p>This allows any type with underlying type <code>string</code> or <code>[]byte</code>, but nothing
else. And again, technically that would imply allowing index-operations and
<code>len</code>. But does the compiler understand that?</p>
<p>Lastly, it&rsquo;s not really clear how <code>len</code>, <code>cap</code>, <code>make</code> or <code>range</code> would work.
For example, all these contracts are superficially valid:</p>
<pre tabindex="0"><code>contract rangeable (t T) {
  for x := range t {
    fmt.Println(x)
  }
}

contract lengthed (t T) {
  var _ int = len(t)
}

contract capped (t T) {
  var _ int = cap(t)
}

contract makeable (t T) {
  t = make(T)
}

contract makeable2 (t T) {
  t = make(T, 0)
}
</code></pre><p>But in all these cases, they allow some subset of channel, map, slice and array
types, with vastly different interpretations of these operations, depending on
the kind of type used - to the degree, that code using them would usually be
nonsensical. Disallowing these, however, opens questions about the claim of
familiar Go syntax, as we now have to make decisions what sort of expressions
and statements we do or don&rsquo;t allow in a contract.</p>
<p>This is why I say contracts optimize for grammar, instead of vocabulary. The
programmer is interested in the vocabulary - what does the contract actually
<em>mean</em> and what contract should they use? But the vocabulary is obscured by the
grammar - because we use Go syntax, to understand a given contract we need to
know a bunch of things about what the compiler is and is not able to infer from
it.</p>
<p>This is why I don&rsquo;t really buy the argument of not wanting to learn a bunch of
new syntax or new identifiers for constraints: You <em>still</em> have to learn that
vocabulary, but you express it in an obscure and unnatural grammar. I hope to
show that we can introduce the power of generics while also using familiar
grammar and with minimal addition of vocabulary.</p>
<h2 id="scrapping-contracts">Scrapping contracts</h2>
<p>Now, I&rsquo;m not the first person to suggest this, but I think we should consider
scrapping contracts from the design. We can still retain type-parameters and we
can still have constraints, but we express them via interfaces instead. I
should point out, that - for now - I&rsquo;m intentionally optimizing for simplicity
of the design, at the cost of some boilerplate and some loss of power. I will
later try and provide some alternatives to compensate for that in part. But
there is still likely going to remain a net cost in expressiveness. Personally,
I think that tradeoff is worth exploring.</p>
<p>The new design would retain type-parameters and most of their syntax. The
difference is that type-parameters are a full argument list. The type of an
argument has to be an interface type. It can be ellided, in which case it
defaults to the type of the following type-parameter. The last type-parameter
defaults to <code>interface{}</code>. As a bonus, this allows providing multiple sets of
constraints on one declaration:</p>
<pre tabindex="0"><code>func Map(type A, B) (s []A, f func(A) B) []B {
  var out []B
  for _, a := range s {
    out = f(a)
  }
  return out
}

func Stringify(type A fmt.Stringer) (s []A) []string {
  // Because of the signature of fmt.Stringer.String, we can infer all the
  // type-arguments here. Note that A does not *have* to be passed boxed in an
  // interface. A.String is still a valid method-expression for any fmt.Stringer.
  return Map(s, A.String)
}
</code></pre><p>We still want to be able to express multiple, interdependent parameters, which
we can, via parametric interfaces:</p>
<pre tabindex="0"><code>type Graph(type Node, Edge) interface {
  Nodes(Edge) []Node
  Edges(Node) []Edge
}

func ShortestPath(type Node, Edge) (g Graph(Node, Edge), from, to Node) []Edge {
  // …
}

// Undirected Graph as an adjacency list. This could be further parameterized,
// to allow for user-defined paylooads.
type AdjacencyList [][]int

func (g AdjacencyList) Nodes(edge [2]int) []int {
  return edge[:]
}

func (g AdjacencyList) Edges(node int) [][2]int {
  var out [][2]int
  for _, v := range g[node] {
    out = append(out, [2]int{node, v}
    if v != node {
      out = append(out, [2]int{v, node})
    }
  }
  return out
}

func main() {
  g := AdjacencyList{…}
  // Types could be infered here, as the names of methods are unique, so we can
  // look at the methods Nodes and Edges of AdjacencyList to infer the
  // type-arguments.
  path := ShortestPath(g, 0, len(g)-1)
  fmt.Println(path)
}
</code></pre><p>The last example is relevant to the difference in power between contracts and
interfaces: Usage of operators. We can still express the concept, but this is
where the increased boilerplate comes in:</p>
<pre tabindex="0"><code>func Max(type T)(a, b T, less func(T, T) bool) T {
  if less(a, b) {
    return b
  }
  return a
}

func main() {
  fmt.Println(Max(a, b int, func(a, b int) { return a &lt; b }))
}
</code></pre><p>I will try to show some ways to get rid of that boilerplate later. For now,
let&rsquo;s just treat it as a necessary evil of this idea. Though it should be
mentioned, that while this is more <em>cumbersome</em>, it&rsquo;s still just as <em>typesafe</em>
as contracts (as opposed to, say, a reflect-based generic <code>Max</code>).</p>
<p>So, scrapping contracts leaves us with more boilerplate, but just the same set
of concepts we can express - though we do have to pass in any builtin
operations we want to perform as extra functions (or express them in an
interface). In exchange, we get</p>
<ul>
<li>Only one way to specify constraints.</li>
<li>A simpler spec (we don&rsquo;t need to add a new concept, contracts, to the
language) and a saved (pseudo-)keyword.</li>
<li>A simpler compiler: We don&rsquo;t need to add a solver to deduce constraints from
a given contract. The constraint-checker already exists.</li>
<li>Still a well-known, though less powerfull, language to express constraints,
with interfaces.</li>
<li>Simple syntax (same as normal arglists) for having multiple sets of
constraints in one declaration.</li>
<li>Trivially good error messages. Types passed in need only be checked for
consistency and interface satisfaction - the latter is already implemented,
including good error messages.</li>
</ul>
<h2 id="getting-rid-of-boilerplate">Getting rid of boilerplate</h2>
<p>I see two main ways to get rid of boilerplate: Adding methods to builtin types,
or what I call pseudo-interfaces.</p>
<h3 id="methods-on-builtin-types">Methods on builtin types</h3>
<p>An obvious idea is to not use operators in generic code, but instead use
method-call syntax. That is, we&rsquo;d do something akin to</p>
<pre tabindex="0"><code>func Max(type T Ordered) (a, b T) T {
  if a.Less(b) {
    return b
  }
  return a
}
</code></pre><p>To actually reduce the boilerplate, we&rsquo;d predefine methods for all the
operators on the builtin types. That would allow us to call <code>Max</code> with <code>int</code>,
for example.</p>
<p>Unfortunately, I can see a bunch of roadblocks to make this work. Methods are
not promoted to derived types, so you couldn&rsquo;t use <code>Max</code> with e.g.
<code>time.Duration</code>, which has <em>underlying</em> type <code>int64</code>, but is not the same type.
We&rsquo;d probably want those methods to be &ldquo;special&rdquo; in that they automatically get
promoted to any type whose underlying type is predeclared. That introduces
compatibility issues of clashing Method/Field names.</p>
<p>At the end, to express that <code>Less</code> has to take the same argument as the
receiver type, <code>Ordered</code> might look something like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Ordered</span>(<span style="color:#a6e22e">T</span>) <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Less</span>(<span style="color:#a6e22e">T</span>) <span style="color:#66d9ef">bool</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Max</span>(<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">T</span> <span style="color:#a6e22e">Ordered</span>(<span style="color:#a6e22e">T</span>)) (<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span> <span style="color:#a6e22e">T</span>) <span style="color:#a6e22e">T</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">Less</span>(<span style="color:#a6e22e">b</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">b</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">a</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// In the universe block:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Implements Ordered(int).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">a</span> <span style="color:#66d9ef">int</span>) <span style="color:#a6e22e">Less</span>(<span style="color:#a6e22e">b</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">retun</span> <span style="color:#a6e22e">a</span> &lt; <span style="color:#a6e22e">b</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Though it&rsquo;s not clear, whether a parameter like <code>T Ordered(T)</code> should be
allowed. And this would technically allow to implement <code>Ordered(int)</code> on a
custom type. While that probably won&rsquo;t be very useful (the majority of usecases
will require <code>T Ordered(T)</code>), it&rsquo;s not excluded.</p>
<h3 id="pseudo-interfaces">Pseudo-interfaces</h3>
<p>Unfortunately I didn&rsquo;t have a lot of time the last couple of days, so I got
beat to the punch on this. Matt Sherman <a href="https://clipperhouse.com/go-generics-typeclasses/">described the idea first</a>
and called the concept &ldquo;typeclasses&rdquo;. I will stick with pseudo-interface,
because it fits better in the general concept of this description.</p>
<p>The idea is to introduce a set of types into the language that can be used like
interfaces (including embedding), but instead of providing methods, provide
operators. There is a limited set of base types that need to be provided:</p>
<pre tabindex="0"><code>pseudo-interface | Allowed operators
-----------------+-------------------
comparable       | ==, !=
ordered          | &lt;, &lt;= &gt; &gt;=
boolean          | ||, &amp;&amp;, !
bitwise          | ^, %, &amp;, &amp;^, &lt;&lt;, &gt;&gt;
arith            | +, -, *, /
concat           | +
complex          | real(z), imag(z)
nilable          | v == nil
</code></pre><p>and a set of derived pseudo-interfaces:</p>
<pre tabindex="0"><code>pseudo-interface | definition
-----------------+-----------------------------------------------------
num              | interface { comparable; ordered; arith }
integral         | interface { num; bitwise }
stringy          | interface { comparable; ordered; concat; len() int }
iface            | interface { comparable; nilable }
</code></pre><p>The pseudo-interfaces would be declared in the universe block, as predeclared
identifiers. This makes them backwards-compatible (as opposed to methods on
builtin types), because any existing identifier would just shadow these (akin
to how you can have a variable with name <code>string</code>).</p>
<p>Bitshift-operators currently are restricted when used with constants
overflowing the width of an integral type. For generic code, this restriction
would be lifted (as the size is not statically known) and instead the behavior
is equivalent to if the right operand is an uint variable with the given
value.</p>
<p>This would allow us to write</p>
<pre tabindex="0"><code>func Max(type T ordered) (a, b T) T {
  if a &lt; b {
    return b
  }
  return a
}
</code></pre><p>Notably, the list of pseudo-interfaces doesn&rsquo;t include anything related to
channel-, slice- or map-operations (or other composite types). The idea is to
instead use a type literal directly:</p>
<pre tabindex="0"><code>type Keys(type K, V) (m map[K]V) []K {
  var out []K
  for k := range m {
    out = append(out, k)
  }
  return out
}
</code></pre><p>As every type supporting, e.g. <code>map</code> operations, need to have underlying type
<code>map[K]V</code>, it&rsquo;s thus assignable to that type and can be passed to <code>Keys</code> as is.
That is, this is completely legal:</p>
<pre tabindex="0"><code>func main() {
  type MyMap map[string]int
  var m = MyMap{
    &#34;foo&#34;: 23,
    &#34;bar&#34;: 42,
  }
  fmt.Println(Keys(m))
}
</code></pre><p>This also solves another problem with contracts: The ambiguity of <code>len</code>, <code>cap</code>
and <code>range</code>. As the actual kind of the value is not only known during
compilation of the generic function, but even obvious from the code, there is
no question about the intended semantics.</p>
<p>Should Go ever grow operator overloading via operator methods, the
pseudo-interfaces could be changed into actual interfaces, containing the
necessary methods. Of course, that implies that operator overloading would
retain the properties of existing operators, e.g. that having <code>==</code> implies
having <code>!=</code>, or having <code>-</code> implying having <code>+</code>. Personally, I consider that a
good thing - it limits the abuse of operator overloading for nonsensical
operations (say, <code>&lt;&lt;</code> for writing to an <code>io.Writer</code>).</p>
<p>I&rsquo;m not trying to advocate for operator overloading, but think it&rsquo;s worth
mentioning that this design leaves the door open to that.</p>
<h3 id="but-performance">But performance</h3>
<p>A possible criticism of either of these approaches is, that operators have
better performance than dynamic dispatch to a method. I believe (vigorous
handwaving ahead) that this is no different in the existing contracts proposal.
If generic code is compiled generically, it still needs to employ some means
of dynamic dispatch for operators. If, on the other hand, it&rsquo;s compiled
instantiated, then the compiler would also be able to devirtualize the
interfaces - and then inline the method definition.</p>
<h2 id="conclusion">Conclusion</h2>
<p>I&rsquo;ve previously said that I&rsquo;m &ldquo;meh&rdquo; on the design doc, which is the strongest
form of endorsement a generics proposal could ever get from me. After some
discussion, I&rsquo;m more and more convinced that while contracts <em>seem</em>
conceptually simple, they create a plethora of implementation- and usage
questions. I&rsquo;m not sure, the supposed advantage of contracts, of a well-known
syntax, holds up to scrutiny when it comes to mapping that to the actually
derived constraints or writing contracts. There are also many open questions in
regards to contracts, a bunch of them related to the ambiguity of
Go-expressions. As a result, I&rsquo;m starting to feel more negative towards them -
they <em>look</em> like an elegant idea, but in practice, they have a lot of weird
corners.</p>
<p>This design is similar (AIUI) to the <a href="https://go.googlesource.com/proposal/+/master/design/15292/2010-06-type-functions.md">type functions</a>
proposal, so I assume there are good reasons the Go team does not want this.
The difference is mainly the absence of operator methods in favor of
pseudo-interfaces or explicit method calls. This design also handwaves a
couple of important implementation questions - the justification for that is
that these questions (e.g. type inference and code generation) should be able
to be taken from the design doc with minimal changes. It&rsquo;s entirely
possible that I am overlooking something, though.</p>
]]></content></entry><entry><title type="html">Why doesn't Go have variance in its type system?</title><link href="https://blog.merovius.de/posts/2018-06-03-why-doesnt-go-have-variance-in/" rel="alternate" type="text/html"/><id>https://blog.merovius.de//2018/06/03/why-doesnt-go-have-variance-in.html</id><published>2018-06-03T23:20:00+00:00</published><updated>2018-06-03T23:20:00+00:00</updated><content type="html"><![CDATA[<p><strong>tl;dr: I explain what co-, contra- and invariance are and what the
implications for Go&rsquo;s type system would be. In particular, why it&rsquo;s impossible
to have variance in slices.</strong></p>
<p>A question that comes up relatively often with Go newcomers is &ldquo;why can&rsquo;t I
pass e.g. an <code>[]int</code> to a <code>func([]interface{})</code>&rdquo;? In this post I want to
explore this question and its implications for Go. But the concept of
variance (which this is about) is also useful in other languages.</p>
<p>Variance describes what happens to subtype relationships, when they are
used in composite types. In this context, &ldquo;A is a subtype of B&rdquo; means
that a value of type A can always be used, where a value of type B is required.
Go doesn&rsquo;t have explicit subtype relationships - the closest it has is
<a href="https://golang.org/ref/spec#Assignability">assignability</a> which mostly
determines whether types can be used interchangeably. Probably the most
important case of this is given by interfaces: If a type T (whether its a
concrete type, or itself an interface) implements an interface I, then T can be
viewed as a subtype of I. In that sense,
<a href="https://godoc.org/bytes#Buffer"><code>*bytes.Buffer</code></a> is a subtype of
<a href="https://godoc.org/io#ReadWriter">io.ReadWriter</a>, which is a subtype of
<a href="https://godoc.org/io#Reader">io.Reader</a>. And every type is a subtype of
<code>interface{}</code>.</p>
<p>The easiest way to understand what variance means, is to look at function
types. Let&rsquo;s assume, we have a type and a subtype - for example, let&rsquo;s look at
<code>*bytes.Buffer</code> as a subtype of <code>io.Reader</code>. Say, we have a <code>func() *bytes.Buffer</code>. We could also use this like a <code>func() io.Reader</code> - we just
reinterpret the return value as an <code>io.Reader</code>. The reverse is not true: We
can&rsquo;t treat a <code>func() io.Reader</code> as a <code>func() *bytes.Buffer</code>, because not every
<code>io.Reader</code> is a <code>*bytes.Buffer</code>. So, function return values could <em>preserve</em>
the direction of subtyping relationships: If A is a subtype of B, <code>func() A</code>
could be a subtype of <code>func() B</code>. This is called <em>covariance</em>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">F</span>() <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Reader</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> new(<span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">Buffer</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">G</span>() <span style="color:#f92672">*</span><span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">Buffer</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> new(<span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">Buffer</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Use</span>(<span style="color:#a6e22e">f</span> <span style="color:#66d9ef">func</span>() <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Reader</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">useReader</span>(<span style="color:#a6e22e">f</span>())
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Use</span>(<span style="color:#a6e22e">F</span>) <span style="color:#75715e">// Works
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Use</span>(<span style="color:#a6e22e">G</span>) <span style="color:#75715e">// Doesn&#39;t work right now; but *could* be made equivalent to…
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">Use</span>(<span style="color:#66d9ef">func</span>() <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Reader</span> { <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">G</span>() })
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>On the other hand, say we have a <code>func(*bytes.Buffer)</code>. Now we can&rsquo;t use that
as a <code>func(io.Reader)</code>: You can&rsquo;t call it with an <code>io.Reader</code>. But we <em>can</em> do
the reverse. If we have a <code>*bytes.Buffer</code>, we can call a <code>func(io.Reader)</code> with
it. Thus, function arguments <em>reverse</em> the subtype relationship: If A is a
subtype of B, then <code>func(B)</code> could be a subtype of <code>func(A)</code>. This is called
<em>contravariance</em>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">F</span>(<span style="color:#a6e22e">r</span> <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Reader</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">useReader</span>(<span style="color:#a6e22e">r</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">G</span>(<span style="color:#a6e22e">r</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">Buffer</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">useReader</span>(<span style="color:#a6e22e">r</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Use</span>(<span style="color:#a6e22e">f</span> <span style="color:#66d9ef">func</span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">Buffer</span>)) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> new(<span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">Buffer</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">b</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Use</span>(<span style="color:#a6e22e">F</span>) <span style="color:#75715e">// Doesn&#39;t work right now; but *could* be made equivalent to…
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">Use</span>(<span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">r</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">Buffer</span>) { <span style="color:#a6e22e">F</span>(<span style="color:#a6e22e">r</span>) })
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Use</span>(<span style="color:#a6e22e">G</span>) <span style="color:#75715e">// Works
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>So, <code>func</code> is contravariant for arguments and covariant for return values. Of
course, we can combine the two: If A and C are subtypes of B and D
respectively, we can make <code>func(B) C</code> a subtype of <code>func(A) D</code>, by converting
like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// *os.PathError implements error
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">F</span>(<span style="color:#a6e22e">r</span> <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Reader</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">PathError</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Use</span>(<span style="color:#a6e22e">f</span> <span style="color:#66d9ef">func</span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">Buffer</span>) <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> new(<span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">Buffer</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">b</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">useError</span>(<span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Use</span>(<span style="color:#a6e22e">F</span>) <span style="color:#75715e">// Could be made to be equivalent to
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">Use</span>(<span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">r</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">Buffer</span>) <span style="color:#66d9ef">error</span> { <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">F</span>(<span style="color:#a6e22e">r</span>) })
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>However, <code>func(A) C</code> and <code>func(B) D</code> are incompatible. Neither can be a subtype
of the other:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">F</span>(<span style="color:#a6e22e">r</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">Buffer</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">PathError</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">UseF</span>(<span style="color:#a6e22e">f</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Reader</span>) <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">NewReader</span>(<span style="color:#e6db74">&#34;foobar&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">b</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">useError</span>(<span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">G</span>(<span style="color:#a6e22e">r</span> <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Reader</span>) <span style="color:#66d9ef">error</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">UseG</span>(<span style="color:#a6e22e">f</span> <span style="color:#66d9ef">func</span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">Buffer</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">PathErorr</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> new(<span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">Buffer</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">f</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">usePathError</span>(<span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">UseF</span>(<span style="color:#a6e22e">F</span>) <span style="color:#75715e">// Can&#39;t work, because:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">UseF</span>(<span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">r</span> <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Reader</span>) <span style="color:#66d9ef">error</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">F</span>(<span style="color:#a6e22e">r</span>) <span style="color:#75715e">// type-error: io.Reader is not *bytes.Buffer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	})
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">UseG</span>(<span style="color:#a6e22e">G</span>) <span style="color:#75715e">// Can&#39;t work, because:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">UseG</span>(<span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">r</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">Buffer</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">PathError</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">G</span>(<span style="color:#a6e22e">r</span>) <span style="color:#75715e">// type-error: error is not *os.PathError
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	})
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>So in this case, there just <em>is</em> not relationship between the composite types.
This is called <em>invariance</em>.</p>
<hr>
<p>Now, we can get back to our opening question: Why can&rsquo;t you use <code>[]int</code> as
<code>[]interface{}</code>? This really is the question &ldquo;Why are slice-types invariant&rdquo;?.
The questioner assumes that because <code>int</code> is a subtype of <code>interface{}</code>, we
should also make <code>[]int</code> a subtype of <code>[]interface{}</code>. However, we can now see
a simple problem with that. Slices support (among other things) two fundamental
operations, that we can roughly translate into function calls:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">as</span> <span style="color:#f92672">:=</span> make([]<span style="color:#a6e22e">A</span>, <span style="color:#ae81ff">10</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">as</span>[<span style="color:#ae81ff">0</span>] 		<span style="color:#75715e">// func Get(as []A, i int) A
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">as</span>[<span style="color:#ae81ff">1</span>] = <span style="color:#a6e22e">a</span>  		<span style="color:#75715e">// func Set(as []A, i int, a A)
</span></span></span></code></pre></div><p>This shows a clear problem: The type A appears <em>both</em> as an argument <em>and</em>
as a return type. So it appears both covariantly and contravariantly. So while
with functions there is a relatively clear-cut answer to how variance might
work, it just doesn&rsquo;t make a lot of sense for slices. Reading from it would
require covariance but writing to it would require contravariance. In other
words: If you&rsquo;d make <code>[]int</code> a subtype of <code>[]interface{}</code> you&rsquo;d need to explain
how this code would work:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">G</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">F</span>(<span style="color:#a6e22e">v</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">v</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">F</span>(<span style="color:#a6e22e">v</span> []<span style="color:#66d9ef">interface</span>{}) {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// string is a subtype of interface{}, so this should be valid
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">v</span>[<span style="color:#ae81ff">0</span>] = <span style="color:#e6db74">&#34;Oops&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Channels give another interesting perspective here. The bidirectional channel
type has the same issue as slices: Receiving requires covariance, whereas
sending requires contravariance. But you can restrict the directionality of a
channel and only allow send- or receive-operations respectively. So while <code>chan A</code> and <code>chan B</code> would not be related, we could make <code>&lt;-chan A</code> a subtype of
<code>&lt;-chan B</code>. And <code>chan&lt;- B</code> a subtype of <code>chan&lt;- A</code>.</p>
<p>In that sense, <a href="https://github.com/golang/go/issues/22876">read-only types</a>
have the potential to at least theoretically allow variance for slices. While
<code>[]int</code> still wouldn&rsquo;t be a subtype of <code>[]interface{}</code>, we could make <code>ro []int</code> a subtype of <code>ro []interface{}</code> (borrowing the syntax from the
proposal).</p>
<hr>
<p>Lastly, I want to emphasize that all of these are just the <em>theoretical</em> issues
with adding variance to Go&rsquo;s type system. I consider them harder, but even if
we <em>could</em> solve them we would still run into practical issues. The most
pressing of which is that subtypes have different memory representations:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// super pseudo-code to illustrate
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">x</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">Buffer</span> <span style="color:#75715e">// unsafe.Pointer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">y</span> <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">ReadWriter</span> <span style="color:#75715e">// struct{ itable *itab; value unsafe.Pointer }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>					<span style="color:#75715e">// where itable has two entries
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">z</span> <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Reader</span>		<span style="color:#75715e">// struct{ itable *itab; value unsafe.Pointer }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>					<span style="color:#75715e">// where itable has one entry
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>)
</span></span></code></pre></div><p>So even though you might think that all interfaces have the same memory
representation, they actually don&rsquo;t, because the method tables have a different
assumed layout. So in code like this</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Do</span>(<span style="color:#a6e22e">f</span> <span style="color:#66d9ef">func</span>() <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Reader</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">r</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">f</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">Read</span>(<span style="color:#a6e22e">buf</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">F</span>() <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Reader</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> new(<span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">Buffer</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">G</span>() <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">ReadWriter</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> new(<span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">Buffer</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">H</span>() <span style="color:#f92672">*</span><span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">Buffer</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> new(<span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">Buffer</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// All of F, G, H should be subtypes of func() io.Reader
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">Do</span>(<span style="color:#a6e22e">F</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Do</span>(<span style="color:#a6e22e">G</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Do</span>(<span style="color:#a6e22e">H</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>there still needs to be a place where the return value of <code>H</code> is wrapped into
an <code>io.Reader</code> and there needs to be a place where the itable of the return
value of <code>G</code> is transformed into the correct format expected for an
<code>io.Reader</code>. This isn&rsquo;t a <em>huge</em> problem for <code>func</code>: The compiler can
generate the appropriate wrappers at the call site in <code>main</code>.
There is a performance overhead, but only code that actually uses this form of
subtyping needs to pay it. However, it becomes significant problem for slices.</p>
<p>For slices, we must either a) convert the <code>[]int</code> into an <code>[]interface{}</code> when
passing it, meaning an allocation and complete copy. Or b) delay the conversion
between <code>int</code> and <code>interface{}</code> until the access, which would mean that every
slice access now has to go through an indirect function call - just <em>in case</em>
anyone would ever pass us a subtype of what we are expecting. Both options
seem prohibitively expensive for Go&rsquo;s goals.</p>
]]></content></entry><entry><title type="html">Persistent datastructures with Go</title><link href="https://blog.merovius.de/posts/2018-02-25-persistent_datastructures_with_go/" rel="alternate" type="text/html"/><id>https://blog.merovius.de//2018/02/25/persistent_datastructures_with_go.html</id><published>2018-02-25T17:30:00+00:00</published><updated>2018-02-25T17:30:00+00:00</updated><content type="html"><![CDATA[<p>I&rsquo;ve recently taken a liking to <a href="https://en.wikipedia.org/wiki/Persistent_data_structure">persistent datastructures</a>.
These are datastructures where instead of mutating data in-place, you are
creating a new version of the datastructures, that shares most of its state
with the previous version. Not all datastructures can be implemented
efficiently like this, but those that do get a couple of immediate benefits -
keeping old versions around allows you to get cheap snapshotting and copying.
It is trivial to pass a copy to a different thread and you don&rsquo;t have to worry
about concurrent writes, as neither actually mutates any shared state.</p>
<p>Persistent datastructures are popular in functional programming languages, but
I also found the idea a useful tool to model datastructures in Go. Go&rsquo;s
interfaces provide a nice way to model them and make them easy to reason about.
In this post, I will try to illustrate this with a couple of examples.</p>
<p>There are four key ideas I&rsquo;d like you to walk away with:</p>
<ul>
<li>Modeling datastructures as persistent (<em>if possible</em>) makes them easier to
reason about.</li>
<li>When you want to use sum types, try to think of the common properties you are
trying to abstract over instead - put those in an interface.</li>
<li>Separate out the required from the provided interface. Make the former an
interface type, provide the latter as functions or a wrapper.</li>
<li>Doing these allows you to add more efficient implementations later, when you
discover they are necessary.</li>
</ul>
<h2 id="linked-lists">Linked lists</h2>
<p>This is more of an illustrative example, to demonstrate the techniques, than
actually useful. But one of the simplest datastructures existing are linked
lists: A list of nodes, where each node has a value and possibly a next node
(unless we are at the end of the List). In functional languages, you&rsquo;d use a
sum type to express this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#66d9ef">List</span> a <span style="color:#f92672">=</span> <span style="color:#66d9ef">Node</span> a (<span style="color:#66d9ef">List</span> a) <span style="color:#75715e">-- either it&#39;s a node with a value and the rest of the list</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">|</span> <span style="color:#66d9ef">End</span>             <span style="color:#75715e">-- or it&#39;s the end of the list</span>
</span></span></code></pre></div><p>Go infamously does not have sum types, but we can use interfaces to instead.
The classical way would be something like</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">List</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// We use an unexported marker-method. As nothing outside the current package
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// can implement this unexported method, we get control over all
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// implementations of List and can thus de-facto close the set of possible
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// types.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">list</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Node</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Value</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Next</span> <span style="color:#a6e22e">List</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">Node</span>) <span style="color:#a6e22e">list</span>() {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">End</span> <span style="color:#66d9ef">struct</span> {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">End</span>) <span style="color:#a6e22e">list</span>() {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Value</span>(<span style="color:#a6e22e">l</span> <span style="color:#a6e22e">List</span>) (<span style="color:#a6e22e">v</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">ok</span> <span style="color:#66d9ef">bool</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">l</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">l</span>.(<span style="color:#66d9ef">type</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">Node</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">Value</span>, <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">End</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">default</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// This should never happen. Someone violated our sum-type assumption.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    panic(<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;unknown type %T&#34;</span>, <span style="color:#a6e22e">l</span>))
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This works, but it is not really idiomatic Go code. It is error-prone and easy
to misuse, leading to potential panics. But there is a different way to model
this using interfaces, closer to how they are intended. Instead of expressing
what a list is</p>
<blockquote>
<p>A list <em>is</em> either a value and a next element, or the end of the list</p>
</blockquote>
<p>we say what we want a list to be able to <em>do</em>:</p>
<blockquote>
<p>A list has a current element and may have a tail</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">List</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Value returns the current value of the list
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">Value</span>() <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Next returns the tail of the list, or nil, if this is the last node.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">Next</span>() <span style="color:#a6e22e">List</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">node</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">value</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">next</span>  <span style="color:#a6e22e">List</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">n</span> <span style="color:#a6e22e">node</span>) <span style="color:#a6e22e">Value</span>() <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">value</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">n</span> <span style="color:#a6e22e">node</span>) <span style="color:#a6e22e">Next</span>() <span style="color:#a6e22e">List</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">next</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">New</span>(<span style="color:#a6e22e">v</span> <span style="color:#66d9ef">int</span>) <span style="color:#a6e22e">List</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">node</span>{<span style="color:#a6e22e">v</span>, <span style="color:#66d9ef">nil</span>}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Prepend</span>(<span style="color:#a6e22e">l</span> <span style="color:#a6e22e">List</span>, <span style="color:#a6e22e">v</span> <span style="color:#66d9ef">int</span>) <span style="color:#a6e22e">List</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">node</span>{<span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">l</span>}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This is a far more elegant abstraction. The empty list is represented by the
<code>nil</code> interface. We have only one implementation of that interface, for the
nodes. We offer exported functions to create new lists - potentially from
existing ones.</p>
<p>Note that the methods actually have <code>node</code> as a receiver, not <code>*node</code>, as we
often tend to do with structs. This fact makes this implementation a
<em>persistent</em> linked list. None of the methods can modify the list. So after
creation, the linked list will stay forever immutable. Even if you type-assert
to get to the underlying data, that would only provide you with a <em>copy</em> of the
data - the original would stay unmodified. The memory layout, however, is the
same - the value gets put on the heap and you are only passing pointers to it
around.</p>
<p>The beauty of this way to think about linked lists, is that it allows us to
amend it after the fact. For example, say we notice that our program is slow,
due to excessive cache-misses (as linked lists are not contiguous in memory).
We can easily add a function, that packs a list:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">packed</span> []<span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">p</span> <span style="color:#a6e22e">packed</span>) <span style="color:#a6e22e">Value</span>() <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">p</span>[<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">p</span> <span style="color:#a6e22e">packed</span>) <span style="color:#a6e22e">Next</span>() <span style="color:#a6e22e">List</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">p</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">p</span>[<span style="color:#ae81ff">1</span>:]
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Pack</span>(<span style="color:#a6e22e">l</span> <span style="color:#a6e22e">List</span>) <span style="color:#a6e22e">List</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">l</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">p</span> <span style="color:#a6e22e">packed</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> ; <span style="color:#a6e22e">l</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span>; <span style="color:#a6e22e">l</span> = <span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">Next</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">p</span> = append(<span style="color:#a6e22e">p</span>, <span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">Value</span>())
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">p</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The cool thing about this is that we can mix and match the two: For example,
we could prepend new elements and once the list gets too long, pack it and
continue to prepend to the packed list. And since <code>List</code> is an interface, users
can implement it themselves and use it with our existing implementation. So,
for example, a user could build us a list that calculates fibonacci numbers:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">fib</span> [<span style="color:#ae81ff">2</span>]<span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">l</span> <span style="color:#a6e22e">fib</span>) <span style="color:#a6e22e">Value</span>() <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">l</span>[<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">l</span> <span style="color:#a6e22e">fib</span>) <span style="color:#a6e22e">Next</span>() <span style="color:#a6e22e">List</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fib</span>{<span style="color:#a6e22e">l</span>[<span style="color:#ae81ff">1</span>], <span style="color:#a6e22e">l</span>[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">+</span><span style="color:#a6e22e">l</span>[<span style="color:#ae81ff">1</span>]}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>and then use that with functions that take a <code>List</code>. Or they could have a
lazily evaluated list:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">lazy</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">o</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">Once</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">f</span> <span style="color:#66d9ef">func</span>() (<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">List</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">v</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">next</span> <span style="color:#a6e22e">List</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">l</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">lazy</span>) <span style="color:#a6e22e">Value</span>() <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">o</span>.<span style="color:#a6e22e">Do</span>(<span style="color:#66d9ef">func</span>() { <span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">next</span> = <span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">f</span>() })
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">v</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">l</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">lazy</span>) <span style="color:#a6e22e">Next</span>() <span style="color:#a6e22e">List</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">o</span>.<span style="color:#a6e22e">Do</span>(<span style="color:#66d9ef">func</span>() { <span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">next</span> = <span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">f</span>() })
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">next</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Note that in this case the methods need to be on a pointer-receiver. This
(technically) leaves the realm of persistent data-structures. While they
motivated our interface-based abstraction and helped us come up with a safe
implementation, we are not actually <em>bound</em> to them. If we later decide, that
for performance reasons we want to add a mutable implementation, we can do so
(of course, we still have to make sure that we maintain the safety of the
original). And we can intermix the two, allowing us to only apply this
optimization to part of our data structure.</p>
<p>I find this a pretty helpful way to think about datastructures.</p>
<h2 id="associative-lists">Associative lists</h2>
<p>Building on linked lists, we can build a map based on <a href="https://en.wikipedia.org/wiki/Association_list">Association Lists</a>.
It&rsquo;s a similar idea as before:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Map</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Value</span>(<span style="color:#a6e22e">k</span> <span style="color:#66d9ef">interface</span>{}) <span style="color:#66d9ef">interface</span>{}
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Set</span>(<span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">v</span> <span style="color:#66d9ef">interface</span>{}) <span style="color:#a6e22e">Map</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">empty</span> <span style="color:#66d9ef">struct</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">empty</span>) <span style="color:#a6e22e">Value</span>(<span style="color:#a6e22e">_</span> <span style="color:#66d9ef">interface</span>{}) <span style="color:#66d9ef">interface</span>{} {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">empty</span>) <span style="color:#a6e22e">Set</span>(<span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">v</span> <span style="color:#66d9ef">interface</span>{}) <span style="color:#a6e22e">Map</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">pair</span>{<span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">empty</span>{}}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Make</span>() <span style="color:#a6e22e">Map</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">empty</span>{}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">pair</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">v</span> <span style="color:#66d9ef">interface</span>{}
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">parent</span> <span style="color:#a6e22e">Map</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">p</span> <span style="color:#a6e22e">pair</span>) <span style="color:#a6e22e">Value</span>(<span style="color:#a6e22e">k</span> <span style="color:#66d9ef">interface</span>{}) <span style="color:#66d9ef">interface</span>{} {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">k</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">k</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">v</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">parent</span>.<span style="color:#a6e22e">Value</span>(<span style="color:#a6e22e">k</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">p</span> <span style="color:#a6e22e">pair</span>) <span style="color:#a6e22e">Set</span>(<span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">v</span> <span style="color:#66d9ef">interface</span>{}) <span style="color:#a6e22e">Map</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">pair</span>{<span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">p</span>}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This time, we don&rsquo;t represent an empty map as <code>nil</code>, but add a separate
implementation of the interface for an empty map.  That makes the
implementation of <code>Value</code> cleaner, as it doesn&rsquo;t have to check the parent map
for <code>nil</code> &ndash; but it requires users to call <code>Make</code>.</p>
<p>There is a problem with our <code>Map</code>, though: We cannot iterate over it. The
interface does not give us access to any parent maps. We could use
type-assertion, but that would preclude users from implementing their own. What
if we added a method to the interface to support iteration?</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Map</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Value</span>(<span style="color:#a6e22e">k</span> <span style="color:#66d9ef">interface</span>{}) <span style="color:#66d9ef">interface</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Iterate calls f with all key-value pairs in the map.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">Iterate</span>(<span style="color:#a6e22e">f</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">v</span> <span style="color:#66d9ef">interface</span>{}))
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">empty</span>) <span style="color:#a6e22e">Iterate</span>(<span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">v</span> <span style="color:#66d9ef">interface</span>{})) {
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">p</span> <span style="color:#a6e22e">pair</span>) <span style="color:#a6e22e">Iterate</span>(<span style="color:#a6e22e">f</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">v</span> <span style="color:#66d9ef">interface</span>{})) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">v</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">parent</span>.<span style="color:#a6e22e">Iterate</span>(<span style="color:#a6e22e">f</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Unfortunately, this still doesn&rsquo;t really work though: If we write multiple
times to the same key, <code>Iterate</code> as implemented would call <code>f</code> with all
key-value-pairs. This is likely not what we want.</p>
<p>The heart of the issue here, is the difference between the <em>required</em> interface
and the <em>provided</em> interface. We can also see that with <code>Set</code>. Both of the
implementations of that method look essentially the same and neither actually
depends on the used type. We could instead provide <code>Set</code> as a function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Set</span>(<span style="color:#a6e22e">m</span> <span style="color:#a6e22e">Map</span>, <span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">v</span> <span style="color:#66d9ef">interface</span>{}) <span style="color:#a6e22e">Map</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">pair</span>{<span style="color:#a6e22e">k</span>,<span style="color:#a6e22e">v</span>,<span style="color:#a6e22e">m</span>}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The lesson is, that some operations need support from the implementation, while
other operations can be implemented without it. The provided interface is the
set of operations we provide to the user, whereas the required interface is the
set of operations that we rely on. We can split the two and get something like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// Interface is the set of operations required to implement a persistent map.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Interface</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Value</span>(<span style="color:#a6e22e">k</span> <span style="color:#66d9ef">interface</span>{}) <span style="color:#66d9ef">interface</span>{}
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Iterate</span>(<span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">v</span> <span style="color:#66d9ef">interface</span>{}))
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Map</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Interface</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">m</span> <span style="color:#a6e22e">Map</span>) <span style="color:#a6e22e">Iterate</span>(<span style="color:#a6e22e">f</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">v</span> <span style="color:#66d9ef">interface</span>{})) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">seen</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">interface</span>{}]<span style="color:#66d9ef">bool</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">Interface</span>.<span style="color:#a6e22e">Iterate</span>(<span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">v</span> <span style="color:#66d9ef">interface</span>{}) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">seen</span>[<span style="color:#a6e22e">k</span>] {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">v</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  })
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">m</span> <span style="color:#a6e22e">Map</span>) <span style="color:#a6e22e">Set</span>(<span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">v</span> <span style="color:#66d9ef">interface</span>{}) <span style="color:#a6e22e">Map</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">Map</span>{<span style="color:#a6e22e">pair</span>{<span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">Interface</span>}}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Using this, we could again implement a packed variant of <code>Map</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">packed</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">interface</span>{}]<span style="color:#66d9ef">interface</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">p</span> <span style="color:#a6e22e">packed</span>) <span style="color:#a6e22e">Value</span>(<span style="color:#a6e22e">k</span> <span style="color:#66d9ef">interface</span>{}) <span style="color:#66d9ef">interface</span>{} {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">p</span>[<span style="color:#a6e22e">k</span>]
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">p</span> <span style="color:#a6e22e">packed</span>) <span style="color:#a6e22e">Iterate</span>(<span style="color:#a6e22e">f</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">v</span> <span style="color:#66d9ef">interface</span>{})) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">p</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">v</span>)
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Pack</span>(<span style="color:#a6e22e">m</span> <span style="color:#a6e22e">Map</span>) <span style="color:#a6e22e">Map</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> make(<span style="color:#a6e22e">packed</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">Iterate</span>(<span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">k</span>,<span style="color:#a6e22e">v</span> <span style="color:#66d9ef">interface</span>{}) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">p</span>[<span style="color:#a6e22e">k</span>] = <span style="color:#a6e22e">v</span>
</span></span><span style="display:flex;"><span>  })
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">m</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="ropes">Ropes</h2>
<p>A <a href="https://en.wikipedia.org/wiki/Rope_(data_structure)">Rope</a> is a data
structure to store a string in a way that is efficiently editable. They are
often used in editors, as it is too slow to copy the complete content on every
insert operation. Editors also benefit from implementing them as persistent data
structures, as that makes it very easy to implement multi-level undo: Just have
a stack (or ringbuffer) of Ropes, representing the states the file was in after
each edit. Given that they all share most of their structure, this is very
efficient. Implementing ropes is what really bought me into the patterns
I&rsquo;m presenting here. Let&rsquo;s see, how we could represent them.</p>
<a href="https://en.wikipedia.org/wiki/Rope_(data_structure)#/media/File:Vector_Rope_example.svg">
  <img src="/assets/Vector_Rope_example.svg" alt='Rope representing the string "Hello_my_name_is_Simon"'>
</a>
<p>A Rope is a binary tree with strings as leafs. The represented string
is what you get when you do a depth-first traversal and concatenate all the
leafs. Every node in the tree also has a <em>weight</em>, which corresponds to the
length of the string for leafs and the length of the left subtree for inner
nodes. This allows easy recursive lookup of the <code>i</code>th character: If <code>i</code> is less
than the weight of a node, we look into the left subtree, otherwise into the
right. Let&rsquo;s represent this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Base</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Index</span>(<span style="color:#a6e22e">i</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">byte</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Length</span>() <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">leaf</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">l</span> <span style="color:#a6e22e">leaf</span>) <span style="color:#a6e22e">Index</span>(<span style="color:#a6e22e">i</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">byte</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">l</span>[<span style="color:#a6e22e">i</span>]
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">l</span> <span style="color:#a6e22e">leaf</span>) <span style="color:#a6e22e">Length</span>() <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> len(<span style="color:#a6e22e">l</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">node</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">left</span>, <span style="color:#a6e22e">right</span> <span style="color:#a6e22e">Base</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">n</span> <span style="color:#a6e22e">node</span>) <span style="color:#a6e22e">Index</span>(<span style="color:#a6e22e">i</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">byte</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">w</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">left</span>.<span style="color:#a6e22e">Length</span>(); <span style="color:#a6e22e">i</span> <span style="color:#f92672">&gt;=</span> <span style="color:#a6e22e">w</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// The string represented by the right child starts at position w,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// so we subtract it when recursing to the right
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">right</span>.<span style="color:#a6e22e">Index</span>(<span style="color:#a6e22e">i</span><span style="color:#f92672">-</span><span style="color:#a6e22e">w</span>)
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">left</span>.<span style="color:#a6e22e">Index</span>(<span style="color:#a6e22e">i</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">n</span> <span style="color:#a6e22e">node</span>) <span style="color:#a6e22e">Length</span>() <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">left</span>.<span style="color:#a6e22e">Length</span>() <span style="color:#f92672">+</span> <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">right</span>.<span style="color:#a6e22e">Length</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Rope</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Base</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">New</span>(<span style="color:#a6e22e">s</span> <span style="color:#66d9ef">string</span>) <span style="color:#a6e22e">Rope</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">Rope</span>{<span style="color:#a6e22e">leaf</span>(<span style="color:#a6e22e">s</span>)}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">r</span> <span style="color:#a6e22e">Rope</span>) <span style="color:#a6e22e">Append</span>(<span style="color:#a6e22e">r2</span> <span style="color:#a6e22e">Rope</span>) <span style="color:#a6e22e">Rope</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">Rope</span>{<span style="color:#a6e22e">node</span>{<span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">Base</span>, <span style="color:#a6e22e">r2</span>.<span style="color:#a6e22e">Base</span>}}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Note, how we did not actually add a <code>Weight</code>-method to our interface: Given
that it&rsquo;s only used by the traversal on inner nodes, we can just directly
calculate it from its definition as the length of the left child tree. In
practice, we might want to pre-calculate <code>Length</code> on creation, though, as it
currently is a costly recursive operation.</p>
<p>The next operation we&rsquo;d have to support, is splitting a Rope at an index. We
can&rsquo;t implement that with our current interface though, we need to add it:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Base</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Index</span>(<span style="color:#a6e22e">i</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">byte</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Length</span>() <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Split</span>(<span style="color:#a6e22e">i</span> <span style="color:#66d9ef">int</span>) (<span style="color:#a6e22e">left</span>, <span style="color:#a6e22e">right</span> <span style="color:#a6e22e">Base</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">l</span> <span style="color:#a6e22e">leaf</span>) <span style="color:#a6e22e">Split</span>(<span style="color:#a6e22e">i</span> <span style="color:#66d9ef">int</span>) (<span style="color:#a6e22e">Base</span>, <span style="color:#a6e22e">Base</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">l</span>[:<span style="color:#a6e22e">i</span>], <span style="color:#a6e22e">l</span>[<span style="color:#a6e22e">i</span>:]
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">n</span> <span style="color:#a6e22e">node</span>) <span style="color:#a6e22e">Split</span>(<span style="color:#a6e22e">i</span> <span style="color:#66d9ef">int</span>) (<span style="color:#a6e22e">Base</span>, <span style="color:#a6e22e">Base</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">w</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">left</span>.<span style="color:#a6e22e">Length</span>(); <span style="color:#a6e22e">i</span> <span style="color:#f92672">&gt;=</span> <span style="color:#a6e22e">w</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">left</span>, <span style="color:#a6e22e">right</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">right</span>.<span style="color:#a6e22e">Split</span>(<span style="color:#a6e22e">i</span><span style="color:#f92672">-</span><span style="color:#a6e22e">w</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">node</span>{<span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">left</span>, <span style="color:#a6e22e">left</span>}, <span style="color:#a6e22e">right</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">left</span>, <span style="color:#a6e22e">right</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">left</span>.<span style="color:#a6e22e">Split</span>(<span style="color:#a6e22e">i</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">left</span>, <span style="color:#a6e22e">node</span>{<span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">right</span>, <span style="color:#a6e22e">right</span>}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">r</span> <span style="color:#a6e22e">Rope</span>) <span style="color:#a6e22e">Split</span>(<span style="color:#a6e22e">i</span> <span style="color:#66d9ef">int</span>) (<span style="color:#a6e22e">Rope</span>, <span style="color:#a6e22e">Rope</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Note that we return the wrapping struct, as opposed to Base.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// This is so users work with the provided interface, not the required one.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">left</span>, <span style="color:#a6e22e">right</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">Split</span>(<span style="color:#a6e22e">i</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">Rope</span>{<span style="color:#a6e22e">left</span>}, <span style="color:#a6e22e">Rope</span>{<span style="color:#a6e22e">right</span>}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>I think this code is remarkably readable and easy to understand - and that is
mostly due to the fact that we are reusing subtrees whenever we can. What&rsquo;s
more, given these operations we can implement the remaining three from the
wikipedia article easily:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">r</span> <span style="color:#a6e22e">Rope</span>) <span style="color:#a6e22e">Insert</span>(<span style="color:#a6e22e">r2</span> <span style="color:#a6e22e">Rope</span>, <span style="color:#a6e22e">i</span> <span style="color:#66d9ef">int</span>) <span style="color:#a6e22e">Rope</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">left</span>, <span style="color:#a6e22e">right</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">Split</span>(<span style="color:#a6e22e">i</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">left</span>.<span style="color:#a6e22e">Append</span>(<span style="color:#a6e22e">r2</span>).<span style="color:#a6e22e">Append</span>(<span style="color:#a6e22e">right</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">r</span> <span style="color:#a6e22e">Rope</span>) <span style="color:#a6e22e">Delete</span>(<span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">j</span> <span style="color:#66d9ef">int</span>) <span style="color:#a6e22e">Rope</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">left</span>, <span style="color:#a6e22e">right</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">Split</span>(<span style="color:#a6e22e">j</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">left</span>, <span style="color:#a6e22e">_</span> = <span style="color:#a6e22e">left</span>.<span style="color:#a6e22e">Split</span>(<span style="color:#a6e22e">i</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">left</span>.<span style="color:#a6e22e">Append</span>(<span style="color:#a6e22e">right</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">r</span> <span style="color:#a6e22e">Rope</span>) <span style="color:#a6e22e">Slice</span>(<span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">j</span> <span style="color:#66d9ef">int</span>) <span style="color:#a6e22e">Rope</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">r</span>, <span style="color:#a6e22e">_</span> = <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">Split</span>(<span style="color:#a6e22e">j</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">r</span> = <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">Split</span>(<span style="color:#a6e22e">i</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">r</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This provides us with a fully functioning Rope implementation. It doesn&rsquo;t
support everything we&rsquo;d need to write an editor, but it&rsquo;s a good start that was
quick to write. It is also reasonably simple to extend with more functionality.
For example, you could imagine having an implementation that can rebalance
itself, when operations start taking too long. Or adding traversal, or
random-access unicode support that is still backed by compact UTF-8. And I
found it reasonably simple (though it required some usage of unsafe) to write
an implementation of <code>Base</code> that used an <code>mmap</code>ed file (thus you&rsquo;d only need to
keep the actual edits in RAM, the rest would be read directly from disk with
the OS managing caching for you).</p>
<h2 id="closing-remarks">Closing remarks</h2>
<p>None of these ideas are revolutionary (especially to functional programmers).
But I find that considering if a datastructure I need can be implemented as a
persistent/immutable one helps me to come up with clear abstractions that work
well. And I also believe that Go&rsquo;s interfaces provide a good way to express
these abstractions - because they allow you to start with a simple, immutable
implementation and then compose it with mutable ones - if and only if there are
clear efficiency benefits. Lastly, I think there is an interesting idea here of
how to substitute sum-types by interfaces - not in a direct manner, but instead
by thinking about the common behavior you want to provide over the sum.</p>
<p>I hope you find that this inspires you to think differently about these problems too.</p>
]]></content></entry><entry><title type="html">What even is error handling?</title><link href="https://blog.merovius.de/posts/2018-01-21-what_even_is_error_handling/" rel="alternate" type="text/html"/><id>https://blog.merovius.de//2018/01/21/what_even_is_error_handling.html</id><published>2018-01-21T23:40:00+00:00</published><updated>2018-01-21T23:40:00+00:00</updated><content type="html"><![CDATA[<p><strong>tl;dr: Error handling shouldn&rsquo;t be about how to best propagate an error
value, but how to make it destroy it (or make it irrelevant). To encourage
myself to do that, I started removing errors from function returns wherever I
found it at all feasible</strong></p>
<p>Error handling in Go is a contentious and often criticized issue. There is no
shortage on articles criticizing the approach taken, no shortage on articles
giving advice on how to deal with it (or defending it) and also no shortage on
proposals on how to improve it.</p>
<p>During these discussion, I always feel there is something missing. The
proposals for improvement usually deal with syntactical issues, how to avoid
boilerplate. Then there is the other school of thought - where it&rsquo;s not about
syntax, but about how to best pass errors around. Dave Chaney wrote <a href="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully">an often
quoted blog post on the
subject</a>,
where he lists all the ways error information can be mapped into the Go type
system, why he considers them flawed and what he suggests instead.
This school of thought regularly comes up with helper packages, to make
wrapping or annotating errors easier.
<a href="https://github.com/pkg/errors">pkg/errors</a> is very popular (and is grown out
of the approach of above blog post) but <a href="https://godoc.org/github.com/upspin/upspin/errors#Error">upspin&rsquo;s
incarnation</a> also
gathered some attention.</p>
<p>I am dissatisfied with both schools of thought. Overall, neither seems to
explicitly address, what to me is the underlying question: What <em>is</em> error
handling? In this post, I&rsquo;m trying to describe how I interpret the term and
why, to me, the existing approaches and discussions mostly miss the mark. Note,
that I don&rsquo;t claim this understanding to be universal - just how <em>I</em> would put
into words my understanding of the topic.</p>
<hr>
<p>Let&rsquo;s start with a maybe weird question: Why is the entry point into the
program <code>func main()</code> and not <code>func main() error</code>? Personally, I start most of
my programs writing</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">run</span>(); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Fatal</span>(<span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">run</span>() <span style="color:#66d9ef">error</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// …
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>This allows me to use <code>defer</code>, pass on errors and all that good stuff. So, why
doesn&rsquo;t the language just do that for me?</p>
<p>We can find part of the answer in <a href="https://groups.google.com/d/topic/golang-nuts/6xl02B_MxdA/discussion">this old golang-nuts thread</a>.
It is about return codes, instead of an <code>error</code>, but the principle is the
same. And the best answer - in my opinion - is this:</p>
<blockquote>
<p>I think the returned status is OS-specific, and so Go the language should not
define its type (Maybe some OS can only report 8-bit result while some other
OS support arbitrary string as program status, there is considerable
differences between that; there might even be environment that don&rsquo;t support
returning status code or the concept of status code simply doesn&rsquo;t exist)</p>
<p>I imagine some Plan 9 users might be disagree with the signature of
<code>os.Exit()</code>.</p>
</blockquote>
<p>So, in essence: Not all implementations would necessarily be able to assign a
reasonable meaning to a return code (or error) from <code>main</code>. For example, an
embedded device likely couldn&rsquo;t really do anything with it. It thus seems
preferable to not couple the language to this decision which only <em>really</em> makes
semantic sense on a limited subset of implementations. Instead, we provide
mechanisms in the standard library to exit the program or take any other
reasonable action and then let the developer decide, under what circumstances
they want to exit the program and with what code. Being coupled to a decision
in the standard library is better than being coupled in the language itself.
And a developer who targets a platform where an exit code doesn&rsquo;t make sense,
can take a different action instead.</p>
<p>Of course, this leaves the programmer with a problem: What to do with errors?
We could write it to stderr, but <code>fmt.Fprintf</code> <em>also</em> returns an error, so what
to do with that one? Above I used <code>log.Fatal</code>, which does <em>not</em> return an error.
What happens if the underlying <code>io.Writer</code> fails to write, though? What
does <code>log</code> do with the resulting error? The answer is, of course: It ignores
any errors.</p>
<p>The point is, that passing on the error is not a solution. <em>Eventually</em> every
program will return to <code>main</code> (or <code>os.Exit</code> or panic) and the buck stops there.
It needs to get <em>handled</em> and the signature of <code>main</code> enforces that the only
way to do that is via side-effects - and if they fail, you just have to deal
with that one too.</p>
<hr>
<p>Let&rsquo;s continue with a similar question, that has a similar answer, that
occasionally comes up: Why doesn&rsquo;t <code>ServeHTTP</code> return an <code>error</code>? Sooner or
later, people face the question of what to do with errors in their HTTP
Handlers. For example, what if you are writing out a JSON object and
<code>Marshal</code> fails? In fact, a lot of HTTP frameworks out there will define their
own handler-type, which differs from <code>http.Handler</code> in exactly that way. But if
everyone wants to return an <code>error</code> from their handler, why doesn&rsquo;t the
interface just add that error return itself? Was that just an oversight?</p>
<p>I&rsquo;m strongly arguing that no, this was not an oversight, but the correct design
decision. Because the HTTP Server package <em>can not handle any errors</em>. An HTTP
server is supposed to stay running, every request demands a response. If
<code>ServeHTTP</code> would return an <code>error</code>, the server would have to do <em>something</em>
with it, but what to do is highly application-specific. You might respond that
it should serve a 500 error code, but in 99% of cases, that is the wrong thing
to do. Instead you should serve a more specific error code, so the client
knows (for example) whether to retry or if the response is cacheable.
<code>http.Server</code> could also just ignore the error and instead drop the request on
the floor, but that&rsquo;s even worse. Or it could propagate it up the stack. But as
we determined, eventually it would have to reach <code>main</code> and the buck stops
there. You probably don&rsquo;t want your server to come down, every time a request
contains an invalid parameter.</p>
<p>So, given that a) every request needs an answer and b) the right answer is
highly application-specific, the translation from errors into status codes
<em>has</em> to happen in application code. And just like <code>main</code> enforces you to
handle any errors via side-effects by not allowing you to return an <code>error</code>, so
does <code>http</code> force you to handle any errors via writing a response by not
allowing you to return an <code>error</code>.<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></p>
<p>So, what are you supposed to do, when <code>json.Marshal</code> fails? Well, that depends
on our application. Increment a metric. Log the error. panic. Write out a 500.
Ignore it and write a 200. Commit to the uncomfortable knowledge, that
sometimes, you can&rsquo;t just pass the decision on what to do with an error to
someone else.</p>
<hr>
<p>These two examples distill, I think, pretty well, what I view as error
<em>handling</em>: An error is handled, when you destroy the error value. In that
parlance, <code>log.Error</code> handles any errors of the underlying writer by not
returning them. Every program needs to handle any error in <em>some</em> way, because
<code>main</code> can&rsquo;t return anything and the values need to go <em>somewhere</em>. Any HTTP
handler needs to actually <em>handle</em> errors, by translating them into HTTP
responses.</p>
<p>And in that parlance, packages like <code>pkg/errors</code> have little, really, to do with
error <em>handling</em> - instead, they provides you with a strategy for the case where
you are <em>not</em> handling your errors. In the same vein, proposals that address
the repetitive checking of errors via extra syntax do not really simplify their
handling at all - they just move it around a bit. I would term that <em>error
propagation</em>, instead - no doubt important, but keep in mind, that an error
that was <em>handled</em>, doesn&rsquo;t need to be propagated at all. So to me, a good
approach to error handling would be characterized by mostly obviating the need
for convenient error propagation mechanisms.</p>
<p>And to me, at least, it seems that we talk too little about how to handle
errors, in the end.</p>
<hr>
<p>Does Go encourage explicit error handling? This is the phrasing very often used
to justify the repetitive nature, but I tend to disagree. Compare, for example,
Go&rsquo;s approach to checked exceptions in Java: There, errors are propagated via
exceptions. Every exception that could be thrown (theoretically) must be
annotated in the method signature. Any exception that you handle, has to be
mentioned in a try-catch-statement. And the compiler will refuse to compile a
program which does not explicitly mention how exceptions are handled. This, to
me, seems like the pinnacle of <em>explicit</em> error handling. Rust, too, requires
this - it introduces a <code>?</code> operator to signify propagating an error, but that,
still, is an explicit annotation. And apart from that, you can&rsquo;t use the return
value of a function that might propagate an error, without explicitly handling
that error first.</p>
<p>In Go, on the other hand, it is not only perfectly acceptable to ignore errors
when it makes sense (for example, I will always ignore errors created from
writing to a <a href="https://godoc.org/bytes#Buffer.Write"><code>*bytes.Buffer</code></a>), it is
actually often the only sensible thing to do. It is fundamentally not only
okay, but 99% of times <em>correct</em> to just completely ignore the error returned
by <code>fmt.Println</code>. And while it makes sense to check the error returned from
<code>json.Marshal</code> in your HTTP handler against <code>*json.MarshalError</code> (to
panic/log/complain loudly, because your code is buggy), any other errors
<em>should 99% of the time just be ignored</em>. And that&rsquo;s fine.</p>
<p>I believe that to say Go encourages explicit error handling, it would need some
mechanism of checked exceptions, Result types, or a requirement to pass an
<a href="https://github.com/kisielk/errcheck">errcheck</a> like analysis in the compiler.</p>
<p>I think it would be closer to say, that Go encourages <em>local</em> error handling.
That is, the code that handles an error, is close to the code that produced it.
Exceptions encourages the two to be separated: There are usually several
or many lines of code in a single <code>try</code>-block, all of which share one
<code>catch</code>-block and it is hard to tell which of the lines produced it. And very
often, the actual error location is several stack frames deep. You could
contrast this with Go, where the error return is immediately obvious from the
code and if you have a line of error handling, it is usually immediately
attached to the function call that produced it.</p>
<p>However, that still seems to come short, in my view. After all, there is
nothing to force you to do that. And in fact, one of the most often <a href="https://blog.golang.org/errors-are-values">cited
articles about Go error handling</a> is
often interpreted to encourage exactly that. Plus, a lot of people end up
writing <code>return err</code> far too often, simply propagating the error to be
<em>handled</em> elsewhere. And the proliferation of error-wrapping libraries happens
in the same vein: What their proponents phrase as &ldquo;adding context to the error
value&rdquo;, I interpret as &ldquo;adding back some of the information as a crutch, that
you removed when passing the error to non-local handling code&rdquo;. Sadly, far too
often, the error then ends up not being handled at all, as everyone just takes
advantage of that crutch. This leaves the end-user with an error message that is
essentially a poorly formatted, non-contiguous stacktrace.</p>
<p>Personally, I&rsquo;d characterize Go&rsquo;s approach like this: In Go, error handling is
simply first-class code. By forcing you to use exactly the same control-flow
mechanisms and treat errors like any other data, Go encourages you to code your
error handling. Often that means a bunch of control flow to catch and recover
from any errors where they occur. But that&rsquo;s not &ldquo;clutter&rdquo;, just as it is not
&ldquo;clutter&rdquo; to write <code>if n &lt; 1 { return 1 }</code> when writing a Fibonacci function
(to choose a trivial example). It is just code. And yes, sometimes that code
might also store the error away or propagate it out-of-band to reduce
repetition <em>where it makes sense</em> - like in above blog post. But focussing on
the &ldquo;happy path&rdquo; is a bit of a distraction: Your <em>users</em> will definitely be
more happy about those parts of the control flow that make the errors disappear
or transform them into clean, actionable advise on how to solve the problem.</p>
<p>So, in my reading, the title of the Go blog post puts the emphasis in slightly
the wrong place - and often, people take the wrong message from it, in my
opinion. Not &ldquo;errors are values&rdquo;, but &ldquo;error handling is code&rdquo;.</p>
<hr>
<p>So, what <em>would</em> be my advise for handling errors? To be honest, I don&rsquo;t know
yet - and I&rsquo;m probably in no place to lecture anyone anyway.</p>
<p>Personally, I&rsquo;ve been trying for the last couple of months to take a page out
of <code>http.Handler</code>s playbook and try, as much as possible, to completely avoid
returning an error. Instead of thinking &ldquo;I should return an error here, in case
I ever do any operation that fails&rdquo;, I instead think &ldquo;is there <em>any way at
all</em> I can get away with not returning an error here?&rdquo;. It doesn&rsquo;t always work
and sometimes you <em>do</em> have to pass errors around or wrap them. But I am
forcing myself to think very hard about handling my errors and it encourages a
programming-style of isolating failing components. The constraint of not being
able to return an error tends to make you creative in how to handle it.</p>
<hr>
<p>I think <em>this</em> particular pattern is fine, though, personally, I don&rsquo;t
really see the point. Anything that builds an <code>appError</code> needs to provide
the complete response anyway, so you might as well just write it out
directly. YMMV.</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>You might be tempted to suggest, that you could
define an <code>HTTPError</code>, containing the necessary info. Indeed, that&rsquo;s what the
<a href="https://blog.golang.org/error-handling-and-go#TOC_3.">official Go blog</a> does,
so it can&rsquo;t be bad? And indeed, that <em>is</em> what they do, but note that they do
<em>not</em> actually return an <code>error</code> in the end - they return an <code>appError</code>, which
contains the necessary information. Exactly <em>because</em> they don&rsquo;t know how to
deal with general errors. So they translate any errors into a domain specific
type that carries the response. So, that is <em>not</em> the same as returning an
<code>error</code>.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
]]></content></entry><entry><title type="html">Generating entropy without imports in Go</title><link href="https://blog.merovius.de/posts/2018-01-15-generating_entropy_without_imports_in_go/" rel="alternate" type="text/html"/><id>https://blog.merovius.de//2018/01/15/generating_entropy_without_imports_in_go.html</id><published>2018-01-15T01:04:30+00:00</published><updated>2018-01-15T01:04:30+00:00</updated><content type="html"><![CDATA[<p><strong>tl;dr: I come up with a couple of useless, but entertaining ways to generate entropy without relying on any packages.</strong></p>
<p>This post is inspired by a <a href="https://www.reddit.com/r/golang/comments/7qb74r/can_golang_package_source_with_no_imports_be/dso7xsc/">comment on reddit</a>,
saying</p>
<blockquote>
<p>[…]given the constraints of no imports and the function signature:</p>
<p><code>func F(map[string]string) map[string]string { ... }</code></p>
<p>F must use a deterministic algorithm, since it is a deterministic algorithm
it can be represented in a finite state machine.</p>
</blockquote>
<p>Now, the point of this comment was to talk about how to then compile such a
function into a deterministic finite state machine, but it got me thinking
about a somewhat different question. If we disallow any imports and assume a
standard (gc) Go implementation - how many ways can we find to create a
non-deterministic function?</p>
<p>So, the challenge I set to myself was: Write a function <code>func() string</code> that a)
can not refer to any qualified identifier (i.e. no imports) and b) is
non-deterministic, that is, produces different outputs on each run. To start me
off, I did add a couple of helpers, to accumulate entropy, generate random
numbers from it and to format strings as hex, without any imports:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">rand</span> <span style="color:#66d9ef">uint32</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">r</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">rand</span>) <span style="color:#a6e22e">mix</span>(<span style="color:#a6e22e">v</span> <span style="color:#66d9ef">uint32</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">*</span><span style="color:#a6e22e">r</span> = ((<span style="color:#f92672">*</span><span style="color:#a6e22e">r</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">5</span>) <span style="color:#f92672">+</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">r</span>) <span style="color:#f92672">+</span> <span style="color:#a6e22e">rand</span>(<span style="color:#a6e22e">v</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">r</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">rand</span>) <span style="color:#a6e22e">rand</span>() <span style="color:#66d9ef">uint32</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mx</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">rand</span>(int32(<span style="color:#f92672">*</span><span style="color:#a6e22e">r</span>)<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">31</span>) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xa8888eef</span>
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">*</span><span style="color:#a6e22e">r</span> = <span style="color:#f92672">*</span><span style="color:#a6e22e">r</span><span style="color:#f92672">&lt;&lt;</span><span style="color:#ae81ff">1</span> ^ <span style="color:#a6e22e">mx</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> uint32(<span style="color:#f92672">*</span><span style="color:#a6e22e">r</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">hex</span>(<span style="color:#a6e22e">v</span> <span style="color:#66d9ef">uint32</span>) <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">b</span> []<span style="color:#66d9ef">byte</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">v</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">:=</span> byte(<span style="color:#a6e22e">v</span> <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xf</span>); <span style="color:#a6e22e">x</span> &lt; <span style="color:#ae81ff">10</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">b</span> = append(<span style="color:#a6e22e">b</span>, <span style="color:#e6db74">&#39;0&#39;</span><span style="color:#f92672">+</span><span style="color:#a6e22e">x</span>)
</span></span><span style="display:flex;"><span>		} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">b</span> = append(<span style="color:#a6e22e">b</span>, <span style="color:#e6db74">&#39;a&#39;</span><span style="color:#f92672">+</span><span style="color:#a6e22e">x</span><span style="color:#f92672">-</span><span style="color:#ae81ff">10</span>)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">v</span> <span style="color:#f92672">&gt;&gt;=</span> <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> string(<span style="color:#a6e22e">b</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Obviously, these could be inlined, but separating them allows us to reuse them
for our different functions. Then I set about the actual task at hand.</p>
<h3 id="method-1-map-iteration">Method 1: Map iteration</h3>
<p>In Go, the iteration order of maps is <a href="https://golang.org/ref/spec#For_range">not specified</a>:</p>
<blockquote>
<p>The iteration order over maps is not specified and is not guaranteed to be
the same from one iteration to the next.</p>
</blockquote>
<p>But <code>gc</code>, the canonical Go implementation, actively
<a href="https://golang.org/doc/go1.3#map">randomizes</a> the map iteration order to
prevent programs from depending on it. We can use this, to receive some of
entropy from the runtime, by creating a map and iterating over it:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">MapIteration</span>() <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">r</span> <span style="color:#a6e22e">rand</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">m</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">uint32</span>]<span style="color:#66d9ef">bool</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> uint32(<span style="color:#ae81ff">0</span>); <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">100</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">m</span>[<span style="color:#a6e22e">i</span>] = <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">1000</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">k</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">m</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">mix</span>(<span style="color:#a6e22e">k</span>)
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">break</span> <span style="color:#75715e">// the rest of the loop is deterministic
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">hex</span>(<span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">rand</span>())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We first create a map with a bunch of keys. We then iterate over it a bunch of
times; each map iteration gives us a different start index, which we mix into
our entropy pool.</p>
<h3 id="method-2-select">Method 2: Select</h3>
<p>Go actually defines <a href="https://golang.org/ref/spec#Select_statements">a way</a> in
which the runtime is giving us access to entropy directly:</p>
<blockquote>
<p>If one or more of the communications can proceed, a single one that can
proceed is chosen via a uniform pseudo-random selection.</p>
</blockquote>
<p>So the spec guarantees that if we have multiple possible communications in a
select, the case <em>has</em> to be chosen non-deterministically. We can, again,
extract that non-determinism:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Select</span>() <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">r</span> <span style="color:#a6e22e">rand</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">ch</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">bool</span>)
</span></span><span style="display:flex;"><span>	close(<span style="color:#a6e22e">ch</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">1000</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">select</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">case</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ch</span>:
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">mix</span>(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">case</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ch</span>:
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">mix</span>(<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">hex</span>(<span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">rand</span>())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We create a channel and immediately close it. We then create a select-statement
with two cases and depending on which was taken, we mix a different value into
our entropy pool. The channel is closed, to guarantee that communication can
always proceed. This way, we extract one bit of entropy per iteration.</p>
<p>Note, that there is no racing or concurrency involved here: This is simple,
single-threaded Go code. The randomness comes directly from the runtime. Thus,
this should work in any compliant Go implementation. The <a href="https://play.golang.org/">playground</a>,
however, is not compliant with the spec in this regard, strictly speaking. It
is deliberately deterministic.</p>
<h3 id="method-3-race-condition">Method 3: Race condition</h3>
<p>This method exploits the fact, that on a multi-core machine at least, the Go
scheduler is non-deterministic. So, if we let two goroutines race to write a
value to a channel, we can extract some entropy from which one wins this race:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">RaceCondition</span>() <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">r</span> <span style="color:#a6e22e">rand</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">1000</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">ch</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">uint32</span>, <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">start</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">bool</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>			<span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">start</span>
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>		}()
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>			<span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">start</span>
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>		}()
</span></span><span style="display:flex;"><span>		close(<span style="color:#a6e22e">start</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">mix</span>(<span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ch</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">hex</span>(<span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">rand</span>())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The <code>start</code> channel is there to make sure that both goroutines become runnable
concurrently. Otherwise, the first goroutine would be relatively likely to
write the value before the second is even spawned.</p>
<h3 id="method-4-allocationdata-races">Method 4: Allocation/data races</h3>
<p>Another thought I had, was to try to extract some entropy from the allocator or
GC. The basic idea is, that the address of an allocated value might be
non-deterministic - in particular, if we allocate a lot. We can then try use
that as entropy.</p>
<p>However, I could not make this work very well, for the simple reason that Go
does not allow you to actually do anything with pointers - except dereferencing
and comparing them for equality. So while you might get non-deterministic
values, those values can&rsquo;t be used to actually generate random numbers.</p>
<p>I thought I might be able to somehow get a string or integer representation of
some pointer without any imports. One way I considered was inducing a
runtime-panic and recovering that, in the hope that the error string would
contain a stacktrace or offending values. However, none of the error strings
created by the runtime actually seem to contain any values that could be used
here.</p>
<p>I also tried a workaround to interpret the pointer as an integer, by exploiting
<a href="https://research.swtch.com/gorace">race conditions</a> to do unsafe operations:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">DataRace</span>() <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">r</span> <span style="color:#a6e22e">rand</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">data</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">uintptr</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">addr</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">uintptr</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">j</span>, <span style="color:#a6e22e">k</span> <span style="color:#66d9ef">interface</span>{}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">i</span> = (<span style="color:#f92672">*</span><span style="color:#66d9ef">uintptr</span>)(<span style="color:#66d9ef">nil</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">j</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">data</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">done</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> !<span style="color:#a6e22e">done</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">k</span> = <span style="color:#a6e22e">i</span>
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">k</span> = <span style="color:#a6e22e">j</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">p</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">k</span>.(<span style="color:#f92672">*</span><span style="color:#66d9ef">uintptr</span>); <span style="color:#a6e22e">ok</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">addr</span> = <span style="color:#a6e22e">p</span>
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">done</span> = <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">data</span> = new(<span style="color:#66d9ef">uintptr</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">mix</span>(uint32(<span style="color:#f92672">*</span><span style="color:#a6e22e">addr</span>))
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">hex</span>(<span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">rand</span>())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>It turns out, however, that at least this particular instance of a data race
has been fixed since Russ Cox wrote that blog post. In Go 1.9, this code just
loops endlessly. I tried it in Go 1.5, though, and it works there - but we
don&rsquo;t get a whole lot of entropy (addresses are not <em>that</em> random). With other
methods, we could re-run the code to collect more entropy, but in this case,
I believe the escape analysis gets into our way by stack-allocating the
pointer, so it will be the same one on each run.</p>
<p>I like this method, because it uses several obscure steps to work, but on the
other hand, it&rsquo;s the least reliable and it requires an old Go version.</p>
<h3 id="your-methods">Your Methods?</h3>
<p>These are all the methods I could think of; but I&rsquo;m sure I missed a couple. If
you can think of any, feel free to let me know on
<a href="https://twitter.com/TheMerovius">Twitter</a>,
<a href="https://www.reddit.com/r/golang/comments/7qfvzu/generating_entropy_without_imports_in_go/">reddit</a>
or <a href="https://news.ycombinator.com/item?id=16147475">hackernews</a> :) I also posted
the code in a
<a href="https://gist.github.com/Merovius/283ff12a1186d001815485fca1094968">gist</a>, so
you can download and run it yourself, but keep in mind, that the last method
busy-loops in newer Go versions.</p>
]]></content></entry><entry><title type="html">Monads are just monoids in the category of endofunctors</title><link href="https://blog.merovius.de/posts/2018-01-08-monads-are-just-monoids/" rel="alternate" type="text/html"/><id>https://blog.merovius.de//2018/01/08/monads-are-just-monoids.html</id><published>2018-01-08T00:30:00+00:00</published><updated>2018-01-08T00:30:00+00:00</updated><content type="html"><![CDATA[<p><strong>tl;dr: I explain the mathematical background of a joke-explanation of monads. Contains lots of math and a hasty introduction to category theory.</strong></p>
<p>There is a running gag in the programming community, that newcomers will often
be confused by the concept of monads (which is how sequential computations are
modeled in purely functional languages) and getting the explanation &ldquo;it is
simple, really: Monads are just monoids in the category of endofunctors&rdquo;. This
is not meant as an actual explanation, but rather to poke a bit of fun at the
habit of functional programmers to give quite abstract and theoretical
explanations at times, that are not all that helpful.</p>
<p>However, given my background in mathematics, I decided that I wanted to
actually approach Haskell from this point of view: I am interested in how it
uses math to model programming and also to, after several years of doing mostly
engineering focused programming work, flex my math muscles again</p>
<ul>
<li>as there is quite a bit of interesting math behind these concepts.</li>
</ul>
<p>The quote is from a pretty popular <a href="http://www.maths.ed.ac.uk/~aar/papers/maclanecat.pdf">book about category
theory</a> and is, in full:</p>
<blockquote>
<p>All told, a monad in \(X\) is just a monoid in the category of endofunctors
of \(X\), with product \(\times\) replaced by composition of endofunctors
and unit set by the identity endofunctor.</p>
</blockquote>
<p>This, of course, is an explanation of the <em>mathematical</em> concept of monads,
not meant for programmers. Most explanations of the quote that I found either
assumed quite a bit of knowledge in Haskell or took a lot of liberties with the
mathematical concepts (and relied a lot on &ldquo;squinting&rdquo;) or both. This write up
is my attempt, to walk through all the concepts needed to explain monads as a
mathematical concept and how it relates to Haskell - with as little squinting
as possible.</p>
<p>Of course, there are a couple of disclaimers, I should start with:</p>
<ol>
<li>This is not the best way to understand what monads are, if you are actually
interested in using them to program. In fact, it is literally the worst way.
I would recommend <a href="http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf">this intro</a>,
which takes a much more practical approach.</li>
<li>This is not the best way to understand how category theory works, if you are
actually interested in learning mathematics. In fact, it is literally the
worst way. I would recommend <a href="http://www.maths.ed.ac.uk/~aar/papers/maclanecat.pdf">the book the quote is from</a>,
it&rsquo;s quite good (but assumes a math audience).</li>
<li>I haven&rsquo;t done mathematics in years. I also don&rsquo;t know much Haskell either.
So I might be getting a bunch of stuff wrong to varying degrees. I&rsquo;m sure I
will hear all about it :)</li>
<li>Even if I would <em>understand</em> everything correctly, there are still a lot of
details, mostly of technical nature, I had to omit, to keep this &ldquo;short&rdquo;.
Not that it is short.</li>
</ol>
<p>Originally, I intended this to be the ultimate explanation, which would teach
Haskellers category theory, mathematicians Haskell and people who know neither
both. Unsurprisingly, this is not what this is, at all. It ended up mostly a
write up to assure myself that I understood the path myself. If anything, you
can treat this as a kind of &ldquo;reading companion&rdquo;: If you want to understand this
topic of the intersection between category theory and functional programming,
this post can lead you through the correct terms to search for and give you a
good idea what to focus on, in the respective Wikipedia articles.</p>
<p>With all that out of the way, let&rsquo;s begin.</p>
<h2 id="categories">Categories</h2>
<p>In mathematics, a category is (roughly) a collection of objects and a
collection of arrows between them. There is not a lot of meaning behind these,
but it will probably help you to think of objects as sets and arrows as
mappings.  Every arrow goes from an object (the <em>domain</em>) to an object (the
<em>codomain</em>) and we write an arrow as \(f:X\to Y\), where \(f\) is the name
of the arrow, \(X\) is the domain and \(Y\) is the codomain. Just like with
mappings, there can be many arrows between any given pair of objects - or there
may be none.</p>
<p>We do need <em>some</em> restrictions: First, we require a specific <em>identity</em> arrow
\(\mathrm{id}:X\to X\) attached to every object \(X\), which has \(X\) as
both domain and codomain. Secondly, we require (some) arrows to be
<em>composable</em>. That is if we have two arrows \(f:X\to Y,g:Y\to Z\) - so,
whenever the domain of \(g\) is the codomain of \(f\) - there should also
be a composed arrow<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>
\(g\circ f: X\to Z\), that shares the domain with \(f\) and the codomain with
\(g\).</p>
<p>Furthermore, the identity arrows must act as a <em>unit</em> for composition, that is,
for every arrow \(f\) we require \(\mathrm{id}\circ f = f = f
\circ\mathrm{id}\). We also require composition to be <em>associative</em>, that is
\((f\circ g)\circ h = f\circ(g\circ h)\) (whenever all compositions exist)<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>.</p>
<p>When we talk about a category, we often draw diagrams like this:</p>
<div>
\[
\require{AMScd}
\begin{CD}
X       @>{f}>> Y       \\
@V{g}VV         @VV{p}V \\
Z       @>>{q}> W       \\
\end{CD}
\]
</div>
<p>They show some of the objects and arrows from the category in a compact way.
This particular diagram indicates that there are four objects and four arrows
involved, with obvious domains and codomains. We only draw a subset of the
objects and arrows, that is interesting for the point we are trying to make -
for example, above diagram could also contain, of course, identity arrows and
compositions \(p\circ f\) and \(q\circ g\)), but we didn&rsquo;t draw them. In
a square like this, we can take two paths from \(X\) to \(W\). If these
paths are identical (that is, \(p\circ f = q\circ g\), we say that the
square <em>commutes</em>. A <em>commutative</em> diagram is a diagram, in which any square
commutes, that is, it does not matter which path we take from any object to
another. Most of the time, when we draw a diagram, we intend it to be
commutative.</p>
<p>So, to summarize, to define a mathematical category, we need to:</p>
<ol>
<li>Specify what our objects are</li>
<li>Specify what our arrows are, where each arrow starts and ends at a certain
object</li>
<li>This collection of arrows need to include an arrow \(\mathrm{id}_X\) for
every object \(X\), which starts and ends at \(X\)</li>
<li>And we need to be able to glue together arrows \(f:X\to Y\) and \(g:Y\to
Z\) to an arrow \(g\circ f: X\to Z\)</li>
</ol>
<p>In Haskell, we work on the category <strong>Hask</strong>, which consists of:</p>
<ol>
<li>The objects are <em>types</em>: <code>Int</code> is an object, <code>String</code> is an object but also
<code>Int | String</code>, <code>String -&gt; Int</code> and any other complicated type you can think
of.</li>
<li>The arrows are <em>functions</em>: <code>f :: a -&gt; b</code> is a function taking an <code>a</code> as an
input and returning a <code>b</code> and is represented by an arrow <code>f</code>, which has <code>a</code>
as its domain and <code>b</code> as its codomain.  So, for example, <code>length :: String -&gt; Int</code> would start at the type <code>String</code> and end at <code>Int</code>.</li>
<li>Haskell has a function <code>id :: a -&gt; a</code> which gives us the identity arrow
for any type <code>a</code>.</li>
<li>We can compose functions with the operator <code>(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)</code>. Note, that this follows the swapped notation of \(\circ\), where
the input type of the left function is the output type of the right function.</li>
</ol>
<p>In general, category theory is concerned with the <em>relationship between</em>
categories, whereas in functional programming, we usually only deal with this
one category. This turns out to be both a blessing and a curse: It means that
our object of study is much simpler, but it also means, that it is sometimes
hard to see how to apply the general concepts to the limited environment of
functional programming.</p>
<h2 id="monoids">Monoids</h2>
<p>Understanding categories puts us in the position to understand <em>monoids</em>. A
monoid is the generalized structure underlying concepts like the natural
numbers: We can <em>add</em> two natural numbers, but we can&rsquo;t (in general) <em>subtract</em>
them, as there are no negative numbers. We also have the number \(0\), which,
when added to any number, does nothing - it acts as a <em>unit</em> for addition. And
we also observe, that addition is <em>associative</em>, that is, when doing a bunch of
additions, the order we do them in doesn&rsquo;t matter.</p>
<p>The same properties also apply to other constructs. For example, if we take all
maps from a given set to itself, they can be composed and that composition is
associative and there is a unit element (the identity map).</p>
<p>This provides us with the following elements to define a monoid:</p>
<ol>
<li>A set \(M\)</li>
<li>An operation \(\star\colon M\times M\to M\), which &ldquo;adds&rdquo; together two elements to
make a new one</li>
<li>We need a special unit element \(u\in M\), which acts neutrally when added to
any other element, that is \(m\star u=m=u\star m\)</li>
<li>The operation needs to be associative, that is we always require
\(m\star(n\star k)=(m\star n)\star k\)</li>
</ol>
<p>There is another way to frame this, which is closer in line with category theory.
If we take \(1 := \{0\}\) to be a 1-element set, we can see that the
elements of \(M\) are in a one-to-one correspondence to functions \(1\to M\):
Every such function chooses an element of \(M\) (the image of \(0\)) and
every element \(m\in M\) fixes such a function, by using \(f(0) := m\).
Thus, instead of saying &ldquo;we need a special element of \(M\)&rdquo;, we can also
choose a special <em>function</em> \(\eta: 1\to M\). And instead of talking about an
&ldquo;operation&rdquo;, we can talk about a function \(\mu: M\times M\to M\). Which
means, we can define a monoid via a commutative diagram like so:</p>
<div>
\[
\begin{CD}
1 \\
@V{\eta}VV \\
M \\
\end{CD}
\hspace{1em}
\begin{CD}
M\times M \\
@V{\mu}VV \\
M \\
\end{CD}
\hspace{1em}
\begin{CD}
M\times 1 @>{\mathrm{id}\times\eta}>> M\times M @<{\eta\times\mathrm{id}}<< 1\times M \\
@V{\pi_1}VV                           @V{\mu}VV                             @V{\pi_2}VV \\
M         @>{\mathrm{id}}>>           M         @<{\mathrm{id}}<<           M \\
\end{CD}
\hspace{1em}
\begin{CD}
M\times M\times M @>{\mu\times\mathrm{id}}>> M\times M \\
@V{\mathrm{id}\times\mu}VV                   @V{\mu}VV \\
M\times M         @>{\mu}>>                  M \\
\end{CD}
\]
</div>
<p>\(\pi_1\) and \(\pi_2\) here, are the functions that project to the first
or second component of a cross product respectively (that is \(\pi_1(a, b) :=
a, \pi_2(a, b) := b\)) and e.g. \(\mathrm{id}\times\eta\) is the map that
applies \(\mathrm{id}\) to the first component of a cross-product and
\(\eta\) to the second: \(\mathrm{id}\times\eta(m, 0) = (m, \eta(0))\).</p>
<p>There are four sub-diagrams here:</p>
<ol>
<li>The first diagram just says, that we need an arrow \(\eta:1\to M\). This
chooses a unit element for us.</li>
<li>Likewise, the second diagram just says, that we need an arrow
\(\mu:M\times M\to M\). This is the operation.</li>
<li>The third diagram tells us that the chosen by \(\eta\) should be a unit
for \(\mu\). The commutativity of the left square tells us, that it should
be right-neutral, that is
\[ \forall m\in M: m = \pi_1(m, 0) = \mu(\mathrm{id}\times\eta(m, 0)) = \mu(m, \eta(0)) \]
and the commutativity of the right square tells us, that it should be left-neutral, that is
\[ \forall m\in M: m = \pi_2(0,m) = \mu(\eta\times\mathrm{id}(0, m)) = \mu(\eta(0), m) \]</li>
</ol>
<p>Thus, the first diagram is saying that the element chosen by \(\eta\) should
act like a unit. For example, the left square says</p>
<p>\[\pi_1(m,0) = \mu((\mathrm{id}\times\eta)(m,0)) = \mu(m,\eta(0))\]</p>
<p>Now, writing \(\mu(m,n) = m\star n\) and \(\eta(0) = u\), this is equivalent to saying \(m = u\star m\).</p>
<p>The second diagram is saying that \(\mu\) should be associative: The top arrow
combines the first two elements, the left arrow combines the second two. The right and
bottom arrows then combine the result with the remaining element respectively,
so commutativity of that square means the familiar \(m\star (n\star k) = (m\star n)\star k\).</p>
<p>Haskell has the concept of a monoid too. While it&rsquo;s not really relevant to the
discussion, it might be enlightening to see, how it&rsquo;s modeled. A monoid in
Haskell is a type-class with two (required) methods:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#66d9ef">Monoid</span> a <span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>  mempty <span style="color:#f92672">::</span> a
</span></span><span style="display:flex;"><span>  mappend <span style="color:#f92672">::</span> a <span style="color:#f92672">-&gt;</span> a <span style="color:#f92672">-&gt;</span> a
</span></span></code></pre></div><p>Now, this gives us the operation (<code>mappend</code>) and the unit (<code>a</code>), but where are
the requirements of associativity and the unit acting neutrally? The Haskell
type system is unable to codify these requirements, so they are instead given
as a &ldquo;law&rdquo;, that is, any implementation of a monoid is supposed to have these
properties, to be manually checked by the programmer:</p>
<ul>
<li><code>mappend mempty x = x</code> (the unit is left-neutral)</li>
<li><code>mappend x mempty = x</code> (the unit is right-neutral)</li>
<li><code>mappend x (mappend y z) = mappend (mappend x y) z</code> (the operation is associative)</li>
</ul>
<h2 id="functors">Functors</h2>
<p>I mentioned that category theory investigates the relationship between
categories - but so far, everything we&rsquo;ve seen only happens inside a single
category. Functors are, how we relate categories to each other. Given two
categories \(\mathcal{B}\) and \(\mathcal{C}\), a <em>functor</em>
\(F:\mathcal{B}\to \mathcal{C}\) assigns to every object \(X\) of
\(\mathcal{B}\), an object \(F(X)\) of \(\mathcal{C}\). It also assigns
to every arrow \(f:X\to Y\) in \(\mathcal{B}\) a corresponding arrow
\(F(f): F(X)\to F(Y)\) in \(\mathcal{C}\)<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup>. So, a functor transfers
arrows from one category to another, preserving domain and codomain. To
actually preserve the structure, we also need it to preserve the extra requirements
of a category, identities and composition. So we need, in total:</p>
<ol>
<li>An object map, \(F:O_\mathcal{B} \to O_\mathcal{C}\)</li>
<li>An arrow map, \(F:A_\mathcal{B}\to A_\mathcal{C}\), which preserves
start and end object, that is the image of an arrow \(X\to Y\) starts at
\(F(X)\) and ends at \(F(Y)\)</li>
<li>The arrow map has to preserve identities, that is \(F(\mathrm{id}_X) =
\mathrm{id}_{F(X)}\)</li>
<li>The arrow map has to preserve composition, that is \(F(g\circ f) =
F(g)\circ F(f)\).</li>
</ol>
<p>A trivial example of a functor is the <em>identity functor</em> (which we will call
\(I\)), which assigns each object to itself and each arrow to itself - that
is, it doesn&rsquo;t change the category at all.</p>
<p>A simple example is the construction of the <em>free monoid</em>, which maps from the
category of sets to the category of monoids. The Free monoid \(S^*\) on a
set \(S\) is the set of all finite length strings of elements of \(S\),
with concatenation as the operation and the empty string as the unit. Our
object map then assigns to each set \(S\) its free monoid \(S^*\). And our
arrow map assigns to each function \(f:S\to T\) the function \(f^*:S^*\to
T^*\), that applies \(f\) to each element of the input string.</p>
<p>There is an interesting side note here: Mathematicians love to abstract.
Categories arose from the observation, that in many branches of mathematics we
are researching some class of objects with some associated structure and those
maps between them, that preserve this structure. It turns out that category
theory is a branch of mathematics that is researching the objects of
categories, with some associated structure (identity arrows and composition)
and maps (functors) between them, that preserve that structure. So it seems
obvious that we should be able to view categories <em>as objects of a category</em>,
with functors as arrows. Functors can be composed (in the obvious way) and
every category has an identity functor, that just maps every object and arrow
to itself.</p>
<p>Now, in Haskell, Functors are again a type class:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#66d9ef">Functor</span> f <span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>  fmap <span style="color:#f92672">::</span> (a <span style="color:#f92672">-&gt;</span> b) <span style="color:#f92672">-&gt;</span> (f a <span style="color:#f92672">-&gt;</span> f b)
</span></span></code></pre></div><p>This looks like our arrow map: It assigns to each function <code>g :: a -&gt; b</code> a
function <code>fmap g :: f a -&gt; f b</code>. The object map is implicit: When we write <code>f a</code>,
we are referring to a new type, that depends on <code>a</code> - so we &ldquo;map&rdquo; <code>a</code> to <code>f a</code>
<sup id="fnref:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup>.</p>
<p>Again, there are additional requirements the type system of Haskell can not
capture. So we provide them as laws the programmer has to check manually:</p>
<ul>
<li><code>fmap id  ==  id</code> (preserves identities)</li>
<li><code>fmap (f . g)  ==  fmap f . fmap g</code> (preserves composition)</li>
</ul>
<p>There is one thing to note here: As mentioned, in Haskell we only really deal
with one category, the category of types. That means that a functor always maps
from the category of types to <em>itself</em>. In mathematics, we call such a functor,
that maps a category to itself, an <em>endofunctor</em>. So we can tell, that in
Haskell, every functor is automatically an endofunctor.</p>
<h2 id="natural-transformations">Natural transformations</h2>
<p>We now understand categories and we understand functors. We also understand,
that we can look at something like the category of categories. But the
definition of a monad given to us talks about the <em>category of endofunctors</em>.
So we seem to have to step up yet another level in the abstraction hierarchy
and somehow build this category. As objects, we&rsquo;d like to have endofunctors -
and arrows will be <em>natural transformations</em>, which take one functor to
another, while preserving its internal structure (the mapping of arrows). If
that sounds complicated and abstract, that&rsquo;s because it is.</p>
<p>We need two functors \(F,G:\mathcal{B}\to \mathcal{C}\) of the same &ldquo;kind&rdquo;
(that is, mapping to and from the same categories). A natural transformation
\(\eta:F\dot\to G\) assigns an arrow<sup id="fnref:5"><a href="#fn:5" class="footnote-ref" role="doc-noteref">5</a></sup> \(\eta_X: F(X)\to G(X)\) (called
a <em>component</em> of \(\eta\)) to every object in \(\mathcal{B}\). So a component
\(\eta_X\) describes, how we can translate the action of \(F\) on \(X\)
into the action of \(G\) on \(X\) - i.e. how to translate their object maps.
We also have to talk about the translation of the arrow maps. For that, we observe
that for any arrow \(f:X\to Y\) in \(\mathcal{B}\), we get four new arrows in
\(\mathcal{C}\):</p>
<div>
\[
\begin{CD}
X       \\
@V{f}VV \\
Y       \\
\end{CD}
\hspace{1em}
\begin{CD}
F(X)        @>{\eta_X}>> G(X)       \\
@V{F(f)}VV               @VV{G(f)}V \\
F(Y)        @>>{\eta_Y}> G(Y)       \\
\end{CD}
\]
</div>
<p>For a natural transformation, we require the resulting square to commute.</p>
<p>So, to recap: To create a natural transformation, we need</p>
<ol>
<li>Two functors \(F,G:\mathcal{B}\to\mathcal{C}\)</li>
<li>For every object \(X\) in \(\mathcal{B}\), an arrow \(\eta_X: F(X)\to
G(X)\)</li>
<li>The components need to be compatible with the arrow maps of the functors:
\(\eta_Y\circ F(f) = G(f)\circ \eta_X\).</li>
</ol>
<p>In Haskell, we can define a natural transformation like so:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> (<span style="color:#66d9ef">Functor</span> f, <span style="color:#66d9ef">Functor</span> g) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">Transformation</span> f g <span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>    eta <span style="color:#f92672">::</span> f a <span style="color:#f92672">-&gt;</span> g a
</span></span></code></pre></div><p><code>f</code> and <code>g</code> are functors and a natural transformation from <code>f</code> to <code>g</code> provides
a map <code>f a -&gt; g a</code> for every type <code>a</code>. Again, the requirement of compatibility
with the actions of the functors is not expressible as a type signature, but we
can require it as a law:</p>
<ul>
<li><code>eta (fmap fn a) = fmap fn (eta a)</code></li>
</ul>
<h2 id="monads">Monads</h2>
<p>This, finally, puts us in the position to define monads. Let&rsquo;s look at our quote above:</p>
<blockquote>
<p>All told, a monad in \(X\) is just a monoid in the category of endofunctors
of \(X\), with product \(\times\) replaced by composition of endofunctors
and unit set by the identity endofunctor.</p>
</blockquote>
<p>It should be clear, how we can <em>compose</em> endofunctors. But it is important,
that this is a different view of these things than if we&rsquo;d look at the category
of categories - there, objects are categories and functors are arrows, while
here, objects are <em>functors</em> and arrows are natural transformations. That
shows, how composition of functors can take the role of the cross-product of
sets: In a set-category, the cross product makes a new set out of two other
set. In the category of endofunctors, composition makes a new endofunctor out
of two other endofunctors.</p>
<p>When we defined monoids diagrammatically, we also needed a cross product of
mappings, that is, given a map \(f:X_1\to Y_1\) and a map \(g:X_2\to
Y_2\), we needed the map \(f\times g: X_1\times X_2\to Y_1\times
Y_2\), which operated on the individual constituents. If we want to replace
the cross product with composition of endofunctors, we need an equivalent for
natural transformations. That is, given two natural transformations
\(\eta:F\to G\) and \(\epsilon:J\to K\), we want to construct a natural
transformation \(\eta\epsilon:J\circ F\to K\circ G\). This diagram
illustrates how we get there (working on components):</p>
<div>
\[
\begin{CD}
F(X)    @>{\eta_X}>>    G(X)                  @.                            \\
@V{J}VV                 @VV{J}V               @.                            \\
J(F(X)) @>{J(\eta_X)}>> J(G(X))               @>{\epsilon_{G(X)}}>> K(G(X)) \\
\end{CD}
\]
</div>
<p>As we can see, we can build an arrow \(\epsilon_{G(X)}\circ J(\eta_X):
J(F(X)) \to K(G(X))\), which we can use as the components of our natural
transformation \(\eta\epsilon:J\circ F\to K\circ G\). This construction is
called the <em>horizontal composition</em> of natural transformations. We should
verify that this is indeed a natural transformation - for now, let&rsquo;s just
accept that it follows from the naturality of \(\eta\) and \(\epsilon\).</p>
<p>Lastly, there is an obvious natural transformation taking a functor to itself;
each component being just the identity arrow. We call that natural
transformation \(\iota\), staying with the convention of using Greek letters
for natural transformations.</p>
<p>With this, we can redraw the diagram we used to define monoids above, the
replacements indicated by the quotes:</p>
<div>
\[
\begin{CD}
I \\
@V{\eta}VV \\
M \\
\end{CD}
\hspace{1em}
\begin{CD}
M\circ M \\
@V{\mu}VV \\
M \\
\end{CD}
\hspace{1em}
\begin{CD}
M\circ I @>{\iota\ \eta}>> M\circ M  @<{\eta\ \iota}<< I\circ M \\
@VVV                       @V{\mu}VV                   @VVV \\
M        @>{\iota}>>       M         @<{\iota}<<       M \\
\end{CD}
\hspace{1em}
\begin{CD}
M\circ M\circ M @>{\mu\ \iota}>> M\circ M  \\
@V{\iota\ \mu}VV                 @V{\mu}VV \\
M\circ M        @>{\mu}>>      M         \\
\end{CD}
\]
</div>
<p>The vertical arrows in the middle diagram now simply apply the composition of
functors, using that the identity functor is a unit.</p>
<p>These diagrams encode these conditions on our natural transformations<sup id="fnref:6"><a href="#fn:6" class="footnote-ref" role="doc-noteref">6</a></sup>:</p>
<ul>
<li>\(\mu\circ\eta\iota = \mu = \iota\eta\circ\mu\), that is \(\eta\) serves as a unit</li>
<li>\(\mu\circ\mu\iota = \mu\circ\iota\mu\), that is \(\mu\) is associative</li>
</ul>
<p>To recap, a monad, in category theory, is</p>
<ul>
<li>An endofunctor \(M\)</li>
<li>A natural transformation \(\eta: I\to M\), which serves as an identity for
horizontal composition.</li>
<li>A natural transformation \(\mu: M\circ M\to M\), which is associative in
respect to horizontal composition.</li>
</ul>
<p>Now, let&rsquo;s see, how this maps to Haskell monads.</p>
<p>First, what is the identity functor in Haskell? As we pointed out above, the
object function of functors is implicit, when we write <code>f a</code> instead of <code>a</code>. As
such, the identity functor is simply <code>a</code> - i.e. we map any type to itself.
<code>fmap</code> of that functor would thus also just be the identity
<code>fmap :: (a -&gt; a) -&gt; (a -&gt; a)</code>.</p>
<p>So, what would our natural transformation \(\eta\) look like? As we said, a
natural transformation between two functors is just a map <code>f a -&gt; g a</code>. So (if
we call our endofunctor <code>m</code>) the identity transformation of our monoid is
<code>eta :: a -&gt; m a</code>
mapping the identity functor to <code>m</code>. We also need our monoidal operation, which
should map <code>m</code> applied twice to <code>m</code>:
<code>mu :: m (m a) -&gt; m a</code>.</p>
<p>Now, Haskellers write <code>return</code> instead of <code>eta</code> and write <code>join</code> instead of
<code>mu</code>, giving us the type class<sup id="fnref:7"><a href="#fn:7" class="footnote-ref" role="doc-noteref">7</a></sup></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> (<span style="color:#66d9ef">Functor</span> m) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">Monad</span> <span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>  return <span style="color:#f92672">::</span> a <span style="color:#f92672">-&gt;</span> m a
</span></span><span style="display:flex;"><span>  join <span style="color:#f92672">::</span> m (m a) <span style="color:#f92672">-&gt;</span> m a
</span></span></code></pre></div><p>As a last note, it is worth pointing out that you usually won&rsquo;t implement
<code>join</code>, but instead a different function, called &ldquo;monadic bind&rdquo;:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span>(<span style="color:#f92672">&gt;&gt;=</span>) <span style="color:#f92672">::</span> m a <span style="color:#f92672">-&gt;</span> (a <span style="color:#f92672">-&gt;</span> m b) <span style="color:#f92672">-&gt;</span> m b
</span></span></code></pre></div><p>The reason is, that this more closely maps to what monads are actually <em>used</em>
for in functional programming. But we can move between <code>join</code> and <code>&gt;&gt;=</code> via</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span>(<span style="color:#f92672">&gt;&gt;=</span>) <span style="color:#f92672">::</span> m a <span style="color:#f92672">-&gt;</span> (a <span style="color:#f92672">-&gt;</span> m b) <span style="color:#f92672">-&gt;</span> m b
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">v</span> <span style="color:#f92672">&gt;&gt;=</span> f <span style="color:#f92672">=</span> join ((fmap f) v)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">join</span> <span style="color:#f92672">::</span> m (m a) <span style="color:#f92672">-&gt;</span> m a
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">join</span> v <span style="color:#f92672">=</span> v <span style="color:#f92672">&gt;&gt;=</span> id
</span></span></code></pre></div><h2 id="conclusion">Conclusion</h2>
<p>This certainly was a bit of a long ride. It took me <em>much</em> longer than
anticipated both to understand all the steps necessary and to write them down.
I hope you found it helpful and I hope I didn&rsquo;t make too many, too glaring
mistakes. If so (either), feel free to let me know on
<a href="https://twitter.com/TheMerovius">Twitter</a>,
<a href="https://www.reddit.com/r/haskell/comments/7oudxd/monads_are_just_monoids_in_the_category_of/">reddit</a>
or <a href="https://news.ycombinator.com/item?id=16093508">Hacker News</a> - but please
remember to be kind :)</p>
<p><em>I want to thank <a href="https://twitter.com/r4dler">Tim Adler</a> and
<a href="https://twitter.com/9b17fe">mxf+</a> for proof-reading this absurdly long post
and for making many helpful suggestions for improvements</em></p>
<hr>
<p>The fact that we are not doing that is a completely justified criticism,
that is due to a historical accident - we write function application from
right to left, that is we write \(f(x)\), for applying \(f\) to \(x\).
Accordingly, we write \(g(f(x))\), when applying \(g\) to the result of
applying \(f\) to \(x\). And we chose to have the composite-notation be
consistent with <em>that</em>, instead of the arrow-notation.</p>
<p>I chose to just eat the unfortunate confusion, as it turns out Haskell is
doing exactly the same thing, so swapping things around would just increase
the confusion.</p>
<p>Sorry.</p>
<p>What was that? Oh, you thought Mathematicians where precise? Ha!</p>
<p>This is one of the things that was tripping me up for a while: I was trying to
figure out, how I would map types to other types in Haskell or even talk about
the object map. But the most useful answer is &ldquo;you don&rsquo;t&rdquo;.</p>
<script defer crossorigin="anonymous" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>It is often confusing to people, that the way the
arrows point in the notation and the order they are written seems to contradict
each other: When writing \(f:X\to Y\) and \(g:Y\to Z\) you might reasonably
expect their composite to work like \(f\circ g: X\to Z\), that is, you glue
together the arrows in the order you are writing them.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>Keep in mind that this is a different notion from the
ones for monoids, which we come to a bit later: While the formulas seem the
same and the identities look like a unit, the difference is that only certain
arrows can be composed, not all. And that there are many identity arrows, not
just one. However, if we would have only <em>one</em> object, it would have to be the
domain and codomain of every arrow and there would be exactly one identity
arrow. In that case, the notions <em>would</em> be the same and indeed, &ldquo;a category
with exactly one object&rdquo; is yet another way to define monoids.&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3" role="doc-endnote">
<p>It is customary, to use the same name for the object
and arrow map, even though that may seem confusing. A slight justification of
that would be, that the object map is already given by the arrow map anyway: If
\(F\) is the arrow map, we can define the object map as \(X\mapsto
\mathrm{dom}(F(\mathrm{id}_X))\). So, given that they are always occurring
together and you can make one from the other, we tend to just drop the
distinction and save some symbols.&#160;<a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:4" role="doc-endnote">
<p>It is important to note, that this is not really a
<em>function</em>. Functions operate on values of a given type. But here, we are
operating on <em>types</em> and Haskell has no concept of a &ldquo;type of types&rdquo; built in
that a function could operate on. There are constructs operating on types to
construct new types, like <code>data</code>, <code>type</code>, <code>newtype</code> or even <code>deriving</code>. But
they are special syntactical constructs that exist outside of the realm of
functions.&#160;<a href="#fnref:4" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:5" role="doc-endnote">
<p>An important note here, is that the \(\eta_X\) are
<em>arrows</em>. Where the object map of a functor is just a general association which
could look anything we like, the components of a natural transformation need to
preserve the internal structure of the category we are working in.&#160;<a href="#fnref:5" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:6" role="doc-endnote">
<p>You will often see these conditions written
differently, namely written e.g. \(\mu M\) instead of \(\mu\iota\). You can
treat that as a notational shorthand, it really means the same thing.&#160;<a href="#fnref:6" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:7" role="doc-endnote">
<p>There is a technicality here, that Haskell also has
an intermediate between functor and monad called &ldquo;applicative&rdquo;. As I understand
it, this does not have a clear category theoretical analogue. I&rsquo;m not sure why
it exits, but I believe it has been added into the hierarchy after the fact.&#160;<a href="#fnref:7" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
]]></content></entry><entry><title type="html">My case for veganism</title><link href="https://blog.merovius.de/posts/2018-01-02-my-case-for-veganism/" rel="alternate" type="text/html"/><id>https://blog.merovius.de//2018/01/02/my-case-for-veganism.html</id><published>2018-01-02T00:23:00+00:00</published><updated>2018-01-02T00:23:00+00:00</updated><content type="html"><![CDATA[<p>I&rsquo;m going to try to make an argument for being vegan, but, to be clear, it is
not very likely to convince you to change your eating habits. It is not
designed to - it is only supposed to change the way you think about it. I
mention all of that, so you are aware that <em>I don&rsquo;t care</em> what your conclusions
are here. If you are reading this, you should do so out of a genuine interest
of my motives and for the purpose of self-reflection - not to pick a fight with
that vegan dude and really show him he&rsquo;s wrong. I will not debate the content
of this article with you. So, with that out of the way, here is a thought
experiment:</p>
<blockquote>
<p>Say, we would live in a Star Trek like post-scarcity society. Energy is all
but abundant and we figured out replicator-technology, that can instantly
create anything we like out of it. You get offer the choice between two
meals, one is a delicious steak dinner (or whatever), made in a traditional
manner. The second is the same thing, but from a replicator. Both are
indistinguishable, they taste the same, they have the same nutritional and
chemical composition, they cost the same. <em>They only differ in how they&rsquo;re
made.</em></p>
</blockquote>
<p>You might be trying to rules-lawyer this. You might be trying to make up an
argument, for why the replicator-steak would <em>have</em> to be worse. Or that the
cow would already be dead, so it wouldn&rsquo;t matter. But that is obviously not the
point of this thought experiment (and remember, you don&rsquo;t have to convince
anyone of being right, here). The point is, that I strongly believe that the
vast majority of people would agree, that <em>all things being equal</em>, choosing
the meal that no animal suffered for is <em>the correct choice</em>. And if you truly
believe that it isn&rsquo;t, if you can honestly say to yourself that it doesn&rsquo;t
matter: You won&rsquo;t gain anything from the rest of this article. You are relieved
and might now just as well stop reading.</p>
<p>The point I am trying to make, is that you probably already know all the
reasons you <em>should</em> be vegan. It&rsquo;s very likely that you already have an
intuitive understanding of all the reasons in the &ldquo;pro veganism&rdquo; column of your
pro/contra list. And it really shouldn&rsquo;t be necessary to convince you it&rsquo;s a
good idea, in general.</p>
<p>Why then, do so few people actually <em>choose</em> to be vegan, if they are fully
aware of all the reasons to do so? The obvious answer is: Because not all
things <em>are</em> being equal. There is a &ldquo;contra veganism&rdquo; column and it&rsquo;s filled
with many good reasons <em>not</em> to. What reasons those are, is deeply individual.
It might be due to health. Due to an appeal to nature. Convenience. Money.
Availability. Taste. Or maybe just priorities: Other things seem more important
and deserving of your energy. <em>And that&rsquo;s okay</em>. We all have to make hundreds
of decisions every day and weigh these kinds of questions. And sometimes we do
things that we shouldn&rsquo;t and we usually have good reasons to. And sometimes we
compromise and don&rsquo;t go <em>all the way</em>, but just do the best we feel able to and
that&rsquo;s fine too. Nobody has to be perfect all the time.</p>
<p>The reason, I&rsquo;m writing this article anyway, is that there is a fundamental
difference between the two questions &ldquo;Why are you vegan?&rdquo; and &ldquo;Why are you not
<em>not</em> vegan?&rdquo;. When you ask me why I am vegan, you are making the conversation
inherently about my values and you will usually end up attacking them - not
because you disagree with them (you likely are not), but just because that&rsquo;s
the natural progression of this question. And to be absolutely clear: I don&rsquo;t
owe you a justification for my value system. I&rsquo;m sorry if that sounds harsh,
but the topic is mostly
<a href="/posts/2017-10-20-a-day-in-the-life-of-an-omnivore/">really annoying</a>
to me (as hard as that may be to believe at this point).</p>
<p>A more sensible question, though, is to ask how to best <em>mitigate the
contra</em>-column. If we agree that, fundamentally, the points in the pro-column
are valid and shared reasons, we can proceed into the much more productive
conversation about how much weight the downsides really have and how you might
be able to reduce at least some of their impact. And, again to be clear: The
outcome of that might very well be, that your reasons are completely valid,
rational and that, applied to your personal situation, veganism wouldn&rsquo;t be a
good choice. (And to be also clear: I might not be in the mood to have <em>this</em>
conversation either. But it&rsquo;s much preferable).</p>
<p>So, what I wish people to take away from this is</p>
<ol>
<li>Stop asking why you should be vegan (or why I am), you more than likely
already know. If you are really interested in making an informed choice,
bring up your concerns instead, but also accept if I don&rsquo;t want to talk
about them at that particular time - it&rsquo;s a lot of emotional labor, to give
the same explanations repeatedly. It might not seem like a big deal to me,
to ask these questions, but I&rsquo;ve repeated most of my answers literally
hundreds of times at this point and might prefer to just enjoy my food.</li>
<li>Stop treating veganism as a <em>preference</em> and start treating it as a <em>moral
choice</em>. There is a qualitative difference between someone who does not like
Italian food and a vegan. This is interesting when choosing what or where to
eat as a group: This is hard enough as it is and I at least usually try very
hard to accommodate everyone and not be a burden. And I absolutely do not
expect to be treated like I&rsquo;m better for that. But if it actually would come
down to a choice between a vegetarian restaurant or a steakhouse, just
because you really like meat: Yes, I do absolutely expect us to avoid the
steakhouse. (To be clear: In my experience, it rarely <em>actually</em> comes down
to only those two choices. And there are good reasons to avoid vegetarian
restaurants that are not based on preference which should be given ample
weight too - e.g. someone I know has Coeliac disease, fructose intolerance
and lactose intolerance and tends to have a very hard time eating non-meat
things. In my experience, though, people who have needs and not just
preferences tend to ironically be more open to compromise anyway, so it is
less often a problem with them).</li>
<li>Maybe think about your reasons for not being vegan and evaluate them
seriously. To be clear, this is a stretch-goal and not the actual point of
this article.</li>
</ol>
<p>And if you want to, you can watch someone who does eat meat say <em>essentially</em>
the same things here:</p>
<div class="video-container">
  <iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/uwKrtNr76BM" frameborder="0" allowfullscreen></iframe>
</div>
<p>Thanks for reading, don&rsquo;t @ me. ;)</p>
<hr>
<h2 id="reasons-im-not-not-vegan">Reasons I&rsquo;m not <em>not</em> vegan</h2>
<p>Now, the main point of this post is dedicated to the general question of &ldquo;how I
think about the topic and how I believe you should think about it too&rdquo;. But I
also want it to serve as a reference of my personal, specific thoughts driving
my decision - so if you don&rsquo;t know me well or are not interested in my personal
reasons, this would be a good place to close the tab and do something else.</p>
<p>I&rsquo;m still writing this, because I hope this can be the last thing I ever have
to write about this (yeah, lol). Because again, I don&rsquo;t actually <em>like</em>
discussing it, as unbelievable as that may seem. So here is, as a reference,
why <em>I</em> am vegan (and I might add to/change this list over time, when my
viewpoints evolve). Why, after ten-ish years of thinking &ldquo;I <em>should</em> be vegan,
but…&rdquo;, I decided to make the switch - or at least give it a serious try. So,
this is a list of reasons I gave to myself to justify not going vegan and why
they stopped being convincing <em>to me</em>. Your mileage may vary.</p>
<h3 id="meatcheeseeggsbaileys-is-awesome-and-i-cant-imagine-giving-it-up">Meat/Cheese/Eggs/Bailey&rsquo;s is awesome and I can&rsquo;t imagine giving it up.</h3>
<p>For most of my life I didn&rsquo;t think about vegetarianism or veganism at all.
Eating meat was the default, so that&rsquo;s what I did. When I did start to think
about it, I convinced myself that I couldn&rsquo;t give up meat, because most of
my favorite foods where meat-based. However, a lot of people in my
peer-group around that time (university) where vegetarian or vegan, so I
naturally got into contact with a lot of good food that <em>wasn&rsquo;t</em> naturally
meat-based. So I started eating less and less meat - and the less meat I
ate, the more I realized I didn&rsquo;t really <em>miss</em> it that much, given how much
good alternatives there are. Eventually I decided to become a &ldquo;flexitarian&rdquo;,
which very quickly (in ~1-2 months) became &ldquo;vegetarian&rdquo;, when I realized
that it didn&rsquo;t actually bother me to not eat meat at all - and making that
commitment meant less decisions, so it made things easier. With
Cheese/Eggs/Bailey&rsquo;s, I basically went through exactly the same transition,
six or seven years later: &ldquo;I can&rsquo;t imagine giving them up&rdquo; - &ldquo;Actually,
there are really good alternatives&rdquo; - &ldquo;Let&rsquo;s just try reducing it and see
how far I get&rdquo; - &ldquo;Meh, might as well just commit completely&rdquo;.</p>
<p>So, to me, giving up animal products just turned out much easier, than
expected, when I actually tried. And I&rsquo;m not saying I don&rsquo;t <em>miss</em> them,
every once in a while, I will still look longingly at a steak or think
fondly of my scrambled eggs. But for the most part, the alternatives are
just as great (or at times better), so it isn&rsquo;t <em>as</em> big a sacrifice as
expected.</p>
<h3 id="being-vegetarianvegan-is-unhealthy">Being vegetarian/vegan is unhealthy.</h3>
<p>There is a bunch of research about this and for a while (especially before
actually looking into the details) the health implications of veganism
(vegetarianism not so much) did concern me. But, it turns out, this topic is
pretty complicated. Nutrition research is <em>very hard</em> - and that manifests
in the fact that for most of it, the statistical significance is usually low
and the effect sizes usually small. Now, I&rsquo;m not <em>denying</em>, that there are
health downsides to a vegan diet. But even <em>with</em> the general mess that
nutritional research is, it doesn&rsquo;t seem very controversial that if you are
concerned for your health, there are much more important factors to
consider. If weighed against the health benefits of sleeping more, doing
more sports, not sitting all day, stop recreational drug use, taking
extensive vacations… (neither of which I seem to be willing to do, even
though they would be easy enough), the relatively minor health effects of
eating animal products (contrasted with a somewhat balanced vegan diet plus
supplementation) just did not seem to be a relevant driving force for that
decision and more of a rationalization.</p>
<p>That being said, from what I can gather so far, there is a general consensus
that if a) you pay attention to having a somewhat balanced diet and b) are
willing to supplement the nutrients you <em>can&rsquo;t</em> actually get, the health
impact of veganism is pretty low, if any. Personally, I am supplementing
Vitamins B12 and D right now, which has very low quality of life impact - so
I don&rsquo;t consider that a significant downside. I also pay a little bit more
attention to what I&rsquo;m eating, which I consider a good thing.</p>
<p>If it turns out that I can not sustain a vegan diet, I will reconsider it,
but for now, I don&rsquo;t see any realistic danger of that happening.</p>
<h3 id="it-is-cumbersome-to-know-whether-or-not-something-is-vegan">It is cumbersome to know whether or not something is vegan.</h3>
<p>This is mostly true. As a vegetarian, this mostly revolved around looking
for gelatin in the ingredients of sweets and asking in a restaurant whether
&ldquo;Lasagna&rdquo; is made with meat or not. Being a vegan does involve a <em>lot</em> of
scanning ingredients-lists of basically every product I buy. Though I&rsquo;m
positively surprised how many vendors are recently starting to choose to get
their products <a href="https://www.v-label.eu/">certified</a> - and not only brands
you would expect to focus on that, but also, increasingly, all kinds of
mainstream products.</p>
<p>That being said, there <em>is</em> an availability issue (especially around &ldquo;may
contain traces of…&rdquo;, which is basically saying &ldquo;if you are allergic, we
can&rsquo;t rule out cross-contamination of other things from the same factory&rdquo;).
I tend to be pragmatic about this: If I have the choice, I will buy the
certifiably vegan option, otherwise I&rsquo;m also fine with traces of animal
products, personally. If I don&rsquo;t know, I will go with my best guess and how
I feel in the moment.</p>
<p>This is definitely the most true and heavy argument still on the contra-side
for me, but being kind of pragmatic about it helps alleviate most of the
pain.</p>
<h3 id="its-hypocritical-to-draw-the-line-at-x-and-not-at-y">It&rsquo;s hypocritical to draw the line at X and not at Y.</h3>
<p>You can always be more rigorous and there are a lot of line-drawing
questions that come up when thinking about vegetarianism/veganism. For the
record, a lot of that is just plain nonsense, but there are some
legitimate questions to be asked around whether or not insects count, for
example, or certain shellfish, whether you would eat meat if it would be
thrown away otherwise or would eat an egg, if the Hen laying it was living a
happy, free life. In the end, the vast majority of things you can eat will
involve <em>some</em> harm to the environment or animals and you won&rsquo;t always know,
so where do you draw the line?</p>
<p>Personally, I decided that <em>definite</em> harm is worse than <em>potential</em> harm
and <em>more</em> harm is worse than <em>less</em> harm. &ldquo;It is hypocritical to not eat
meat/cheese/eggs but still kill a wasp entering your apartment&rdquo; is about as
convincing an argument to me as &ldquo;it is hypocritical to eat meat/cheese/eggs
but not also eat dogs/jellyfish/human&rdquo;. The world isn&rsquo;t black-and-white and
it&rsquo;s fine to choose a gray spot in the middle that makes you comfortable.</p>
<h3 id="eating-out-becomes-a-pita">Eating out becomes a PITA.</h3>
<p>Yes. Going out and eating in a group is a PITA. Honestly, there are no two
ways about it. I do have to actively make sure that a chosen food place has
options for me and more often than not that does involve making special
requests and/or making do with less great meals.</p>
<p>In general, this still works reasonably well. The cafeteria at work has
<em>great</em> vegan options most of the time, Zurich has an amazing choice of
great restaurants for vegans to offer, most other restaurants can accommodate
too and even if not, I&rsquo;m fine just eating a little thing and then later eat
some more at home.</p>
<p>The main problem is working around the social issues associated with it -
dealing with people who are unwilling to be accommodating, having to
justify/discuss my choice or just exposing something about my person I might
prefer to keep private. Basically, I wrote
<a href="/posts/2017-10-20-a-day-in-the-life-of-an-omnivore/">a whole thing about this</a>.</p>
<p>But this is simply one of those downsides I chose to accept. Nobody said
going vegan wouldn&rsquo;t come with sacrifices.</p>
<h3 id="being-vegan-is-expensive">Being vegan is expensive</h3>
<p>I am not sure this is true <em>in general</em>. I am relatively sure, that being
vegetarian at least actually ended up <em>saving</em> me money as a student. But I
can&rsquo;t be completely certain, as the change also came with other changes in
circumstances. My vegan diet is <em>probably</em> more expensive than my vegetarian
one, mainly because it includes a lot more processed substitute products
(&ldquo;faux meat&rdquo; and various plant milks, which are at least in Switzerland
still significantly more expensive than the cow-based variants), but again,
I didn&rsquo;t actually run any numbers.</p>
<p>I&rsquo;m pretty sure it&rsquo;s possible to have an affordable vegan diet, especially
if limiting processed substitute products and not eating out so often.
Luckily, this isn&rsquo;t really a concern for me, right now, though. Food and
Groceries is a <em>relatively</em> small proportion of my monthly expenses and as
such, the impact this has on me is pretty limited either way.</p>
<p>I convinced myself, that if I can afford spending money on all kinds of
luxury items and electronic gadgets, I can probably afford spending a little
more on food.</p>
]]></content></entry></feed>