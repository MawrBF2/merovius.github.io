<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>SQL authentication timing side-channels | Mero's Blog</title><meta name=keywords content="programming"><meta name=description content="It is surprisingly hard to make SQL-based authentication immune to timing side-channels, if you want to prevent enumeration of users."><meta name=author content><link rel=canonical href=https://blog.merovius.de/posts/2015-04-13-difficulties-making-sql-based-au/><link crossorigin=anonymous href=/assets/css/stylesheet.min.48a18943c2fc15c38a372b8dde1f5e5dc0bc64fa6cb90f5a817d2f8c76b7f3ae.css integrity="sha256-SKGJQ8L8FcOKNyuN3h9eXcC8ZPpsuQ9agX0vjHa3864=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.4dcb3c4f38462f66c6b6137227726f5543cb934cca9788f041c087e374491df2.js integrity="sha256-Tcs8TzhGL2bGthNyJ3JvVUPLk0zKl4jwQcCH43RJHfI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://blog.merovius.de/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.merovius.de/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.merovius.de/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.merovius.de/apple-touch-icon.png><link rel=mask-icon href=https://blog.merovius.de/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="SQL authentication timing side-channels"><meta property="og:description" content="It is surprisingly hard to make SQL-based authentication immune to timing side-channels, if you want to prevent enumeration of users."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.merovius.de/posts/2015-04-13-difficulties-making-sql-based-au/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2015-04-13T02:49:53+00:00"><meta property="article:modified_time" content="2015-04-13T02:49:53+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="SQL authentication timing side-channels"><meta name=twitter:description content="It is surprisingly hard to make SQL-based authentication immune to timing side-channels, if you want to prevent enumeration of users."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.merovius.de/posts/"},{"@type":"ListItem","position":2,"name":"SQL authentication timing side-channels","item":"https://blog.merovius.de/posts/2015-04-13-difficulties-making-sql-based-au/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"SQL authentication timing side-channels","name":"SQL authentication timing side-channels","description":"It is surprisingly hard to make SQL-based authentication immune to timing side-channels, if you want to prevent enumeration of users.","keywords":["programming"],"articleBody":"I’ve been thinking about how to do an authentication scheme, that uses some kind of relational database (it doesn’t matter specifically, that the database is relational, the concerns should pretty much apply to all databases) as a backing store, in a way that is resilient against timing side-channel attacks and doesn’t leak any data about which usernames exist in the system and which don’t.\nThe first obvious thing is, that you need to do a constant time comparison of password-hashes. Luckily, most modern crypto libraries should include something like that (at least go’s bcrypt implementation comes with that).\nBut now the question is, how you prevent enumerating users (or checking for existence). A naive query will return an empty result set if the user does not exists, so again, obviously, you need to compare against some password, even if the user isn’t found. But just doing, for example\nif result.Empty { \t// Compare against a prepared hash of an empty password, to have constant \t// time check. \tbcrypt.CompareHashAndPassword(HashOfEmptyPassword, enteredPassword) } else { \tbcrypt.CompareHashAndPassword(result.PasswordHash, enteredPassword) } won’t get you very far. Because (for example) the CPU will predict either of the two branches (and the compiler might or might not decide to “help” with that), so again an attacker might be able to distinguish between the two cases. The best way, to achieve resilience against timing side-channels is to make sure, that your control flow does not depend on input data at all. Meaning no branch or loop should ever take in any way into account, what is actually input into your code (including the username and the result of the database query).\nSo my next thought was to modify the query to return the hash of an empty password as a default, if no user is found. That way, your code is guaranteed to always get a well-defined bcrypt-hash from the database and your control flow does not depend on whether or not the user exists (and an empty password can be safely excluded in advance, as returning early for that does not give any new data to the attacker).\nWhich sounds well, but now the question is, if maybe the timing of your database query tells the attacker something. And this is where I hit a roadblock: If the attacker knows enough about your code (i.e. what database engine you are using, what machine you are running on and what kind of indices your database uses) they can potentially enumerate users by timing your database queries. To illustrate: If you would use a simple linear list as an index, a failed search has to traverse the whole list, whereas a successfull search will abort early. The same issue exists with balanced trees. An attacker could potentially hammer your application with unlikely usernames and measure the mean time to answer. They can then test individual usernames and measure if the time to answer is significantly below the mean for failures, thus enumerating usernames.\nNow, I haven’t tested this for practicality yet (might be fun) and it is pretty likely that this can’t be exploited in reality. Also, the possibility of enumerating users isn’t particularly desirable, but it is also far from a security meltdown of your authentication-system. Nevertheless, the idea that this theoretical problem exists makes me uneasy.\nAn obvious fix would be to make sure, that every query always has to search the complete table on every lookup. I don’t know if that is possible, it might be just trivial by not giving a limit and not marking the username column as unique, but it might also be hard and database-dependent because there will still be an index over this username column which might still create the same kind of issues. There will also likely still be a variance, because we basically just shifted the condition from our own code into the DBMS. I have simply no idea.\nSo there you have it. I am happy to be corrected and pointed to some trivial design. I will likely accept the possibity of being vulnerable here, as the systems I am currently building aren’t that critical. But I will probably still have a look at how other projects are handling this. And maybe if there really is a problem in practice.\n","wordCount":"711","inLanguage":"en","datePublished":"2015-04-13T02:49:53Z","dateModified":"2015-04-13T02:49:53Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.merovius.de/posts/2015-04-13-difficulties-making-sql-based-au/"},"publisher":{"@type":"Organization","name":"Mero's Blog","logo":{"@type":"ImageObject","url":"https://blog.merovius.de/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.merovius.de/ accesskey=h title="Mero's Blog (Alt + H)">Mero's Blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>SQL authentication timing side-channels</h1><div class=post-meta><span title="2015-04-13 02:49:53 +0000 UTC">April 13, 2015</span></div></header><div class=post-content><p>I&rsquo;ve been thinking about how to do an authentication scheme, that uses some
kind of relational database (it doesn&rsquo;t matter specifically, that the database
is relational, the concerns should pretty much apply to all databases) as a
backing store, in a way that is resilient against timing side-channel attacks
and doesn&rsquo;t leak any data about which usernames exist in the system and which
don&rsquo;t.</p><p>The first obvious thing is, that you need to do a constant time comparison of
password-hashes. Luckily, most modern crypto libraries should include something
like that (at least go&rsquo;s bcrypt implementation comes with that).</p><p>But now the question is, how you prevent enumerating users (or checking for
existence). A naive query will return an empty result set if the user does not
exists, so again, obviously, you need to compare against <em>some</em> password, even
if the user isn&rsquo;t found. But just doing, for example</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>result</span>.<span style=color:#a6e22e>Empty</span> {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Compare against a prepared hash of an empty password, to have constant
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// time check.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>bcrypt</span>.<span style=color:#a6e22e>CompareHashAndPassword</span>(<span style=color:#a6e22e>HashOfEmptyPassword</span>, <span style=color:#a6e22e>enteredPassword</span>)
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>bcrypt</span>.<span style=color:#a6e22e>CompareHashAndPassword</span>(<span style=color:#a6e22e>result</span>.<span style=color:#a6e22e>PasswordHash</span>, <span style=color:#a6e22e>enteredPassword</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>won&rsquo;t get you very far. Because (for example) the CPU will predict either of
the two branches (and the compiler might or might not decide to &ldquo;help&rdquo; with
that), so again an attacker might be able to distinguish between the two cases.
The best way, to achieve resilience against timing side-channels is to make
sure, that your control flow does not depend on input data <em>at all</em>. Meaning no
branch or loop should ever take in any way into account, what is actually input
into your code (including the username and the result of the database query).</p><p>So my next thought was to modify the query to return the hash of an empty
password as a default, if no user is found. That way, your code is guaranteed
to always get a well-defined bcrypt-hash from the database and your control
flow does not depend on whether or not the user exists (and an empty password
can be safely excluded in advance, as returning early for that does not give
any new data to the attacker).</p><p>Which sounds well, but now the question is, if maybe the timing <em>of your
database query</em> tells the attacker something. And this is where I hit a
roadblock: If the attacker knows enough about your code (i.e. what database
engine you are using, what machine you are running on and what kind of indices
your database uses) they can potentially enumerate users by timing your
database queries. To illustrate: If you would use a simple linear list as an
index, a failed search has to traverse the whole list, whereas a successfull
search will abort early. The same issue exists with balanced trees. An attacker
could potentially hammer your application with unlikely usernames and measure
the mean time to answer. They can then test individual usernames and measure if
the time to answer is significantly below the mean for failures, thus
enumerating usernames.</p><p>Now, I haven&rsquo;t tested this for practicality yet (might be fun) and it is pretty
likely that this can&rsquo;t be exploited in reality. Also, the possibility of
enumerating users isn&rsquo;t particularly desirable, but it is also far from a
security meltdown of your authentication-system. Nevertheless, the idea that
this theoretical problem exists makes me uneasy.</p><p>An obvious fix would be to make sure, that every query always has to search
the complete table on every lookup. I don&rsquo;t know if that is possible, it might
be just trivial by not giving a limit and not marking the username column as
unique, but it might also be hard and database-dependent because there will
still be an index over this username column which might still create the same
kind of issues. There will also likely still be a variance, because we
basically just shifted the condition from our own code into the DBMS. I have
simply no idea.</p><p>So there you have it. I am happy to be corrected and pointed to some trivial
design. I will likely accept the possibity of being vulnerable here, as the
systems I am currently building aren&rsquo;t that critical. But I will probably still
have a look at how other projects are handling this. And maybe if there really
is a problem in practice.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.merovius.de/tags/programming/>programming</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://blog.merovius.de/>Mero's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>