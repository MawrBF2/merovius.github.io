<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-us"><generator uri="https://gohugo.io/" version="0.96.0">Hugo</generator><title type="html">in education on Mero's Blog</title><link href="https://blog.merovius.de/tags/education/"/><link type="application/atom+xml" rel="self" href="https://blog.merovius.de/tags/education/atom.xml"/><updated>2022-04-06T09:21:40+00:00</updated><id>https://blog.merovius.de/tags/education/</id><author><name>Axel Wagner</name></author><entry><title type="html">Incentives in education</title><link href="https://blog.merovius.de/posts/2013-12-16-incentives-in-education/" rel="alternate" type="text/html"/><id>https://blog.merovius.de//2013/12/16/incentives-in-education.html</id><published>2013-12-16T01:32:47+00:00</published><updated>2013-12-16T01:32:47+00:00</updated><content type="html"><![CDATA[<p><strong>tl;dr: I hate software-engineering as it is teached in Heidelberg. Really</strong></p>
<p>I often recited the story of how I got to choose computer science over physics
as a minor in my mathematics bachelor:</p>
<p>After sitting through almost one semester of the introductory course to
theoretical physics in my 3rd semester — which is incredibly unsatisfactory
and boring, once you are past your first year of mathematics — I suddenly
realized that my reward for suffering through yet another problem sheet of
calculating yet another set of differential operators is, that I have to suffer
through four or five more of these type of courses. This really seemed like a
poor incentive, when I was just discovering hacking and that I was really good
at computer science. So I decided to pass on the opportunity, did not work all
night on that last sheet (and later found out that I would have gotten credit
for that course without even taking the written exam if I just handed in this
additional problem sheet) and instead decided to minor in computer science.</p>
<p>Three years after that I decided to get a second bachelor degree in computer
science (I finished my bachelor of mathematics earlier that year and was
pursuing my master degree at that point), because it seemed a really easy thing
to do at that point: I only needed two semesters more of studies and a bachelor
thesis. That is not a lot of work for a degree. We are now one year and some
change after that point, and there really is not a lot I need anymore.
Basically I only need to finish the introduction to software engineering and
then write my thesis. Yay for me.</p>
<p>The reason I write this (and the reason I started with the anecdote of
physics) is that once again I am questioning the incentives versus the cost.
Since I am pretty sure that it would actually be fun to write my thesis, it all
boils down to the question, whether I want to finish this course (which again,
I&rsquo;m more than halfway done with, it is not a lot work to go) to get a bachelor
degree in computer science. And don&rsquo;t get me wrong — I&rsquo;m sure that software
engineering is a topic, that can be interesting and captivating, or at the
minimum bearable. But the way it is done here in Heidelberg is just hell. It is
incredibly boringly presented and consists of a flood of uninteresting
repetitive tasks and the project-work, to show how important teamwork and
quality-assurance and drawing a <strong>lot</strong> of diagrams is, is a catastrophically
bad, unusable and ugly piece of crapware, that can&rsquo;t even decently perform the
very simple task it was designed to (managing a private movie collection. I
mean, come on, it is not exactly rocket science to do this in at least a barely
usable way).</p>
<p>And even though it is a hell that I would only have to endure for about two or
three problem sheets and one written exam, I watch myself putting off the work
on it (for example by writing this stupid blogpost) and I seriously question
whether this second bachelor is really incentive enough to suffer through it.</p>
<p>If it was my first degree, that would of course be a clear ”yes“. But a second
one? Not sure. Ironically the main way I&rsquo;m putting of work on this problem
sheet — I got up today at 10am, to immediately and energetically start to work
on it — is watching I lot of TED talks on youtube. That&rsquo;s right, I practically
spent 14 hours more or less non-stop watching TED talks. This one applies to
some extend — extrinsic incentives can only go this far in making us do some
work; at some point, without at least some intrinsic motivation, I at least
will not perform very well (or at all):</p>
<div class="video-container">
  <iframe width="560" height="315" src="//www.youtube-nocookie.com/embed/rrkrvAUbU9Y" frameborder="0" allowfullscreen></iframe>
</div>
]]></content></entry><entry><title type="html">First-year introductory course for programming</title><link href="https://blog.merovius.de/posts/2013-09-28-firstyear-introductory-course-fo/" rel="alternate" type="text/html"/><id>https://blog.merovius.de//2013/09/28/firstyear-introductory-course-fo.html</id><published>2013-09-28T03:16:52+00:00</published><updated>2013-09-28T03:16:52+00:00</updated><content type="html"><![CDATA[<p><strong>tl;dr: I gave a very introductory programming course and saw once again how
the basic ideas underlying the modernization of teaching <em>just work</em> when
implemented right.</strong></p>
<p>This last week I organized a (very basic) introductory course on programming for
our first-year students. I was set on C++ because it is the language used in the
introductory lecture and we wanted to give people with absolutely no background
in programming or proper use of a computer the necessary tools to start in this
lecture on mostly equal grounds to people who already took a basic computer
science course in school. We had five days, with 3 hours a day to try to reach
that goal, which is a very limited amount of time for such a course and we had
50 participants.</p>
<p>The whole concept of the course was very modern (at least for our universities
standards) - instead of just giving lectures, telling people about syntax and
stuff we divided up the whole course into 19 lessons, each of which was worked
at mostly independent. That had two big advantages (and was very positively
perceived): First, the amount of time, we needed to spend lecturing and doing
frontal presentations was minimized to about half an hour over all the course.
The saved time could be invested in individual tutoring. This enabled us to
react to every student needing help in a few seconds, using only about 3-4
senior students (with mostly pretty minimal background themselves actually) to
teach.</p>
<p>Second the students where able to just work in their own speed without external
pressure or a limit on the time spent on any lesson. Missing deadlines for
lessons meant more experimentation, less competition amongst the students, less
stress and less pressure to finish with all lessons in time. The course was not
designed to be finished, so even though many students didn&rsquo;t reach the last
lesson, I think the additional experimentation (combined with a less
content-driven curriculum) added much more value for the students.</p>
<p>The content also was rather different from what you usually read in tutorials or
get in lectures at the university. Instead of systematically developing syntax
and different language constructs, we used the language less then the object to
learn, but the mean to learn basic skills needed, when tackling a programming
lecture (basically: „How do I start“ and „what can I do, if it doesn&rsquo;t work?“).
We introduced every lesson with about a page of text, describing the key
constructs underlying the object of that lesson, gave some basic code-examples
and (without explaining the details of the syntax) then presented some basic
exercises, which could be mastered without much understanding of what was
happening, but which ensured the reproduction needed, to properly learn the
syntactic device or the idea. We then added some playfull, very open exercises,
where through experimentation and through their own mistakes the students where
supposed to discover themselves the more intricate details of the subject
matter. Thematically we restricted the syntax to the absolute minimum to get
some basic, but fun and usefull programms to work (for example, we introduced
only one kind of loop, and we introduced only the datatypes int, bool,
std::string and double, as well as arrays thereof)</p>
<p>Though this all might sound fairly „new-agey“, it worked remarkably well. We saw
a fair amount of experimentation, we saw very creative solutions to seemingly
easy and straightforward, we got very positive feedback and though we introduced
many special subjects (for example debuggers, online references and detailed
lectures and exercises on how to read manpages or error output of the compiler),
I think it is fair to say, that we reached at least the level of proficiency and
confidence as the more traditional courses we held the last years had.</p>
<p>So, the bottomline is: We took a very huge bite out of the ideas and thoughts
underlying the ongoing effort in europe to modernize teaching at universities
(The „Bologna Process“, as it&rsquo;s known at least here in germany) and though I
totally agree, that the implementation of these guidelines at the universities
is currently pretty misguided and plain <em>bad</em>, I once again feel confirmed in my
view, that if you put some effort into it and really use what the underlying
ideas of bologna are (instead of just picking up, what you hear from the media
about it), you can create a really kick-ass curriculum, that is both more fun
<em>and</em> more informative at the same time.</p>
<p>All used content is on
<a href="https://github.com/FachschaftMathPhys/Infovorkurs">github</a>, if you are
interested in what exactly we used in the course.</p>
]]></content></entry></feed>