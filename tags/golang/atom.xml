<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-us"><generator uri="https://gohugo.io/" version="0.96.0">Hugo</generator><title type="html">in golang on Mero's Blog</title><link href="https://blog.merovius.de/tags/golang/"/><link type="application/atom+xml" rel="self" href="https://blog.merovius.de/tags/golang/atom.xml"/><updated>2022-04-06T09:26:25+00:00</updated><id>https://blog.merovius.de/tags/golang/</id><author><name>Axel Wagner</name></author><entry><title type="html">Parametric context</title><link href="https://blog.merovius.de/posts/2020-07-20-parametric-context/" rel="alternate" type="text/html"/><id>https://blog.merovius.de//2020/07/20/parametric-context.html</id><published>2020-07-20T00:00:00+00:00</published><updated>2020-07-20T00:00:00+00:00</updated><content type="html"><![CDATA[<p><strong>tl;dr: Go&rsquo;s Context.Value is controversial because of a lack of type-safety. I design a solution for that based on the new generics design draft.</strong></p>
<p>If you are following what&rsquo;s happening with Go, you are aware that recently
<a href="https://blog.golang.org/generics-next-step">an updated design draft for generics has dropped</a>.
What makes this particularly notable is that it comes with an actual prototype
implementation of the draft, including a <a href="https://go2goplay.golang.org/">playground</a>.
This means for the first time, people get to actually try out how a Go with
generics might feel, once they get in. It is a good opportunity to look at
common Go code lacking type-safety and evaluate if and how generics can help
address them.</p>
<p>One area I&rsquo;d like to look at here is <a href="https://godoc.org/context#Context.Value">Context.Value</a>. It is often criticized
for not being explicit enough about the dependencies a function has and some
people even go so far as to discourage its use altogether. On the other hand,
I&rsquo;m on record <a href="/posts/2017-08-14-why-context-value-matters-and-how-to-improve-it/">saying that it is too useful to ignore</a>. Generics
might be a way to bring together these viewpoints.</p>
<p>We want to be able to declare dependency on a functionality in
<code>context.Context</code> via a function&rsquo;s signature and make it impossible to call it
without providing that functionality, while also preserving the ability to pass
it through APIs that don&rsquo;t know anything about it. As an example of such
functionality, I will use logging. Let&rsquo;s start by creating a fictional little
library to do that (the names are not ideal, but let&rsquo;s not worry about that):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">logctx</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;context&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;log&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">LogContext</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// We embed a context.Context, to say that we are augmenting it with
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// additional functionality.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Logf logs the given values in the given format.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">Logf</span>(<span style="color:#a6e22e">format</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">values</span> <span style="color:#f92672">...</span><span style="color:#66d9ef">interface</span>{})
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">WithLog</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>, <span style="color:#a6e22e">l</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Logger</span>) <span style="color:#a6e22e">LogContext</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">logContext</span>{<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">l</span>}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// logContext is unexported, to ensure it can&#39;t be modified.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">logContext</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">l</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Logger</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">logContext</span>) <span style="color:#a6e22e">Logf</span>(<span style="color:#a6e22e">format</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">values</span> <span style="color:#f92672">...</span><span style="color:#66d9ef">interface</span>{}) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#a6e22e">format</span>, <span style="color:#a6e22e">values</span><span style="color:#f92672">...</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>You might notice that we are not actually using <code>Value()</code> here. This is
fundamental to the idea of getting compiler-checks - we need some
compiler-known way to &ldquo;tag&rdquo; functionality and that can&rsquo;t be <code>Value</code>. However,
we provide the same functionality, by essentially adding an <a href="/posts/2017-07-30-the-trouble-with-optional-interfaces/">optional
interface</a> to <code>context.Context</code>.</p>
<p>If we want to use this, we could write</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Foo</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">logctx</span>.<span style="color:#a6e22e">LogContext</span>, <span style="color:#a6e22e">v</span> <span style="color:#66d9ef">int</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">Logf</span>(<span style="color:#e6db74">&#34;Foo(%v)&#34;</span>, <span style="color:#a6e22e">v</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ctx</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">logctx</span>.<span style="color:#a6e22e">WithLog</span>(<span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Background</span>(), <span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">New</span>(<span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Stderr</span>, <span style="color:#e6db74">&#34;&#34;</span>, <span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">LstdFlags</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Foo</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#ae81ff">42</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>However, this has a huge problem: What if we want more than one functionality
(each not knowing about the other)? We might try the same trick, say</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">tracectx</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;context&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;github.com/opentracing/opentracing-go&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">TraceContext</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Tracer</span>() <span style="color:#a6e22e">opentracing</span>.<span style="color:#a6e22e">Tracer</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">WithTracer</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>, <span style="color:#a6e22e">t</span> <span style="color:#a6e22e">opentracing</span>.<span style="color:#a6e22e">Tracer</span>) <span style="color:#a6e22e">TraceContext</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">traceContext</span>{<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">t</span>}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">traceContext</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">t</span> <span style="color:#a6e22e">opentracing</span>.<span style="color:#a6e22e">Tracer</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">traceContext</span>) <span style="color:#a6e22e">Tracer</span>() <span style="color:#a6e22e">opentracing</span>.<span style="color:#a6e22e">Tracer</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">t</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>But because a <code>context.Context</code> is embedded, only those methods explicitly
mentioned in that interface are added to <code>traceContext</code>. The <code>Logf</code> method is
erased. After all, that is <a href="/posts/2017-07-30-the-trouble-with-optional-interfaces/">the trouble with optional interfaces</a>.</p>
<p>This is where generics come in. We can change our wrapper-types and -functions like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">LogContext</span>(<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">parent</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>) <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// the type-parameter is lower case, so the field is not exported.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">parent</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">l</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Logger</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">WithLog</span>(<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Parent</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>) (<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">Parent</span>, <span style="color:#a6e22e">l</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Logger</span>) <span style="color:#a6e22e">LogContext</span>(<span style="color:#a6e22e">Parent</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">LogContext</span>(<span style="color:#a6e22e">parent</span>){<span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">l</span>}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>By adding a type-parameter and embedding it, we actually get <em>all</em> methods of
the parent context on <code>LogContext</code>. We are no longer erasing them. After giving
the <code>tracectx</code> package the same treatment, we can use them like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// FooContext encapsulates all the dependencies of Foo in a context.Context.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">FooContext</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Logf</span>(<span style="color:#a6e22e">format</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">values</span> <span style="color:#f92672">...</span><span style="color:#66d9ef">interface</span>{})
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Tracer</span>() <span style="color:#a6e22e">opentracing</span>.<span style="color:#a6e22e">Tracer</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Foo</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">FooContext</span>, <span style="color:#a6e22e">v</span> <span style="color:#66d9ef">int</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">span</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">Tracer</span>().<span style="color:#a6e22e">StartSpan</span>(<span style="color:#e6db74">&#34;Foo&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">span</span>.<span style="color:#a6e22e">Finish</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">Logf</span>(<span style="color:#e6db74">&#34;Foo(%v)&#34;</span>, <span style="color:#a6e22e">v</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">l</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">New</span>(<span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Stderr</span>, <span style="color:#e6db74">&#34;&#34;</span>, <span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">LstdFlags</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">t</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">opentracing</span>.<span style="color:#a6e22e">GlobalTracer</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ctx has type TraceContext(LogContext(context.Context)),
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//    which embeds a LogContext(context.Context),
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//    which embeds a context.Context
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// So it has all the required methods
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">ctx</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">tracectx</span>.<span style="color:#a6e22e">WithTracer</span>(<span style="color:#a6e22e">logctx</span>.<span style="color:#a6e22e">WithLog</span>(<span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Background</span>(), <span style="color:#a6e22e">l</span>), <span style="color:#a6e22e">t</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Foo</span>(<span style="color:#a6e22e">ctx</span>, <span style="color:#ae81ff">42</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>Foo</code> has now fully declared its dependencies on a logger and a tracectx, without
requiring any type-assertions or runtime-checks. The logging- and
tracing-libraries don&rsquo;t know about each other and yet are able to wrap each
other without loss of type-information. Constructing the context is not
particularly ergonomic though. We require a long chained function call, because
the values returned by the functions have no longer a unified type
<code>context.Context</code> (so the <code>ctx</code> variable can&rsquo;t be re-used).</p>
<p>Another thing to note is that we exported <code>LogContext</code> as a struct, instead of
an interface. This is necessary, because we can&rsquo;t embed type-parameters into
interfaces, but we <em>can</em> embed them as struct-fields. So this is the only way
we can express that the returned type has all the methods the parameter type
has. The downside is that we are making this a concrete type, which isn&rsquo;t
always what we want<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>.</p>
<p>We have now succeeded in annotating <code>context.Context</code> with dependencies, but
this alone is not super useful of course. We also need to be able to pass it
through agnostic APIs (the fundamental problem <code>Context.Value</code> solves).
However, this is easy enough to do.</p>
<p>First, let&rsquo;s change the <code>context</code> API to use the same form of generic wrappers.
This isn&rsquo;t backwards compatible, of course, but this entire blog post is a
thought experiment, so we are ignoring that. I don&rsquo;t provide the full code
here, for brevity&rsquo;s sake, but the basic API would change into this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">context</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// CancelContext is the generic version of the currently unexported cancelCtx.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">CancelContext</span>(<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">parent</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>) <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">parent</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// other fields
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">WithCancel</span>(<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Parent</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>) (<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">Parent</span>) (<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">CancelContext</span>(<span style="color:#a6e22e">Parent</span>), <span style="color:#a6e22e">cancel</span> <span style="color:#a6e22e">CancelFunc</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>This change is necessary to enable <code>WithCancel</code> to also preserve methods of the
parent context. We can now use this in an API that passes through a parametric
context.  For example, say we want to have an <a href="https://godoc.org/golang.org/x/sync/errgroup">errgroup</a> package, that passes
the context through to the argument to <code>(*Group).Go</code>, instead of returning it
from <code>WithContext</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// Derived from the current errgroup code.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// A Group is a collection of goroutines working on subtasks that are part of the same overall task.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// A zero Group is invalid (as opposed to the original errgroup).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Group</span>(<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Context</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>) <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ctx</span>    <span style="color:#a6e22e">Context</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">cancel</span> <span style="color:#66d9ef">func</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">wg</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">WaitGroup</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">errOnce</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">Once</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">err</span>     <span style="color:#66d9ef">error</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">WithContext</span>(<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">C</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">Context</span>) (<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">C</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">Group</span>(<span style="color:#a6e22e">C</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">cancel</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">context</span>.<span style="color:#a6e22e">WithCancel</span>(<span style="color:#a6e22e">ctx</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Group</span>(<span style="color:#a6e22e">C</span>){<span style="color:#a6e22e">ctx</span>: <span style="color:#a6e22e">ctx</span>, <span style="color:#a6e22e">cancel</span>: <span style="color:#a6e22e">cancel</span>}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">g</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Group</span>(<span style="color:#a6e22e">Context</span>)) <span style="color:#a6e22e">Wait</span>() <span style="color:#66d9ef">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Wait</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">g</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Group</span>(<span style="color:#a6e22e">Context</span>)) <span style="color:#a6e22e">Go</span>(<span style="color:#a6e22e">f</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">Context</span>) <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Add</span>(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">wg</span>.<span style="color:#a6e22e">Done</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">ctx</span>); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">errOnce</span>.<span style="color:#a6e22e">Do</span>(<span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">g</span>.<span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>            })
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Note that the code here has barely changed. It can be used as</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Foo</span>(<span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">FooContext</span>) <span style="color:#66d9ef">error</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">span</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">Tracer</span>().<span style="color:#a6e22e">StartSpan</span>(<span style="color:#e6db74">&#34;Foo&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">span</span>.<span style="color:#a6e22e">Finish</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">ctx</span>.<span style="color:#a6e22e">Logf</span>(<span style="color:#e6db74">&#34;Foo was called&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">ctx</span> <span style="color:#a6e22e">FooContext</span> = <span style="color:#a6e22e">newFooContext</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">eg</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">errgroup</span>.<span style="color:#a6e22e">WithContext</span>(<span style="color:#a6e22e">ctx</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">20</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">eg</span>.<span style="color:#a6e22e">Go</span>(<span style="color:#a6e22e">Foo</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">eg</span>.<span style="color:#a6e22e">Wait</span>(); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Fatal</span>(<span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>After playing around with this for a couple of days, I feel pretty confident
that these patterns make it possible to get a fully type-safe version of
<code>context.Context</code>, while preserving the ability to have APIs that pass it
through untouched or augmented.</p>
<p>A completely different question, of course, is whether all of this is a good
idea. Personally, I am on the fence about it. It is definitely valuable, to
have a type-safe version of <code>context.Context</code>. And I think it is impressive how
small the impact of it is on the <em>users</em> of APIs written this way. The
type-argument can almost always be inferred and writing code to make use of this
is very natural - you just declare a suitable context-interface and take it as
an argument. You can also freely pass it to functions taking a pure
<code>context.Context</code> unimpeded.</p>
<p>On the other hand, I am not completely convinced the cost is worth it. As soon
as you do non-trivial things with a context, it becomes a pretty &ldquo;infectious&rdquo;
change. For example, I played around with a <a href="https://go2goplay.golang.org/p/9-xQZufcGp_k">mock gRPC API</a> to allow
interceptors to take a parametric context and it requires almost all types and
functions involved to take a type-parameter. And this doesn&rsquo;t even touch on the
fact that gRPC itself might want to add annotations to the context, which adds
even more types. I am not sure if the additional machinery is really worth the
benefit of some type-safety - especially as it&rsquo;s not always super intuitive and
easily understandable. And even more so, if it needs to be combined with other
type-parameters, to achieve other goals.</p>
<p>I think this is an example of what I tend to dislike about generics and powerful
type-systems in general. They tempt you to write a lot of extra machinery and
types in a way that isn&rsquo;t necessarily semantically meaningful, but only used to
encode some invariant in a way the compiler understands.</p>
<hr>
<p>I don&rsquo;t actually think there is much of a performance problem with
<code>context.Value</code> in practice, but if there is, this could solve that.</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>One <em>upside</em> however, is that this could actually address
the <em>other</em> criticism of <code>context.Value</code>: Its performance. If we consequently embed the
parent-context as values in struct fields, the final context will be a flat
struct. The interface-table of all the extra methods we add will point at the
concrete implementations. There&rsquo;s no longer any need for a linear search to
find a context value.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
]]></content></entry><entry><title type="html">A bird's eye view of Go</title><link href="https://blog.merovius.de/posts/2019-06-12-birdseye-go/" rel="alternate" type="text/html"/><id>https://blog.merovius.de//2019/06/12/birdseye-go.html</id><published>2019-06-12T00:00:00+00:00</published><updated>2019-06-12T00:00:00+00:00</updated><content type="html"><![CDATA[<p><strong>tl;dr: I provide a very high-level overview of what Go-the-language means vs. Go-the-ecosystem vs. Go-an-implementation. I also try to provide specific references to what documentation is most useful for what purpose. See the bottom-most section for that.</strong></p>
<p>When we talk about &ldquo;Go&rdquo;, depending on context, we can mean very different
things. This is my attempt at providing a very high-level overview of the
language and ecosystem and to link to the relevant documentation about how each
part fits together (it&rsquo;s also a bit of a hodgepodge though, addressing
individual random questions I encountered recently). So, let&rsquo;s dive in:</p>
<h2 id="the-go-programming-language">The Go programming language</h2>
<p>The bottom turtle is Go, the programming language. It defines the format and
meaning of source code and the authoritative source is
<a href="https://golang.org/ref/spec">the Go language specification</a>. If something
doesn&rsquo;t conform to the spec, it&rsquo;s not &ldquo;Go&rdquo;. And conversely, if something
<em>isn&rsquo;t</em> mentioned in the spec it&rsquo;s not part of the language. The language spec
is maintained by the Go team and versioned, with a new release roughly every
six months. At the time I wrote this post, the newest release was version
<code>1.12</code>.</p>
<p>The domain of the spec are</p>
<ul>
<li>The grammar of the language</li>
<li>Types, values and their semantics</li>
<li>What identifiers are predeclared and what their meaning is</li>
<li>How Go programs get executed</li>
<li>The special package <a href="https://golang.org/ref/spec#Package_unsafe">unsafe</a>
(though not all of its semantics)</li>
</ul>
<p>The spec alone <em>should</em> enable you to write a compiler for Go. And indeed,
there are many different compilers.</p>
<h2 id="a-go-compiler-and-runtime">A Go compiler and runtime</h2>
<p>The language spec is a text document, which is not useful in and of itself.
For that you need software that actually implements these semantics. This is
done by a compiler (which analyzes and checks the source code and
transforms it into an executable format) and a runtime (which provides the
necessary environment to actually run the code). There are many such
combinations and they all differ a bit more or a bit less. Examples are</p>
<ul>
<li><code>gc</code>, a compiler and runtime written in pure Go (with some assembly) by the
Go team themselves and versioned and released together with the language.
Unlike other such tools, <code>gc</code> doesn&rsquo;t <em>strictly</em> separate the compiler,
assembler and linker - they end up sharing a lot of code and some of the
classical responsibilities move or are shared between them. As such, it&rsquo;s in
general not possible to e.g. link packages compiled by different versions of
<code>gc</code>.</li>
<li><a href="https://golang.org/doc/install/gccgo">gccgo and libgo</a>, a frontend for gcc
and a runtime. It&rsquo;s written in C and maintained by the Go team. It lives in
the gcc organization though and is released according to the gcc release
schedule and thus often lags a bit behind the &ldquo;latest&rdquo; version of the Go
spec.</li>
<li><a href="https://llvm.org/svn/llvm-project/llgo/trunk/README.TXT">llgo</a>, a frontend
for LLVM. I don&rsquo;t know much else about it.</li>
<li><a href="https://github.com/gopherjs/gopherjs">gopherjs</a>, compiling Go code into
javascript and using a javascript VM plus some custom code as a runtime.
Long-term, it&rsquo;ll probably be made obsolete by <code>gc</code> gaining native support for
WebAssembly.</li>
<li><a href="https://tinygo.org/">tinygo</a>, an incomplete implementation targeting small
code size. Runs on either bare-metal micro-controllers or WebAssembly VMs,
with a custom runtime. Due to its limitations it doesn&rsquo;t <em>technically</em>
implement Go - notably, it doesn&rsquo;t include a garbage collector, concurrency
or reflection.</li>
</ul>
<p>There are more, but this gives you an overview over the variety
of implementations. Each of these made potentially different choices
for how to implement the language and have their own idiosyncrasies.
Examples (some of them a bit exotic, to illustrate) where they might differ are:</p>
<ul>
<li>Size of <code>int</code>/<code>uint</code> - the language allows them to be either 32 or 64 bit wide.</li>
<li>How fundamental functionalities of the runtime, like allocation, garbage
collection or concurrency are implemented.</li>
<li>The order of ranging over a <code>map</code> isn&rsquo;t defined in the language - <code>gc</code>
famously explicitly randomizes it, <code>gopherjs</code> uses (last time I checked)
whatever the javascript implementation you are running on uses.</li>
<li>How much extra space <code>append</code> allocates if it needs to - <em>not</em> however,
<em>when</em> it allocates extra space.</li>
<li>How conversions between <code>unsafe.Pointer</code> and <code>uintptr</code> happen. <code>gc</code>, in
particular, comes with its own <a href="https://godoc.org/unsafe#Pointer">set of rules</a>
regarding when these conversions are valid and when they aren&rsquo;t. In general,
the <code>unsafe</code> package is virtual and implemented in the compiler.</li>
</ul>
<p>In general, relying on details not mentioned in the spec (in particular the
ones mentioned here) makes your program <em>compile</em> with different compilers, but
not <em>work</em> as expected. So you should avoid it if possible.</p>
<p>If you install Go via a &ldquo;normal&rdquo; way (by downloading it from the website, or
installing it via a package manager), you&rsquo;ll get <code>gc</code> and the official
runtime by the Go team. And if the context doesn&rsquo;t imply otherwise, when
we talk about how &ldquo;Go does things&rdquo;, we usually refer to <code>gc</code>. It&rsquo;s the main
implementation.</p>
<h2 id="the-standard-library">The standard library</h2>
<p><a href="https://golang.org/pkg/#stdlib">The standard library</a> is a set of packages
that come with Go and can be relied upon to immediately build useful
applications with. It too is maintained by the Go team and versioned and
released together with the language and compiler. In general the standard
library of one implementation will only work with the compiler it comes with.
The reason is that most (but not all) of the runtime is part of the standard
library (mainly in the packages <code>runtime</code>, <code>reflect</code>, <code>syscall</code>). As the
compiler needs to generate code compatible with the used runtime, both need to
come from the same version.  The <em>API</em> of the standard library is stable and
won&rsquo;t change in incompatible ways, so a Go program written against a given
version of the standard library will continue to work as expected with future
versions of the compiler.</p>
<p>Some implementations use their own version of some or all of the standard
library - in particular, the <code>runtime</code>, <code>reflect</code>, <code>unsafe</code> and <code>syscall</code>
packages are completely implementation-defined. As an example, I believe that
<a href="https://cloud.google.com/appengine/docs/standard/go/">AppEngine Standard</a> used
to re-define parts of the standard library for security and safety. In general,
implementations try to make that transparent to the user.</p>
<p>There is also a <a href="https://golang.org/pkg/#subrepo">separate set of repositories</a>,
colloquially referred to as <code>x</code> or &ldquo;the subrepositories&rdquo;. They contain packages
which are developed and maintained by the Go team with all the same processes,
but are <em>not</em> on the same release schedule as the language and have less strict
compatibility guarantees (and commitment to maintainership) than <a href="https://golang.org/doc/go1compat">Go itself</a>.
The packages in there are either experimental (for potential future inclusion
in the standard library), not widely useful enough to be included in the
standard library or, in rare cases, a way for people on the Go team to work on
code using the same review processes they are used to.</p>
<p>Again, when referring to &ldquo;the standard library&rdquo; devoid of extra context, we
mean the officially maintained and distributed one, hosted on
<a href="https://golang.org/pkg">golang.org</a>.</p>
<h2 id="the-build-tool">The build tool</h2>
<p>To make the language user-friendly, you need a build tool. The primary role of
this tool is to find the package you want to compile, find all of its
dependencies, and execute the compiler and linker with the arguments necessary
to build them. Go (the language) has <a href="https://golang.org/ref/spec#Packages">support for packages</a>,
which combine multiple source files into one unit of compilation. And it
defines how to import and use other packages. But importantly, it doesn&rsquo;t
define how import paths map to source files or how they are laid out on disk.
As such, each build tool comes with its own ideas for this. It&rsquo;s possible to
use a generic build tool (like Make) for this purpose, but there are a bunch of
Go-specific ones:</p>
<ul>
<li><a href="https://golang.org/cmd/go/">The go tool</a><sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup> is the build tool officially maintained
by the Go team. It is versioned and released with the language (and
<code>gc</code> and the standard library). It expects a directory called <code>GOROOT</code> (from
an environment variable, with a compiled default) to contain the compiler,
the standard library and various other tools. And it expects all source code
in a single directory called <code>GOPATH</code> (from an environment variable,
defaulting to <code>$HOME/go</code> or equivalent). Specifically, package <code>a/b</code> is
expected to have its source at <code>$GOPATH/src/a/b/c.go</code> etc. And
<code>$GOPATH/src/a/b</code> is expected to <em>only</em> contain source files of one package.
It also has a mechanism to
<a href="https://golang.org/cmd/go/#hdr-Remote_import_paths">download a package and its dependencies recursively from an arbitrary server</a>,
in a fully decentralized scheme, though it does not support versioning or
verification of downloads. The go tool also contains extra tooling for
testing Go code, reading documentation (<a href="https://golang.org">golang.org</a> is
served by the Go tool), file bugs, run various tools…</li>
<li><a href="https://github.com/gopherjs/gopherjs">gopherjs</a> comes with its own build
tool, that largely mimics the Go tool.</li>
<li><a href="https://github.com/golang/go/wiki/Mobile">gomobile</a> is a build tool
specifically to build Go code for mobile operating systems.</li>
<li><a href="https://github.com/golang/dep">dep</a>, <a href="https://getgb.io/">gb</a>,
<a href="https://glide.sh/">glide</a>,… are community-developed build-tools and
dependency managers, each with their own approach to file layout (some are
compatible with the go tool, some aren&rsquo;t) and dependency declarations.</li>
<li><a href="https://bazel.build/">bazel</a> is the open source version of Google&rsquo;s own
build system. While it&rsquo;s not actually Go-specific, I&rsquo;m mentioning it
explicitly due to common claims that idiosyncrasies of the go tool are
intended to serve Google&rsquo;s own use cases, in conflict with the needs of the
community. However, the go tool (and many public tools) can&rsquo;t be used at
Google, because bazel uses an incompatible file layout.</li>
</ul>
<p>The build tool is what most users directly interface with and as such, it&rsquo;s
what largely determines aspects of the <em>Go ecosystem</em> and how packages can be
combined and thus how different Go programmers interact. As above, the go tool
is what&rsquo;s implicitly referred to (unless other context is specified) and thus its
design decisions significantly influence public opinion about &ldquo;Go&rdquo;. While there
are alternative tools and they have wide adoption for use cases like
company-internal code, the open source community <em>in general</em> expects code to
conform to the expectations of the go tool, which (among other things) means:</p>
<ul>
<li>Be available as source code. The go tool has little support for binary
distribution of packages, and what little it has is going to be removed soon.</li>
<li>Be documented according to <a href="https://blog.golang.org/godoc-documenting-go-code">the godoc format</a>.</li>
<li><a href="https://golang.org/pkg/testing/#pkg-overview">Have tests</a> that can be run via <code>go test</code>.</li>
<li>Be fully compilable by a <code>go build</code> (together with the next one, this is
usually called being &ldquo;go-gettable&rdquo;). In particular, to use <a href="https://golang.org/pkg/cmd/go/internal/generate/">go generate</a>
if generating source-code or metaprogramming is required and commit the generated
artifacts.</li>
<li>Namespace import paths with a domain-name as the first component and have
that domain-name either be a well-known code hoster or have a webserver
running on it, so that <a href="https://golang.org/cmd/go/#hdr-Remote_import_paths">go get works</a>
and can find the source code of dependencies.</li>
<li>Have one package per directory and use <a href="https://golang.org/pkg/go/build/#hdr-Build_Constraints">build constraints</a>
for conditional compilation.</li>
</ul>
<p>The <a href="https://golang.org/cmd/go">documentation of the go tool</a> is very
comprehensive and probably a good starting point to learn how Go implements
various ecosystem aspects.</p>
<h2 id="tools">Tools</h2>
<p>Go&rsquo;s standard library includes <a href="https://golang.org/pkg/go/">several packages to interact with Go source code</a>
and the <a href="https://godoc.org/golang.org/x/tools/go">x/tools subrepo contains even more</a>.
As a result (and due to a strong desire to keep the canonical Go distribution
lean), Go has developed a strong culture of developing third-party tools. In
general, these tools need to know where to find source code, and might
need access to type information. The <a href="https://golang.org/pkg/go/build/">go/build</a>
package implements the conventions used by the Go tool, and can thus also serve
as documentation for parts of its build process. The downside is that tools
built on top of it sometimes don&rsquo;t work with code relying on other build tools.
That&rsquo;s why there is a <a href="https://godoc.org/golang.org/x/tools/go/packages">new package in development</a>
which integrates nicely with other build tools.</p>
<p>By its nature the list of Go tools is long and everybody has their own
preferences. But broadly, they contain:</p>
<ul>
<li><a href="https://golang.org/cmd/">Tools developed by the Go team and released as part of the distribution</a>.</li>
<li>This includes tools for <a href="https://golang.org/cmd/gofmt/">automatically formatting source code</a>,
<a href="https://golang.org/cmd/cover/">coverage testing</a>,
<a href="https://golang.org/cmd/trace/">runtime tracing</a> and
<a href="https://golang.org/cmd/pprof/">profiling</a>, a <a href="https://golang.org/cmd/vet/">static analyzer for common mistakes</a>
and <a href="https://golang.org/cmd/fix/">a mostly obsolete tool to migrate code to new Go versions</a>.
These are generally accesed via <code>go tool &lt;cmd&gt;</code>.</li>
<li><a href="https://godoc.org/golang.org/x/tools/cmd">Tools developed by the Go team and maintained out-of-tree</a>.
This includes tools to
<a href="https://godoc.org/golang.org/x/tools/cmd/present">write blog posts and presentations</a>,
<a href="https://godoc.org/golang.org/x/tools/cmd/eg">easily do large refactors</a>,
<a href="https://godoc.org/golang.org/x/tools/cmd/goimports">automatically find and fix import paths</a>
and a <a href="https://godoc.org/golang.org/x/tools/cmd/gopls">language server</a>.</li>
<li>Third-party tools - too many to count. There are many lists of these;
<a href="https://github.com/avelino/awesome-go#tools">here is one</a>.</li>
</ul>
<h2 id="in-summary">In Summary</h2>
<p>I wanted to end this with a short list of references for beginners who feel lost.
So this is where you should go, if you:</p>
<ul>
<li><a href="https://tour.golang.org/welcome/1">Want to start learning Go</a>.</li>
<li><a href="https://golang.org/doc/effective_go.html">Want to understand how a specific language construct works</a>.</li>
<li><a href="https://golang.org/ref/spec">Want to nitpick what is or is not valid Go and why</a>.</li>
<li><a href="https://golang.org/cmd/go/">Want documentation about what the go tool does</a>
Also available via <code>go help</code>. It sometimes references other topics, that you can also
<a href="https://golang.org/pkg/cmd/go/internal/help/">see on the web</a>, but not nicely.</li>
<li><a href="https://github.com/golang/go/wiki/CodeReviewComments">Want to write code that adheres to community standards</a>.</li>
<li><a href="https://golang.org/pkg/testing/#pkg-overview">Want to test your code</a>.</li>
<li><a href="https://godoc.org/">Want to find new packages or look at documentation of public packages</a>.</li>
</ul>
<p>There are many more useful supplementary documents, but this should serve as a good start.
Please <a href="https://twitter.com/TheMerovius">let me know on Twitter</a>
if you are a beginner and there&rsquo;s an area of Go you are missing from this
overview (I might follow this up with more specific topics), or a specific
reference you found helpful. You can also drop me a note if you&rsquo;re a more
experienced Gopher and think I missed something important (but keep in mind
that I intentionally left out most references, so as to keep the ways
forward crisp and clear :) ).</p>
<hr>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>The Go team is currently rolling out support for <em>modules</em>, which is
a unit of code distribution above packages, including support for versioning
and more infrastructure to solve some issues with the &ldquo;traditional&rdquo; go
tool. With that, basically everything in that paragraph becomes obsolete.
However, <em>for now</em> the module support exists but is opt-in. And as the
point of this article is to provide an overview of the separation of
concerns, which doesn&rsquo;t actually change, I felt it was better to stay
within ye olden days - <em>for now</em>.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
]]></content></entry><entry><title type="html">Using roughtime as a "cryptographic notary"</title><link href="https://blog.merovius.de/posts/2018-10-10-using-roughtime-as-a-cryptographic-notary/" rel="alternate" type="text/html"/><id>https://blog.merovius.de//2018/10/18/using-roughtime-as-a-cryptographic-notary.html</id><published>2018-10-10T23:22:40+00:00</published><updated>2018-10-10T23:22:40+00:00</updated><content type="html"><![CDATA[<p><strong>tl;dr: Roughtime can be (ab)used for <a href="https://en.wikipedia.org/wiki/Trusted_timestamping#Trusted_(digital)_timestamping">Trusted Timestamping</a>. I wrote a
<a href="https://github.com/Merovius/notary">simple tool</a> as a PoC</strong></p>
<p>Recently, <a href="https://blog.cloudflare.com/roughtime/">Cloudflare announced</a> that they are now running a
<a href="https://roughtime.googlesource.com/roughtime/">roughtime</a> server. Roughtime is a cryptographically secured
time-synchronization protocol - think NTP with signatures. For an actual
description of how it works, I recommend reading the Cloudflare blog post. But
at it&rsquo;s very core (oversimplification ahead), the user chooses an arbitrary
(usually randomly generated) nonce and the server signs it, plus the current
time.</p>
<p>One thing roughtime adds on top of this, is the ability to build a chain of
requests. This is achieved by taking a hash of a response, combining it with a
randomly generated &ldquo;blind&rdquo; and using the combined hash as a nonce to the next
request. The intended use-case of this is that if a server provides the wrong
time or otherwise misbehaves, you can obtain cryptographic proof of that fact
by getting a timestamped signature of its response from a different server. By
storing the initial nonce, generated blinds and responses, the entire chain can
be validated later.</p>
<p>When I saw Cloudflares announcement, my first thought was that it should be
possible to use a roughtime server as a <a href="https://en.wikipedia.org/wiki/Trusted_timestamping#Trusted_(digital)_timestamping">Time Stamping Authority</a>. The
goal is, to obtain a cryptographic proof, that you owned a particular document
at the current point in time - for example to ensure you can proof original
authorship without publishing the document itself.</p>
<p>The simplest way to achieve this using roughtime is to use the SHA512 hash of
the file as an initial nonce. That way, the roughtime server signs that hash
together with the current time with their private key. By using the roughtime
chain protocol, you can get that proof corroborated by multiple servers.</p>
<p>You can also think of extending this, to get stronger properties. Using the
hash of the file as a nonce only proves that the file existed <em>before</em> that
specific point in time. It also doesn&rsquo;t actually prove that you had the file,
but only the hash. This can be remediated though. If we run a regular roughtime
request, the resulting response is unpredictable (to us) and signs the current
time. Thus, if we use a hash of that response as a prefix &ldquo;salt&rdquo; of the file
itself, the resulting hash proofs that we knew the file <em>after</em> that chain
ran. We can then use that hash as a nonce for another roughtime chain and get a
proof that we had the file at a specific point (or rather, a small interval) in
time. Furthermore, we can opt to use the file-hash not as the nonce itself, but
as a blind. The advantage is, that the blind is never transmitted over the
network, so the actual proof is only available to us (if we use it as a nonce,
an eavesdropper could intercept the proof). I illustrated these options in a
<a href="https://docs.google.com/presentation/d/1quTJfXHvBZCjKJgL6HjUFb_jhDF-PghBwm_lTFLAjdg/edit#slide=id.g43c753f2a5_1_542">recent talk</a> I gave on the subject.</p>
<p>These ideas are mostly academic. I&rsquo;m not sure how useful these properties are
in practice. Nevertheless, the idea intriguiged me enough to <a href="https://github.com/Merovius/notary">implement it</a>
in a simple tool. It&rsquo;s in a pretty rough, proof-of-concept like shape and I
don&rsquo;t know if I will ever progress it from there. It also comes with a client
implementation of the roughtime protocol in Go - initially I was not aware that
there already was a Go implementation, but that also is not go-gettable. Either
way, it was fun to implement it myself :)</p>
]]></content></entry><entry><title type="html">Scrapping contracts</title><link href="https://blog.merovius.de/posts/2018-09-05-scrapping_contracts/" rel="alternate" type="text/html"/><id>https://blog.merovius.de//2018/09/05/scrapping_contracts.html</id><published>2018-09-05T04:00:00+00:00</published><updated>2018-09-05T04:00:00+00:00</updated><content type="html"><![CDATA[<p><strong>tl;dr: I describe a way to simplify the generics design. The ideas are not
particularly novel and have been expressed to various degrees by other people
as well. I hope to provide a more complete view of the design though.</strong></p>
<p>Recently a <a href="https://go.googlesource.com/proposal/+/master/design/go2draft-generics-overview.md">Problem Overview</a>
and <a href="https://go.googlesource.com/proposal/+/master/design/go2draft-contracts.md">Draft Design</a>
for generics in Go have dropped. Since then, predictably,
there has been a bunch of chatter on the intertubez about it. This is a
summary of my thoughts, so far, on the subject - after a bunch of discussions
on Twitter and Reddit.</p>
<p>Note: The design is called &ldquo;Contracts&rdquo;, but I will refer to it as &ldquo;the design
doc&rdquo; here.  When I say &ldquo;contracts&rdquo;, I will refer to the specific part of the
design to express constraints.</p>
<h2 id="contracts-vs-interfaces">Contracts vs. Interfaces</h2>
<p>First, there is a common observation of overlap between generics and interfaces.
To untangle that, we can say that when we use &ldquo;generics&rdquo;, what we mean is
<em>constrained parametric polymorphism</em>. Go already allows polymorphism by using
interfaces. This desgn doc adds two things: One, a way to add <em>type-parameters</em> to
functions and types. And two, a syntax to constrain those type-parameters to a
subset that allows specific operations, via <em>contracts</em>.</p>
<p>The latter is where the overlap lies: Interfaces <em>already</em> allow you to
constrain arguments to types that allow certain operations. In a way, what
contracts add to this, is that those operations can not only be method calls,
but also allow (and constrain) builtin operators and functions to be used and
to allow or disallow certain composite types (though that mainly affects <code>map</code>).</p>
<p>Contracts allow that by the way they are specified: You write a function body
(including arguments, whose notational type becomes the type-variable of the
contract) containing all the statements/expressions you wish to be able
to do. When instantiating a generic type/function with a given set of
type-arguments, the compiler will try to substitute the corresponding
type-variable in the contract body and allow the instantiation, if that body
type-checks.</p>
<h2 id="the-cost-of-contracts">The cost of contracts</h2>
<p>After talking a bit through some examples, I feel that contracts optimize for
the wrong thing. The analogy I came up with is vocabulary vs. grammar.</p>
<p>The contracts design is appealing to a good degree, because it uses familiar
<em>syntax</em>: You don&rsquo;t have to learn any new syntax or language to express your
contract. Just write natural Go code and have that express your constraints for
you. I call this the &ldquo;grammar&rdquo; of constraints: The structure that you use to
input them.</p>
<p>On the other hand, for the <em>user</em> of Go, the relevant question is what
constraints are possible to express and how to express them. They might be
interested in deduplicating values in their algorithm, which requires
equality-operations. Or they might want to do comparisons (e.g. <code>Max</code>), which
requires <code>&gt;</code>. I call this the <em>vocabulary</em>: What is the correct way to express
the set of constraints that my algorithm needs?</p>
<p>The issue now, is that while the grammar of constraints might be obvious, it is
not always clear what the actual semantic constraints that generates <em>are</em>. A
simple example is map-keys. The design doc uses the contract</p>
<pre tabindex="0"><code>contract comparable (t T) {
   t == t
}
</code></pre><p>to specify types that are valid map-keyes. But to a beginner, it is not
immediately obvious, what comparisons have to do with maps. An alternative
would be</p>
<pre tabindex="0"><code>contract mapkey (t T) {
  var _ map[t]bool
}
</code></pre><p>But which is better? Similarly, these two contracts</p>
<pre tabindex="0"><code>contract mult (t T) {
  t = t * t
}

contract add (t T) {
  t = t + t
}
</code></pre><p>seem very similar, but they are, in theory at least, fundamentally different.
Not only because <code>add</code> allows <code>string</code>, while <code>mult</code> doesn&rsquo;t. But also, because
<em>technically</em> any type that supports <code>*</code> also supports <code>-</code> and <code>/</code>. And then there&rsquo;s</p>
<pre tabindex="0"><code>contract div (t T) {
  t = t % t
}
</code></pre><p>which creates another completely different set of types and allowed operators.</p>
<p>A third example is</p>
<pre tabindex="0"><code>contract stringlike (t T) {
  append([]byte(nil), t...)
}
</code></pre><p>This allows any type with underlying type <code>string</code> or <code>[]byte</code>, but nothing
else. And again, technically that would imply allowing index-operations and
<code>len</code>. But does the compiler understand that?</p>
<p>Lastly, it&rsquo;s not really clear how <code>len</code>, <code>cap</code>, <code>make</code> or <code>range</code> would work.
For example, all these contracts are superficially valid:</p>
<pre tabindex="0"><code>contract rangeable (t T) {
  for x := range t {
    fmt.Println(x)
  }
}

contract lengthed (t T) {
  var _ int = len(t)
}

contract capped (t T) {
  var _ int = cap(t)
}

contract makeable (t T) {
  t = make(T)
}

contract makeable2 (t T) {
  t = make(T, 0)
}
</code></pre><p>But in all these cases, they allow some subset of channel, map, slice and array
types, with vastly different interpretations of these operations, depending on
the kind of type used - to the degree, that code using them would usually be
nonsensical. Disallowing these, however, opens questions about the claim of
familiar Go syntax, as we now have to make decisions what sort of expressions
and statements we do or don&rsquo;t allow in a contract.</p>
<p>This is why I say contracts optimize for grammar, instead of vocabulary. The
programmer is interested in the vocabulary - what does the contract actually
<em>mean</em> and what contract should they use? But the vocabulary is obscured by the
grammar - because we use Go syntax, to understand a given contract we need to
know a bunch of things about what the compiler is and is not able to infer from
it.</p>
<p>This is why I don&rsquo;t really buy the argument of not wanting to learn a bunch of
new syntax or new identifiers for constraints: You <em>still</em> have to learn that
vocabulary, but you express it in an obscure and unnatural grammar. I hope to
show that we can introduce the power of generics while also using familiar
grammar and with minimal addition of vocabulary.</p>
<h2 id="scrapping-contracts">Scrapping contracts</h2>
<p>Now, I&rsquo;m not the first person to suggest this, but I think we should consider
scrapping contracts from the design. We can still retain type-parameters and we
can still have constraints, but we express them via interfaces instead. I
should point out, that - for now - I&rsquo;m intentionally optimizing for simplicity
of the design, at the cost of some boilerplate and some loss of power. I will
later try and provide some alternatives to compensate for that in part. But
there is still likely going to remain a net cost in expressiveness. Personally,
I think that tradeoff is worth exploring.</p>
<p>The new design would retain type-parameters and most of their syntax. The
difference is that type-parameters are a full argument list. The type of an
argument has to be an interface type. It can be ellided, in which case it
defaults to the type of the following type-parameter. The last type-parameter
defaults to <code>interface{}</code>. As a bonus, this allows providing multiple sets of
constraints on one declaration:</p>
<pre tabindex="0"><code>func Map(type A, B) (s []A, f func(A) B) []B {
  var out []B
  for _, a := range s {
    out = f(a)
  }
  return out
}

func Stringify(type A fmt.Stringer) (s []A) []string {
  // Because of the signature of fmt.Stringer.String, we can infer all the
  // type-arguments here. Note that A does not *have* to be passed boxed in an
  // interface. A.String is still a valid method-expression for any fmt.Stringer.
  return Map(s, A.String)
}
</code></pre><p>We still want to be able to express multiple, interdependent parameters, which
we can, via parametric interfaces:</p>
<pre tabindex="0"><code>type Graph(type Node, Edge) interface {
  Nodes(Edge) []Node
  Edges(Node) []Edge
}

func ShortestPath(type Node, Edge) (g Graph(Node, Edge), from, to Node) []Edge {
  // …
}

// Undirected Graph as an adjacency list. This could be further parameterized,
// to allow for user-defined paylooads.
type AdjacencyList [][]int

func (g AdjacencyList) Nodes(edge [2]int) []int {
  return edge[:]
}

func (g AdjacencyList) Edges(node int) [][2]int {
  var out [][2]int
  for _, v := range g[node] {
    out = append(out, [2]int{node, v}
    if v != node {
      out = append(out, [2]int{v, node})
    }
  }
  return out
}

func main() {
  g := AdjacencyList{…}
  // Types could be infered here, as the names of methods are unique, so we can
  // look at the methods Nodes and Edges of AdjacencyList to infer the
  // type-arguments.
  path := ShortestPath(g, 0, len(g)-1)
  fmt.Println(path)
}
</code></pre><p>The last example is relevant to the difference in power between contracts and
interfaces: Usage of operators. We can still express the concept, but this is
where the increased boilerplate comes in:</p>
<pre tabindex="0"><code>func Max(type T)(a, b T, less func(T, T) bool) T {
  if less(a, b) {
    return b
  }
  return a
}

func main() {
  fmt.Println(Max(a, b int, func(a, b int) { return a &lt; b }))
}
</code></pre><p>I will try to show some ways to get rid of that boilerplate later. For now,
let&rsquo;s just treat it as a necessary evil of this idea. Though it should be
mentioned, that while this is more <em>cumbersome</em>, it&rsquo;s still just as <em>typesafe</em>
as contracts (as opposed to, say, a reflect-based generic <code>Max</code>).</p>
<p>So, scrapping contracts leaves us with more boilerplate, but just the same set
of concepts we can express - though we do have to pass in any builtin
operations we want to perform as extra functions (or express them in an
interface). In exchange, we get</p>
<ul>
<li>Only one way to specify constraints.</li>
<li>A simpler spec (we don&rsquo;t need to add a new concept, contracts, to the
language) and a saved (pseudo-)keyword.</li>
<li>A simpler compiler: We don&rsquo;t need to add a solver to deduce constraints from
a given contract. The constraint-checker already exists.</li>
<li>Still a well-known, though less powerfull, language to express constraints,
with interfaces.</li>
<li>Simple syntax (same as normal arglists) for having multiple sets of
constraints in one declaration.</li>
<li>Trivially good error messages. Types passed in need only be checked for
consistency and interface satisfaction - the latter is already implemented,
including good error messages.</li>
</ul>
<h2 id="getting-rid-of-boilerplate">Getting rid of boilerplate</h2>
<p>I see two main ways to get rid of boilerplate: Adding methods to builtin types,
or what I call pseudo-interfaces.</p>
<h3 id="methods-on-builtin-types">Methods on builtin types</h3>
<p>An obvious idea is to not use operators in generic code, but instead use
method-call syntax. That is, we&rsquo;d do something akin to</p>
<pre tabindex="0"><code>func Max(type T Ordered) (a, b T) T {
  if a.Less(b) {
    return b
  }
  return a
}
</code></pre><p>To actually reduce the boilerplate, we&rsquo;d predefine methods for all the
operators on the builtin types. That would allow us to call <code>Max</code> with <code>int</code>,
for example.</p>
<p>Unfortunately, I can see a bunch of roadblocks to make this work. Methods are
not promoted to derived types, so you couldn&rsquo;t use <code>Max</code> with e.g.
<code>time.Duration</code>, which has <em>underlying</em> type <code>int64</code>, but is not the same type.
We&rsquo;d probably want those methods to be &ldquo;special&rdquo; in that they automatically get
promoted to any type whose underlying type is predeclared. That introduces
compatibility issues of clashing Method/Field names.</p>
<p>At the end, to express that <code>Less</code> has to take the same argument as the
receiver type, <code>Ordered</code> might look something like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Ordered</span>(<span style="color:#a6e22e">T</span>) <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Less</span>(<span style="color:#a6e22e">T</span>) <span style="color:#66d9ef">bool</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Max</span>(<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">T</span> <span style="color:#a6e22e">Ordered</span>(<span style="color:#a6e22e">T</span>)) (<span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">b</span> <span style="color:#a6e22e">T</span>) <span style="color:#a6e22e">T</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">Less</span>(<span style="color:#a6e22e">b</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">b</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">a</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// In the universe block:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Implements Ordered(int).
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">a</span> <span style="color:#66d9ef">int</span>) <span style="color:#a6e22e">Less</span>(<span style="color:#a6e22e">b</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">retun</span> <span style="color:#a6e22e">a</span> &lt; <span style="color:#a6e22e">b</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Though it&rsquo;s not clear, whether a parameter like <code>T Ordered(T)</code> should be
allowed. And this would technically allow to implement <code>Ordered(int)</code> on a
custom type. While that probably won&rsquo;t be very useful (the majority of usecases
will require <code>T Ordered(T)</code>), it&rsquo;s not excluded.</p>
<h3 id="pseudo-interfaces">Pseudo-interfaces</h3>
<p>Unfortunately I didn&rsquo;t have a lot of time the last couple of days, so I got
beat to the punch on this. Matt Sherman <a href="https://clipperhouse.com/go-generics-typeclasses/">described the idea first</a>
and called the concept &ldquo;typeclasses&rdquo;. I will stick with pseudo-interface,
because it fits better in the general concept of this description.</p>
<p>The idea is to introduce a set of types into the language that can be used like
interfaces (including embedding), but instead of providing methods, provide
operators. There is a limited set of base types that need to be provided:</p>
<pre tabindex="0"><code>pseudo-interface | Allowed operators
-----------------+-------------------
comparable       | ==, !=
ordered          | &lt;, &lt;= &gt; &gt;=
boolean          | ||, &amp;&amp;, !
bitwise          | ^, %, &amp;, &amp;^, &lt;&lt;, &gt;&gt;
arith            | +, -, *, /
concat           | +
complex          | real(z), imag(z)
nilable          | v == nil
</code></pre><p>and a set of derived pseudo-interfaces:</p>
<pre tabindex="0"><code>pseudo-interface | definition
-----------------+-----------------------------------------------------
num              | interface { comparable; ordered; arith }
integral         | interface { num; bitwise }
stringy          | interface { comparable; ordered; concat; len() int }
iface            | interface { comparable; nilable }
</code></pre><p>The pseudo-interfaces would be declared in the universe block, as predeclared
identifiers. This makes them backwards-compatible (as opposed to methods on
builtin types), because any existing identifier would just shadow these (akin
to how you can have a variable with name <code>string</code>).</p>
<p>Bitshift-operators currently are restricted when used with constants
overflowing the width of an integral type. For generic code, this restriction
would be lifted (as the size is not statically known) and instead the behavior
is equivalent to if the right operand is an uint variable with the given
value.</p>
<p>This would allow us to write</p>
<pre tabindex="0"><code>func Max(type T ordered) (a, b T) T {
  if a &lt; b {
    return b
  }
  return a
}
</code></pre><p>Notably, the list of pseudo-interfaces doesn&rsquo;t include anything related to
channel-, slice- or map-operations (or other composite types). The idea is to
instead use a type literal directly:</p>
<pre tabindex="0"><code>type Keys(type K, V) (m map[K]V) []K {
  var out []K
  for k := range m {
    out = append(out, k)
  }
  return out
}
</code></pre><p>As every type supporting, e.g. <code>map</code> operations, need to have underlying type
<code>map[K]V</code>, it&rsquo;s thus assignable to that type and can be passed to <code>Keys</code> as is.
That is, this is completely legal:</p>
<pre tabindex="0"><code>func main() {
  type MyMap map[string]int
  var m = MyMap{
    &#34;foo&#34;: 23,
    &#34;bar&#34;: 42,
  }
  fmt.Println(Keys(m))
}
</code></pre><p>This also solves another problem with contracts: The ambiguity of <code>len</code>, <code>cap</code>
and <code>range</code>. As the actual kind of the value is not only known during
compilation of the generic function, but even obvious from the code, there is
no question about the intended semantics.</p>
<p>Should Go ever grow operator overloading via operator methods, the
pseudo-interfaces could be changed into actual interfaces, containing the
necessary methods. Of course, that implies that operator overloading would
retain the properties of existing operators, e.g. that having <code>==</code> implies
having <code>!=</code>, or having <code>-</code> implying having <code>+</code>. Personally, I consider that a
good thing - it limits the abuse of operator overloading for nonsensical
operations (say, <code>&lt;&lt;</code> for writing to an <code>io.Writer</code>).</p>
<p>I&rsquo;m not trying to advocate for operator overloading, but think it&rsquo;s worth
mentioning that this design leaves the door open to that.</p>
<h3 id="but-performance">But performance</h3>
<p>A possible criticism of either of these approaches is, that operators have
better performance than dynamic dispatch to a method. I believe (vigorous
handwaving ahead) that this is no different in the existing contracts proposal.
If generic code is compiled generically, it still needs to employ some means
of dynamic dispatch for operators. If, on the other hand, it&rsquo;s compiled
instantiated, then the compiler would also be able to devirtualize the
interfaces - and then inline the method definition.</p>
<h2 id="conclusion">Conclusion</h2>
<p>I&rsquo;ve previously said that I&rsquo;m &ldquo;meh&rdquo; on the design doc, which is the strongest
form of endorsement a generics proposal could ever get from me. After some
discussion, I&rsquo;m more and more convinced that while contracts <em>seem</em>
conceptually simple, they create a plethora of implementation- and usage
questions. I&rsquo;m not sure, the supposed advantage of contracts, of a well-known
syntax, holds up to scrutiny when it comes to mapping that to the actually
derived constraints or writing contracts. There are also many open questions in
regards to contracts, a bunch of them related to the ambiguity of
Go-expressions. As a result, I&rsquo;m starting to feel more negative towards them -
they <em>look</em> like an elegant idea, but in practice, they have a lot of weird
corners.</p>
<p>This design is similar (AIUI) to the <a href="https://go.googlesource.com/proposal/+/master/design/15292/2010-06-type-functions.md">type functions</a>
proposal, so I assume there are good reasons the Go team does not want this.
The difference is mainly the absence of operator methods in favor of
pseudo-interfaces or explicit method calls. This design also handwaves a
couple of important implementation questions - the justification for that is
that these questions (e.g. type inference and code generation) should be able
to be taken from the design doc with minimal changes. It&rsquo;s entirely
possible that I am overlooking something, though.</p>
]]></content></entry><entry><title type="html">Why doesn't Go have variance in its type system?</title><link href="https://blog.merovius.de/posts/2018-06-03-why-doesnt-go-have-variance-in/" rel="alternate" type="text/html"/><id>https://blog.merovius.de//2018/06/03/why-doesnt-go-have-variance-in.html</id><published>2018-06-03T23:20:00+00:00</published><updated>2018-06-03T23:20:00+00:00</updated><content type="html"><![CDATA[<p><strong>tl;dr: I explain what co-, contra- and invariance are and what the
implications for Go&rsquo;s type system would be. In particular, why it&rsquo;s impossible
to have variance in slices.</strong></p>
<p>A question that comes up relatively often with Go newcomers is &ldquo;why can&rsquo;t I
pass e.g. an <code>[]int</code> to a <code>func([]interface{})</code>&rdquo;? In this post I want to
explore this question and its implications for Go. But the concept of
variance (which this is about) is also useful in other languages.</p>
<p>Variance describes what happens to subtype relationships, when they are
used in composite types. In this context, &ldquo;A is a subtype of B&rdquo; means
that a value of type A can always be used, where a value of type B is required.
Go doesn&rsquo;t have explicit subtype relationships - the closest it has is
<a href="https://golang.org/ref/spec#Assignability">assignability</a> which mostly
determines whether types can be used interchangeably. Probably the most
important case of this is given by interfaces: If a type T (whether its a
concrete type, or itself an interface) implements an interface I, then T can be
viewed as a subtype of I. In that sense,
<a href="https://godoc.org/bytes#Buffer"><code>*bytes.Buffer</code></a> is a subtype of
<a href="https://godoc.org/io#ReadWriter">io.ReadWriter</a>, which is a subtype of
<a href="https://godoc.org/io#Reader">io.Reader</a>. And every type is a subtype of
<code>interface{}</code>.</p>
<p>The easiest way to understand what variance means, is to look at function
types. Let&rsquo;s assume, we have a type and a subtype - for example, let&rsquo;s look at
<code>*bytes.Buffer</code> as a subtype of <code>io.Reader</code>. Say, we have a <code>func() *bytes.Buffer</code>. We could also use this like a <code>func() io.Reader</code> - we just
reinterpret the return value as an <code>io.Reader</code>. The reverse is not true: We
can&rsquo;t treat a <code>func() io.Reader</code> as a <code>func() *bytes.Buffer</code>, because not every
<code>io.Reader</code> is a <code>*bytes.Buffer</code>. So, function return values could <em>preserve</em>
the direction of subtyping relationships: If A is a subtype of B, <code>func() A</code>
could be a subtype of <code>func() B</code>. This is called <em>covariance</em>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">F</span>() <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Reader</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> new(<span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">Buffer</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">G</span>() <span style="color:#f92672">*</span><span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">Buffer</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> new(<span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">Buffer</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Use</span>(<span style="color:#a6e22e">f</span> <span style="color:#66d9ef">func</span>() <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Reader</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">useReader</span>(<span style="color:#a6e22e">f</span>())
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Use</span>(<span style="color:#a6e22e">F</span>) <span style="color:#75715e">// Works
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Use</span>(<span style="color:#a6e22e">G</span>) <span style="color:#75715e">// Doesn&#39;t work right now; but *could* be made equivalent to…
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">Use</span>(<span style="color:#66d9ef">func</span>() <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Reader</span> { <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">G</span>() })
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>On the other hand, say we have a <code>func(*bytes.Buffer)</code>. Now we can&rsquo;t use that
as a <code>func(io.Reader)</code>: You can&rsquo;t call it with an <code>io.Reader</code>. But we <em>can</em> do
the reverse. If we have a <code>*bytes.Buffer</code>, we can call a <code>func(io.Reader)</code> with
it. Thus, function arguments <em>reverse</em> the subtype relationship: If A is a
subtype of B, then <code>func(B)</code> could be a subtype of <code>func(A)</code>. This is called
<em>contravariance</em>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">F</span>(<span style="color:#a6e22e">r</span> <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Reader</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">useReader</span>(<span style="color:#a6e22e">r</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">G</span>(<span style="color:#a6e22e">r</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">Buffer</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">useReader</span>(<span style="color:#a6e22e">r</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Use</span>(<span style="color:#a6e22e">f</span> <span style="color:#66d9ef">func</span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">Buffer</span>)) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> new(<span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">Buffer</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">b</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Use</span>(<span style="color:#a6e22e">F</span>) <span style="color:#75715e">// Doesn&#39;t work right now; but *could* be made equivalent to…
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">Use</span>(<span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">r</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">Buffer</span>) { <span style="color:#a6e22e">F</span>(<span style="color:#a6e22e">r</span>) })
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Use</span>(<span style="color:#a6e22e">G</span>) <span style="color:#75715e">// Works
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>So, <code>func</code> is contravariant for arguments and covariant for return values. Of
course, we can combine the two: If A and C are subtypes of B and D
respectively, we can make <code>func(B) C</code> a subtype of <code>func(A) D</code>, by converting
like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// *os.PathError implements error
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">F</span>(<span style="color:#a6e22e">r</span> <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Reader</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">PathError</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Use</span>(<span style="color:#a6e22e">f</span> <span style="color:#66d9ef">func</span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">Buffer</span>) <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> new(<span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">Buffer</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">b</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">useError</span>(<span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Use</span>(<span style="color:#a6e22e">F</span>) <span style="color:#75715e">// Could be made to be equivalent to
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">Use</span>(<span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">r</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">Buffer</span>) <span style="color:#66d9ef">error</span> { <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">F</span>(<span style="color:#a6e22e">r</span>) })
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>However, <code>func(A) C</code> and <code>func(B) D</code> are incompatible. Neither can be a subtype
of the other:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">F</span>(<span style="color:#a6e22e">r</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">Buffer</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">PathError</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">UseF</span>(<span style="color:#a6e22e">f</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Reader</span>) <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">NewReader</span>(<span style="color:#e6db74">&#34;foobar&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">b</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">useError</span>(<span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">G</span>(<span style="color:#a6e22e">r</span> <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Reader</span>) <span style="color:#66d9ef">error</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">UseG</span>(<span style="color:#a6e22e">f</span> <span style="color:#66d9ef">func</span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">Buffer</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">PathErorr</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> new(<span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">Buffer</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">f</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">usePathError</span>(<span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">UseF</span>(<span style="color:#a6e22e">F</span>) <span style="color:#75715e">// Can&#39;t work, because:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">UseF</span>(<span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">r</span> <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Reader</span>) <span style="color:#66d9ef">error</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">F</span>(<span style="color:#a6e22e">r</span>) <span style="color:#75715e">// type-error: io.Reader is not *bytes.Buffer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	})
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">UseG</span>(<span style="color:#a6e22e">G</span>) <span style="color:#75715e">// Can&#39;t work, because:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">UseG</span>(<span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">r</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">Buffer</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">PathError</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">G</span>(<span style="color:#a6e22e">r</span>) <span style="color:#75715e">// type-error: error is not *os.PathError
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	})
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>So in this case, there just <em>is</em> not relationship between the composite types.
This is called <em>invariance</em>.</p>
<hr>
<p>Now, we can get back to our opening question: Why can&rsquo;t you use <code>[]int</code> as
<code>[]interface{}</code>? This really is the question &ldquo;Why are slice-types invariant&rdquo;?.
The questioner assumes that because <code>int</code> is a subtype of <code>interface{}</code>, we
should also make <code>[]int</code> a subtype of <code>[]interface{}</code>. However, we can now see
a simple problem with that. Slices support (among other things) two fundamental
operations, that we can roughly translate into function calls:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">as</span> <span style="color:#f92672">:=</span> make([]<span style="color:#a6e22e">A</span>, <span style="color:#ae81ff">10</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">as</span>[<span style="color:#ae81ff">0</span>] 		<span style="color:#75715e">// func Get(as []A, i int) A
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">as</span>[<span style="color:#ae81ff">1</span>] = <span style="color:#a6e22e">a</span>  		<span style="color:#75715e">// func Set(as []A, i int, a A)
</span></span></span></code></pre></div><p>This shows a clear problem: The type A appears <em>both</em> as an argument <em>and</em>
as a return type. So it appears both covariantly and contravariantly. So while
with functions there is a relatively clear-cut answer to how variance might
work, it just doesn&rsquo;t make a lot of sense for slices. Reading from it would
require covariance but writing to it would require contravariance. In other
words: If you&rsquo;d make <code>[]int</code> a subtype of <code>[]interface{}</code> you&rsquo;d need to explain
how this code would work:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">G</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> []<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">F</span>(<span style="color:#a6e22e">v</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">v</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">F</span>(<span style="color:#a6e22e">v</span> []<span style="color:#66d9ef">interface</span>{}) {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// string is a subtype of interface{}, so this should be valid
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">v</span>[<span style="color:#ae81ff">0</span>] = <span style="color:#e6db74">&#34;Oops&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Channels give another interesting perspective here. The bidirectional channel
type has the same issue as slices: Receiving requires covariance, whereas
sending requires contravariance. But you can restrict the directionality of a
channel and only allow send- or receive-operations respectively. So while <code>chan A</code> and <code>chan B</code> would not be related, we could make <code>&lt;-chan A</code> a subtype of
<code>&lt;-chan B</code>. And <code>chan&lt;- B</code> a subtype of <code>chan&lt;- A</code>.</p>
<p>In that sense, <a href="https://github.com/golang/go/issues/22876">read-only types</a>
have the potential to at least theoretically allow variance for slices. While
<code>[]int</code> still wouldn&rsquo;t be a subtype of <code>[]interface{}</code>, we could make <code>ro []int</code> a subtype of <code>ro []interface{}</code> (borrowing the syntax from the
proposal).</p>
<hr>
<p>Lastly, I want to emphasize that all of these are just the <em>theoretical</em> issues
with adding variance to Go&rsquo;s type system. I consider them harder, but even if
we <em>could</em> solve them we would still run into practical issues. The most
pressing of which is that subtypes have different memory representations:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// super pseudo-code to illustrate
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">x</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">Buffer</span> <span style="color:#75715e">// unsafe.Pointer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">y</span> <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">ReadWriter</span> <span style="color:#75715e">// struct{ itable *itab; value unsafe.Pointer }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>					<span style="color:#75715e">// where itable has two entries
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">z</span> <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Reader</span>		<span style="color:#75715e">// struct{ itable *itab; value unsafe.Pointer }
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>					<span style="color:#75715e">// where itable has one entry
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>)
</span></span></code></pre></div><p>So even though you might think that all interfaces have the same memory
representation, they actually don&rsquo;t, because the method tables have a different
assumed layout. So in code like this</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Do</span>(<span style="color:#a6e22e">f</span> <span style="color:#66d9ef">func</span>() <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Reader</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">r</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">f</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">Read</span>(<span style="color:#a6e22e">buf</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">F</span>() <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Reader</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> new(<span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">Buffer</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">G</span>() <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">ReadWriter</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> new(<span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">Buffer</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">H</span>() <span style="color:#f92672">*</span><span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">Buffer</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> new(<span style="color:#a6e22e">bytes</span>.<span style="color:#a6e22e">Buffer</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// All of F, G, H should be subtypes of func() io.Reader
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">Do</span>(<span style="color:#a6e22e">F</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Do</span>(<span style="color:#a6e22e">G</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Do</span>(<span style="color:#a6e22e">H</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>there still needs to be a place where the return value of <code>H</code> is wrapped into
an <code>io.Reader</code> and there needs to be a place where the itable of the return
value of <code>G</code> is transformed into the correct format expected for an
<code>io.Reader</code>. This isn&rsquo;t a <em>huge</em> problem for <code>func</code>: The compiler can
generate the appropriate wrappers at the call site in <code>main</code>.
There is a performance overhead, but only code that actually uses this form of
subtyping needs to pay it. However, it becomes significant problem for slices.</p>
<p>For slices, we must either a) convert the <code>[]int</code> into an <code>[]interface{}</code> when
passing it, meaning an allocation and complete copy. Or b) delay the conversion
between <code>int</code> and <code>interface{}</code> until the access, which would mean that every
slice access now has to go through an indirect function call - just <em>in case</em>
anyone would ever pass us a subtype of what we are expecting. Both options
seem prohibitively expensive for Go&rsquo;s goals.</p>
]]></content></entry><entry><title type="html">Persistent datastructures with Go</title><link href="https://blog.merovius.de/posts/2018-02-25-persistent_datastructures_with_go/" rel="alternate" type="text/html"/><id>https://blog.merovius.de//2018/02/25/persistent_datastructures_with_go.html</id><published>2018-02-25T17:30:00+00:00</published><updated>2018-02-25T17:30:00+00:00</updated><content type="html"><![CDATA[<p>I&rsquo;ve recently taken a liking to <a href="https://en.wikipedia.org/wiki/Persistent_data_structure">persistent datastructures</a>.
These are datastructures where instead of mutating data in-place, you are
creating a new version of the datastructures, that shares most of its state
with the previous version. Not all datastructures can be implemented
efficiently like this, but those that do get a couple of immediate benefits -
keeping old versions around allows you to get cheap snapshotting and copying.
It is trivial to pass a copy to a different thread and you don&rsquo;t have to worry
about concurrent writes, as neither actually mutates any shared state.</p>
<p>Persistent datastructures are popular in functional programming languages, but
I also found the idea a useful tool to model datastructures in Go. Go&rsquo;s
interfaces provide a nice way to model them and make them easy to reason about.
In this post, I will try to illustrate this with a couple of examples.</p>
<p>There are four key ideas I&rsquo;d like you to walk away with:</p>
<ul>
<li>Modeling datastructures as persistent (<em>if possible</em>) makes them easier to
reason about.</li>
<li>When you want to use sum types, try to think of the common properties you are
trying to abstract over instead - put those in an interface.</li>
<li>Separate out the required from the provided interface. Make the former an
interface type, provide the latter as functions or a wrapper.</li>
<li>Doing these allows you to add more efficient implementations later, when you
discover they are necessary.</li>
</ul>
<h2 id="linked-lists">Linked lists</h2>
<p>This is more of an illustrative example, to demonstrate the techniques, than
actually useful. But one of the simplest datastructures existing are linked
lists: A list of nodes, where each node has a value and possibly a next node
(unless we are at the end of the List). In functional languages, you&rsquo;d use a
sum type to express this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#66d9ef">List</span> a <span style="color:#f92672">=</span> <span style="color:#66d9ef">Node</span> a (<span style="color:#66d9ef">List</span> a) <span style="color:#75715e">-- either it&#39;s a node with a value and the rest of the list</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">|</span> <span style="color:#66d9ef">End</span>             <span style="color:#75715e">-- or it&#39;s the end of the list</span>
</span></span></code></pre></div><p>Go infamously does not have sum types, but we can use interfaces to instead.
The classical way would be something like</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">List</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// We use an unexported marker-method. As nothing outside the current package
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// can implement this unexported method, we get control over all
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// implementations of List and can thus de-facto close the set of possible
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// types.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">list</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Node</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Value</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Next</span> <span style="color:#a6e22e">List</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">Node</span>) <span style="color:#a6e22e">list</span>() {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">End</span> <span style="color:#66d9ef">struct</span> {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">End</span>) <span style="color:#a6e22e">list</span>() {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Value</span>(<span style="color:#a6e22e">l</span> <span style="color:#a6e22e">List</span>) (<span style="color:#a6e22e">v</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">ok</span> <span style="color:#66d9ef">bool</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">l</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">l</span>.(<span style="color:#66d9ef">type</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">Node</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">Value</span>, <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">End</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">default</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// This should never happen. Someone violated our sum-type assumption.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    panic(<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;unknown type %T&#34;</span>, <span style="color:#a6e22e">l</span>))
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This works, but it is not really idiomatic Go code. It is error-prone and easy
to misuse, leading to potential panics. But there is a different way to model
this using interfaces, closer to how they are intended. Instead of expressing
what a list is</p>
<blockquote>
<p>A list <em>is</em> either a value and a next element, or the end of the list</p>
</blockquote>
<p>we say what we want a list to be able to <em>do</em>:</p>
<blockquote>
<p>A list has a current element and may have a tail</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">List</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Value returns the current value of the list
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">Value</span>() <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Next returns the tail of the list, or nil, if this is the last node.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">Next</span>() <span style="color:#a6e22e">List</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">node</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">value</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">next</span>  <span style="color:#a6e22e">List</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">n</span> <span style="color:#a6e22e">node</span>) <span style="color:#a6e22e">Value</span>() <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">value</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">n</span> <span style="color:#a6e22e">node</span>) <span style="color:#a6e22e">Next</span>() <span style="color:#a6e22e">List</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">next</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">New</span>(<span style="color:#a6e22e">v</span> <span style="color:#66d9ef">int</span>) <span style="color:#a6e22e">List</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">node</span>{<span style="color:#a6e22e">v</span>, <span style="color:#66d9ef">nil</span>}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Prepend</span>(<span style="color:#a6e22e">l</span> <span style="color:#a6e22e">List</span>, <span style="color:#a6e22e">v</span> <span style="color:#66d9ef">int</span>) <span style="color:#a6e22e">List</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">node</span>{<span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">l</span>}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This is a far more elegant abstraction. The empty list is represented by the
<code>nil</code> interface. We have only one implementation of that interface, for the
nodes. We offer exported functions to create new lists - potentially from
existing ones.</p>
<p>Note that the methods actually have <code>node</code> as a receiver, not <code>*node</code>, as we
often tend to do with structs. This fact makes this implementation a
<em>persistent</em> linked list. None of the methods can modify the list. So after
creation, the linked list will stay forever immutable. Even if you type-assert
to get to the underlying data, that would only provide you with a <em>copy</em> of the
data - the original would stay unmodified. The memory layout, however, is the
same - the value gets put on the heap and you are only passing pointers to it
around.</p>
<p>The beauty of this way to think about linked lists, is that it allows us to
amend it after the fact. For example, say we notice that our program is slow,
due to excessive cache-misses (as linked lists are not contiguous in memory).
We can easily add a function, that packs a list:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">packed</span> []<span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">p</span> <span style="color:#a6e22e">packed</span>) <span style="color:#a6e22e">Value</span>() <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">p</span>[<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">p</span> <span style="color:#a6e22e">packed</span>) <span style="color:#a6e22e">Next</span>() <span style="color:#a6e22e">List</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">p</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">p</span>[<span style="color:#ae81ff">1</span>:]
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Pack</span>(<span style="color:#a6e22e">l</span> <span style="color:#a6e22e">List</span>) <span style="color:#a6e22e">List</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">l</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">p</span> <span style="color:#a6e22e">packed</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> ; <span style="color:#a6e22e">l</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span>; <span style="color:#a6e22e">l</span> = <span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">Next</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">p</span> = append(<span style="color:#a6e22e">p</span>, <span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">Value</span>())
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">p</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The cool thing about this is that we can mix and match the two: For example,
we could prepend new elements and once the list gets too long, pack it and
continue to prepend to the packed list. And since <code>List</code> is an interface, users
can implement it themselves and use it with our existing implementation. So,
for example, a user could build us a list that calculates fibonacci numbers:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">fib</span> [<span style="color:#ae81ff">2</span>]<span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">l</span> <span style="color:#a6e22e">fib</span>) <span style="color:#a6e22e">Value</span>() <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">l</span>[<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">l</span> <span style="color:#a6e22e">fib</span>) <span style="color:#a6e22e">Next</span>() <span style="color:#a6e22e">List</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fib</span>{<span style="color:#a6e22e">l</span>[<span style="color:#ae81ff">1</span>], <span style="color:#a6e22e">l</span>[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">+</span><span style="color:#a6e22e">l</span>[<span style="color:#ae81ff">1</span>]}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>and then use that with functions that take a <code>List</code>. Or they could have a
lazily evaluated list:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">lazy</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">o</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">Once</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">f</span> <span style="color:#66d9ef">func</span>() (<span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">List</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">v</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">next</span> <span style="color:#a6e22e">List</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">l</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">lazy</span>) <span style="color:#a6e22e">Value</span>() <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">o</span>.<span style="color:#a6e22e">Do</span>(<span style="color:#66d9ef">func</span>() { <span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">next</span> = <span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">f</span>() })
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">v</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">l</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">lazy</span>) <span style="color:#a6e22e">Next</span>() <span style="color:#a6e22e">List</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">o</span>.<span style="color:#a6e22e">Do</span>(<span style="color:#66d9ef">func</span>() { <span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">next</span> = <span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">f</span>() })
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">l</span>.<span style="color:#a6e22e">next</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Note that in this case the methods need to be on a pointer-receiver. This
(technically) leaves the realm of persistent data-structures. While they
motivated our interface-based abstraction and helped us come up with a safe
implementation, we are not actually <em>bound</em> to them. If we later decide, that
for performance reasons we want to add a mutable implementation, we can do so
(of course, we still have to make sure that we maintain the safety of the
original). And we can intermix the two, allowing us to only apply this
optimization to part of our data structure.</p>
<p>I find this a pretty helpful way to think about datastructures.</p>
<h2 id="associative-lists">Associative lists</h2>
<p>Building on linked lists, we can build a map based on <a href="https://en.wikipedia.org/wiki/Association_list">Association Lists</a>.
It&rsquo;s a similar idea as before:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Map</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Value</span>(<span style="color:#a6e22e">k</span> <span style="color:#66d9ef">interface</span>{}) <span style="color:#66d9ef">interface</span>{}
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Set</span>(<span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">v</span> <span style="color:#66d9ef">interface</span>{}) <span style="color:#a6e22e">Map</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">empty</span> <span style="color:#66d9ef">struct</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">empty</span>) <span style="color:#a6e22e">Value</span>(<span style="color:#a6e22e">_</span> <span style="color:#66d9ef">interface</span>{}) <span style="color:#66d9ef">interface</span>{} {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">empty</span>) <span style="color:#a6e22e">Set</span>(<span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">v</span> <span style="color:#66d9ef">interface</span>{}) <span style="color:#a6e22e">Map</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">pair</span>{<span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">empty</span>{}}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Make</span>() <span style="color:#a6e22e">Map</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">empty</span>{}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">pair</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">v</span> <span style="color:#66d9ef">interface</span>{}
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">parent</span> <span style="color:#a6e22e">Map</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">p</span> <span style="color:#a6e22e">pair</span>) <span style="color:#a6e22e">Value</span>(<span style="color:#a6e22e">k</span> <span style="color:#66d9ef">interface</span>{}) <span style="color:#66d9ef">interface</span>{} {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">k</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">k</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">v</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">parent</span>.<span style="color:#a6e22e">Value</span>(<span style="color:#a6e22e">k</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">p</span> <span style="color:#a6e22e">pair</span>) <span style="color:#a6e22e">Set</span>(<span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">v</span> <span style="color:#66d9ef">interface</span>{}) <span style="color:#a6e22e">Map</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">pair</span>{<span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">p</span>}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This time, we don&rsquo;t represent an empty map as <code>nil</code>, but add a separate
implementation of the interface for an empty map.  That makes the
implementation of <code>Value</code> cleaner, as it doesn&rsquo;t have to check the parent map
for <code>nil</code> &ndash; but it requires users to call <code>Make</code>.</p>
<p>There is a problem with our <code>Map</code>, though: We cannot iterate over it. The
interface does not give us access to any parent maps. We could use
type-assertion, but that would preclude users from implementing their own. What
if we added a method to the interface to support iteration?</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Map</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Value</span>(<span style="color:#a6e22e">k</span> <span style="color:#66d9ef">interface</span>{}) <span style="color:#66d9ef">interface</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Iterate calls f with all key-value pairs in the map.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">Iterate</span>(<span style="color:#a6e22e">f</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">v</span> <span style="color:#66d9ef">interface</span>{}))
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">empty</span>) <span style="color:#a6e22e">Iterate</span>(<span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">v</span> <span style="color:#66d9ef">interface</span>{})) {
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">p</span> <span style="color:#a6e22e">pair</span>) <span style="color:#a6e22e">Iterate</span>(<span style="color:#a6e22e">f</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">v</span> <span style="color:#66d9ef">interface</span>{})) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">v</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">parent</span>.<span style="color:#a6e22e">Iterate</span>(<span style="color:#a6e22e">f</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Unfortunately, this still doesn&rsquo;t really work though: If we write multiple
times to the same key, <code>Iterate</code> as implemented would call <code>f</code> with all
key-value-pairs. This is likely not what we want.</p>
<p>The heart of the issue here, is the difference between the <em>required</em> interface
and the <em>provided</em> interface. We can also see that with <code>Set</code>. Both of the
implementations of that method look essentially the same and neither actually
depends on the used type. We could instead provide <code>Set</code> as a function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Set</span>(<span style="color:#a6e22e">m</span> <span style="color:#a6e22e">Map</span>, <span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">v</span> <span style="color:#66d9ef">interface</span>{}) <span style="color:#a6e22e">Map</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">pair</span>{<span style="color:#a6e22e">k</span>,<span style="color:#a6e22e">v</span>,<span style="color:#a6e22e">m</span>}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The lesson is, that some operations need support from the implementation, while
other operations can be implemented without it. The provided interface is the
set of operations we provide to the user, whereas the required interface is the
set of operations that we rely on. We can split the two and get something like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// Interface is the set of operations required to implement a persistent map.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Interface</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Value</span>(<span style="color:#a6e22e">k</span> <span style="color:#66d9ef">interface</span>{}) <span style="color:#66d9ef">interface</span>{}
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Iterate</span>(<span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">v</span> <span style="color:#66d9ef">interface</span>{}))
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Map</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Interface</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">m</span> <span style="color:#a6e22e">Map</span>) <span style="color:#a6e22e">Iterate</span>(<span style="color:#a6e22e">f</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">v</span> <span style="color:#66d9ef">interface</span>{})) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">seen</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">interface</span>{}]<span style="color:#66d9ef">bool</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">Interface</span>.<span style="color:#a6e22e">Iterate</span>(<span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">v</span> <span style="color:#66d9ef">interface</span>{}) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">seen</span>[<span style="color:#a6e22e">k</span>] {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">v</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  })
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">m</span> <span style="color:#a6e22e">Map</span>) <span style="color:#a6e22e">Set</span>(<span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">v</span> <span style="color:#66d9ef">interface</span>{}) <span style="color:#a6e22e">Map</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">Map</span>{<span style="color:#a6e22e">pair</span>{<span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">Interface</span>}}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Using this, we could again implement a packed variant of <code>Map</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">packed</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">interface</span>{}]<span style="color:#66d9ef">interface</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">p</span> <span style="color:#a6e22e">packed</span>) <span style="color:#a6e22e">Value</span>(<span style="color:#a6e22e">k</span> <span style="color:#66d9ef">interface</span>{}) <span style="color:#66d9ef">interface</span>{} {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">p</span>[<span style="color:#a6e22e">k</span>]
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">p</span> <span style="color:#a6e22e">packed</span>) <span style="color:#a6e22e">Iterate</span>(<span style="color:#a6e22e">f</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">v</span> <span style="color:#66d9ef">interface</span>{})) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">p</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">f</span>(<span style="color:#a6e22e">k</span>, <span style="color:#a6e22e">v</span>)
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Pack</span>(<span style="color:#a6e22e">m</span> <span style="color:#a6e22e">Map</span>) <span style="color:#a6e22e">Map</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> make(<span style="color:#a6e22e">packed</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">Iterate</span>(<span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">k</span>,<span style="color:#a6e22e">v</span> <span style="color:#66d9ef">interface</span>{}) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">p</span>[<span style="color:#a6e22e">k</span>] = <span style="color:#a6e22e">v</span>
</span></span><span style="display:flex;"><span>  })
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">m</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="ropes">Ropes</h2>
<p>A <a href="https://en.wikipedia.org/wiki/Rope_(data_structure)">Rope</a> is a data
structure to store a string in a way that is efficiently editable. They are
often used in editors, as it is too slow to copy the complete content on every
insert operation. Editors also benefit from implementing them as persistent data
structures, as that makes it very easy to implement multi-level undo: Just have
a stack (or ringbuffer) of Ropes, representing the states the file was in after
each edit. Given that they all share most of their structure, this is very
efficient. Implementing ropes is what really bought me into the patterns
I&rsquo;m presenting here. Let&rsquo;s see, how we could represent them.</p>
<a href="https://en.wikipedia.org/wiki/Rope_(data_structure)#/media/File:Vector_Rope_example.svg">
  <img src="/assets/Vector_Rope_example.svg" alt='Rope representing the string "Hello_my_name_is_Simon"'>
</a>
<p>A Rope is a binary tree with strings as leafs. The represented string
is what you get when you do a depth-first traversal and concatenate all the
leafs. Every node in the tree also has a <em>weight</em>, which corresponds to the
length of the string for leafs and the length of the left subtree for inner
nodes. This allows easy recursive lookup of the <code>i</code>th character: If <code>i</code> is less
than the weight of a node, we look into the left subtree, otherwise into the
right. Let&rsquo;s represent this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Base</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Index</span>(<span style="color:#a6e22e">i</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">byte</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Length</span>() <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">leaf</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">l</span> <span style="color:#a6e22e">leaf</span>) <span style="color:#a6e22e">Index</span>(<span style="color:#a6e22e">i</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">byte</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">l</span>[<span style="color:#a6e22e">i</span>]
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">l</span> <span style="color:#a6e22e">leaf</span>) <span style="color:#a6e22e">Length</span>() <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> len(<span style="color:#a6e22e">l</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">node</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">left</span>, <span style="color:#a6e22e">right</span> <span style="color:#a6e22e">Base</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">n</span> <span style="color:#a6e22e">node</span>) <span style="color:#a6e22e">Index</span>(<span style="color:#a6e22e">i</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">byte</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">w</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">left</span>.<span style="color:#a6e22e">Length</span>(); <span style="color:#a6e22e">i</span> <span style="color:#f92672">&gt;=</span> <span style="color:#a6e22e">w</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// The string represented by the right child starts at position w,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// so we subtract it when recursing to the right
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">right</span>.<span style="color:#a6e22e">Index</span>(<span style="color:#a6e22e">i</span><span style="color:#f92672">-</span><span style="color:#a6e22e">w</span>)
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">left</span>.<span style="color:#a6e22e">Index</span>(<span style="color:#a6e22e">i</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">n</span> <span style="color:#a6e22e">node</span>) <span style="color:#a6e22e">Length</span>() <span style="color:#66d9ef">int</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">left</span>.<span style="color:#a6e22e">Length</span>() <span style="color:#f92672">+</span> <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">right</span>.<span style="color:#a6e22e">Length</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Rope</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Base</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">New</span>(<span style="color:#a6e22e">s</span> <span style="color:#66d9ef">string</span>) <span style="color:#a6e22e">Rope</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">Rope</span>{<span style="color:#a6e22e">leaf</span>(<span style="color:#a6e22e">s</span>)}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">r</span> <span style="color:#a6e22e">Rope</span>) <span style="color:#a6e22e">Append</span>(<span style="color:#a6e22e">r2</span> <span style="color:#a6e22e">Rope</span>) <span style="color:#a6e22e">Rope</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">Rope</span>{<span style="color:#a6e22e">node</span>{<span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">Base</span>, <span style="color:#a6e22e">r2</span>.<span style="color:#a6e22e">Base</span>}}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Note, how we did not actually add a <code>Weight</code>-method to our interface: Given
that it&rsquo;s only used by the traversal on inner nodes, we can just directly
calculate it from its definition as the length of the left child tree. In
practice, we might want to pre-calculate <code>Length</code> on creation, though, as it
currently is a costly recursive operation.</p>
<p>The next operation we&rsquo;d have to support, is splitting a Rope at an index. We
can&rsquo;t implement that with our current interface though, we need to add it:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Base</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Index</span>(<span style="color:#a6e22e">i</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">byte</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Length</span>() <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Split</span>(<span style="color:#a6e22e">i</span> <span style="color:#66d9ef">int</span>) (<span style="color:#a6e22e">left</span>, <span style="color:#a6e22e">right</span> <span style="color:#a6e22e">Base</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">l</span> <span style="color:#a6e22e">leaf</span>) <span style="color:#a6e22e">Split</span>(<span style="color:#a6e22e">i</span> <span style="color:#66d9ef">int</span>) (<span style="color:#a6e22e">Base</span>, <span style="color:#a6e22e">Base</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">l</span>[:<span style="color:#a6e22e">i</span>], <span style="color:#a6e22e">l</span>[<span style="color:#a6e22e">i</span>:]
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">n</span> <span style="color:#a6e22e">node</span>) <span style="color:#a6e22e">Split</span>(<span style="color:#a6e22e">i</span> <span style="color:#66d9ef">int</span>) (<span style="color:#a6e22e">Base</span>, <span style="color:#a6e22e">Base</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">w</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">left</span>.<span style="color:#a6e22e">Length</span>(); <span style="color:#a6e22e">i</span> <span style="color:#f92672">&gt;=</span> <span style="color:#a6e22e">w</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">left</span>, <span style="color:#a6e22e">right</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">right</span>.<span style="color:#a6e22e">Split</span>(<span style="color:#a6e22e">i</span><span style="color:#f92672">-</span><span style="color:#a6e22e">w</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">node</span>{<span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">left</span>, <span style="color:#a6e22e">left</span>}, <span style="color:#a6e22e">right</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">left</span>, <span style="color:#a6e22e">right</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">left</span>.<span style="color:#a6e22e">Split</span>(<span style="color:#a6e22e">i</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">left</span>, <span style="color:#a6e22e">node</span>{<span style="color:#a6e22e">n</span>.<span style="color:#a6e22e">right</span>, <span style="color:#a6e22e">right</span>}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">r</span> <span style="color:#a6e22e">Rope</span>) <span style="color:#a6e22e">Split</span>(<span style="color:#a6e22e">i</span> <span style="color:#66d9ef">int</span>) (<span style="color:#a6e22e">Rope</span>, <span style="color:#a6e22e">Rope</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Note that we return the wrapping struct, as opposed to Base.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// This is so users work with the provided interface, not the required one.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">left</span>, <span style="color:#a6e22e">right</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">Split</span>(<span style="color:#a6e22e">i</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">Rope</span>{<span style="color:#a6e22e">left</span>}, <span style="color:#a6e22e">Rope</span>{<span style="color:#a6e22e">right</span>}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>I think this code is remarkably readable and easy to understand - and that is
mostly due to the fact that we are reusing subtrees whenever we can. What&rsquo;s
more, given these operations we can implement the remaining three from the
wikipedia article easily:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">r</span> <span style="color:#a6e22e">Rope</span>) <span style="color:#a6e22e">Insert</span>(<span style="color:#a6e22e">r2</span> <span style="color:#a6e22e">Rope</span>, <span style="color:#a6e22e">i</span> <span style="color:#66d9ef">int</span>) <span style="color:#a6e22e">Rope</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">left</span>, <span style="color:#a6e22e">right</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">Split</span>(<span style="color:#a6e22e">i</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">left</span>.<span style="color:#a6e22e">Append</span>(<span style="color:#a6e22e">r2</span>).<span style="color:#a6e22e">Append</span>(<span style="color:#a6e22e">right</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">r</span> <span style="color:#a6e22e">Rope</span>) <span style="color:#a6e22e">Delete</span>(<span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">j</span> <span style="color:#66d9ef">int</span>) <span style="color:#a6e22e">Rope</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">left</span>, <span style="color:#a6e22e">right</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">Split</span>(<span style="color:#a6e22e">j</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">left</span>, <span style="color:#a6e22e">_</span> = <span style="color:#a6e22e">left</span>.<span style="color:#a6e22e">Split</span>(<span style="color:#a6e22e">i</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">left</span>.<span style="color:#a6e22e">Append</span>(<span style="color:#a6e22e">right</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">r</span> <span style="color:#a6e22e">Rope</span>) <span style="color:#a6e22e">Slice</span>(<span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">j</span> <span style="color:#66d9ef">int</span>) <span style="color:#a6e22e">Rope</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">r</span>, <span style="color:#a6e22e">_</span> = <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">Split</span>(<span style="color:#a6e22e">j</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">r</span> = <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">Split</span>(<span style="color:#a6e22e">i</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">r</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This provides us with a fully functioning Rope implementation. It doesn&rsquo;t
support everything we&rsquo;d need to write an editor, but it&rsquo;s a good start that was
quick to write. It is also reasonably simple to extend with more functionality.
For example, you could imagine having an implementation that can rebalance
itself, when operations start taking too long. Or adding traversal, or
random-access unicode support that is still backed by compact UTF-8. And I
found it reasonably simple (though it required some usage of unsafe) to write
an implementation of <code>Base</code> that used an <code>mmap</code>ed file (thus you&rsquo;d only need to
keep the actual edits in RAM, the rest would be read directly from disk with
the OS managing caching for you).</p>
<h2 id="closing-remarks">Closing remarks</h2>
<p>None of these ideas are revolutionary (especially to functional programmers).
But I find that considering if a datastructure I need can be implemented as a
persistent/immutable one helps me to come up with clear abstractions that work
well. And I also believe that Go&rsquo;s interfaces provide a good way to express
these abstractions - because they allow you to start with a simple, immutable
implementation and then compose it with mutable ones - if and only if there are
clear efficiency benefits. Lastly, I think there is an interesting idea here of
how to substitute sum-types by interfaces - not in a direct manner, but instead
by thinking about the common behavior you want to provide over the sum.</p>
<p>I hope you find that this inspires you to think differently about these problems too.</p>
]]></content></entry><entry><title type="html">What even is error handling?</title><link href="https://blog.merovius.de/posts/2018-01-21-what_even_is_error_handling/" rel="alternate" type="text/html"/><id>https://blog.merovius.de//2018/01/21/what_even_is_error_handling.html</id><published>2018-01-21T23:40:00+00:00</published><updated>2018-01-21T23:40:00+00:00</updated><content type="html"><![CDATA[<p><strong>tl;dr: Error handling shouldn&rsquo;t be about how to best propagate an error
value, but how to make it destroy it (or make it irrelevant). To encourage
myself to do that, I started removing errors from function returns wherever I
found it at all feasible</strong></p>
<p>Error handling in Go is a contentious and often criticized issue. There is no
shortage on articles criticizing the approach taken, no shortage on articles
giving advice on how to deal with it (or defending it) and also no shortage on
proposals on how to improve it.</p>
<p>During these discussion, I always feel there is something missing. The
proposals for improvement usually deal with syntactical issues, how to avoid
boilerplate. Then there is the other school of thought - where it&rsquo;s not about
syntax, but about how to best pass errors around. Dave Chaney wrote <a href="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully">an often
quoted blog post on the
subject</a>,
where he lists all the ways error information can be mapped into the Go type
system, why he considers them flawed and what he suggests instead.
This school of thought regularly comes up with helper packages, to make
wrapping or annotating errors easier.
<a href="https://github.com/pkg/errors">pkg/errors</a> is very popular (and is grown out
of the approach of above blog post) but <a href="https://godoc.org/github.com/upspin/upspin/errors#Error">upspin&rsquo;s
incarnation</a> also
gathered some attention.</p>
<p>I am dissatisfied with both schools of thought. Overall, neither seems to
explicitly address, what to me is the underlying question: What <em>is</em> error
handling? In this post, I&rsquo;m trying to describe how I interpret the term and
why, to me, the existing approaches and discussions mostly miss the mark. Note,
that I don&rsquo;t claim this understanding to be universal - just how <em>I</em> would put
into words my understanding of the topic.</p>
<hr>
<p>Let&rsquo;s start with a maybe weird question: Why is the entry point into the
program <code>func main()</code> and not <code>func main() error</code>? Personally, I start most of
my programs writing</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">run</span>(); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Fatal</span>(<span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">run</span>() <span style="color:#66d9ef">error</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// …
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>This allows me to use <code>defer</code>, pass on errors and all that good stuff. So, why
doesn&rsquo;t the language just do that for me?</p>
<p>We can find part of the answer in <a href="https://groups.google.com/d/topic/golang-nuts/6xl02B_MxdA/discussion">this old golang-nuts thread</a>.
It is about return codes, instead of an <code>error</code>, but the principle is the
same. And the best answer - in my opinion - is this:</p>
<blockquote>
<p>I think the returned status is OS-specific, and so Go the language should not
define its type (Maybe some OS can only report 8-bit result while some other
OS support arbitrary string as program status, there is considerable
differences between that; there might even be environment that don&rsquo;t support
returning status code or the concept of status code simply doesn&rsquo;t exist)</p>
<p>I imagine some Plan 9 users might be disagree with the signature of
<code>os.Exit()</code>.</p>
</blockquote>
<p>So, in essence: Not all implementations would necessarily be able to assign a
reasonable meaning to a return code (or error) from <code>main</code>. For example, an
embedded device likely couldn&rsquo;t really do anything with it. It thus seems
preferable to not couple the language to this decision which only <em>really</em> makes
semantic sense on a limited subset of implementations. Instead, we provide
mechanisms in the standard library to exit the program or take any other
reasonable action and then let the developer decide, under what circumstances
they want to exit the program and with what code. Being coupled to a decision
in the standard library is better than being coupled in the language itself.
And a developer who targets a platform where an exit code doesn&rsquo;t make sense,
can take a different action instead.</p>
<p>Of course, this leaves the programmer with a problem: What to do with errors?
We could write it to stderr, but <code>fmt.Fprintf</code> <em>also</em> returns an error, so what
to do with that one? Above I used <code>log.Fatal</code>, which does <em>not</em> return an error.
What happens if the underlying <code>io.Writer</code> fails to write, though? What
does <code>log</code> do with the resulting error? The answer is, of course: It ignores
any errors.</p>
<p>The point is, that passing on the error is not a solution. <em>Eventually</em> every
program will return to <code>main</code> (or <code>os.Exit</code> or panic) and the buck stops there.
It needs to get <em>handled</em> and the signature of <code>main</code> enforces that the only
way to do that is via side-effects - and if they fail, you just have to deal
with that one too.</p>
<hr>
<p>Let&rsquo;s continue with a similar question, that has a similar answer, that
occasionally comes up: Why doesn&rsquo;t <code>ServeHTTP</code> return an <code>error</code>? Sooner or
later, people face the question of what to do with errors in their HTTP
Handlers. For example, what if you are writing out a JSON object and
<code>Marshal</code> fails? In fact, a lot of HTTP frameworks out there will define their
own handler-type, which differs from <code>http.Handler</code> in exactly that way. But if
everyone wants to return an <code>error</code> from their handler, why doesn&rsquo;t the
interface just add that error return itself? Was that just an oversight?</p>
<p>I&rsquo;m strongly arguing that no, this was not an oversight, but the correct design
decision. Because the HTTP Server package <em>can not handle any errors</em>. An HTTP
server is supposed to stay running, every request demands a response. If
<code>ServeHTTP</code> would return an <code>error</code>, the server would have to do <em>something</em>
with it, but what to do is highly application-specific. You might respond that
it should serve a 500 error code, but in 99% of cases, that is the wrong thing
to do. Instead you should serve a more specific error code, so the client
knows (for example) whether to retry or if the response is cacheable.
<code>http.Server</code> could also just ignore the error and instead drop the request on
the floor, but that&rsquo;s even worse. Or it could propagate it up the stack. But as
we determined, eventually it would have to reach <code>main</code> and the buck stops
there. You probably don&rsquo;t want your server to come down, every time a request
contains an invalid parameter.</p>
<p>So, given that a) every request needs an answer and b) the right answer is
highly application-specific, the translation from errors into status codes
<em>has</em> to happen in application code. And just like <code>main</code> enforces you to
handle any errors via side-effects by not allowing you to return an <code>error</code>, so
does <code>http</code> force you to handle any errors via writing a response by not
allowing you to return an <code>error</code>.<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></p>
<p>So, what are you supposed to do, when <code>json.Marshal</code> fails? Well, that depends
on our application. Increment a metric. Log the error. panic. Write out a 500.
Ignore it and write a 200. Commit to the uncomfortable knowledge, that
sometimes, you can&rsquo;t just pass the decision on what to do with an error to
someone else.</p>
<hr>
<p>These two examples distill, I think, pretty well, what I view as error
<em>handling</em>: An error is handled, when you destroy the error value. In that
parlance, <code>log.Error</code> handles any errors of the underlying writer by not
returning them. Every program needs to handle any error in <em>some</em> way, because
<code>main</code> can&rsquo;t return anything and the values need to go <em>somewhere</em>. Any HTTP
handler needs to actually <em>handle</em> errors, by translating them into HTTP
responses.</p>
<p>And in that parlance, packages like <code>pkg/errors</code> have little, really, to do with
error <em>handling</em> - instead, they provides you with a strategy for the case where
you are <em>not</em> handling your errors. In the same vein, proposals that address
the repetitive checking of errors via extra syntax do not really simplify their
handling at all - they just move it around a bit. I would term that <em>error
propagation</em>, instead - no doubt important, but keep in mind, that an error
that was <em>handled</em>, doesn&rsquo;t need to be propagated at all. So to me, a good
approach to error handling would be characterized by mostly obviating the need
for convenient error propagation mechanisms.</p>
<p>And to me, at least, it seems that we talk too little about how to handle
errors, in the end.</p>
<hr>
<p>Does Go encourage explicit error handling? This is the phrasing very often used
to justify the repetitive nature, but I tend to disagree. Compare, for example,
Go&rsquo;s approach to checked exceptions in Java: There, errors are propagated via
exceptions. Every exception that could be thrown (theoretically) must be
annotated in the method signature. Any exception that you handle, has to be
mentioned in a try-catch-statement. And the compiler will refuse to compile a
program which does not explicitly mention how exceptions are handled. This, to
me, seems like the pinnacle of <em>explicit</em> error handling. Rust, too, requires
this - it introduces a <code>?</code> operator to signify propagating an error, but that,
still, is an explicit annotation. And apart from that, you can&rsquo;t use the return
value of a function that might propagate an error, without explicitly handling
that error first.</p>
<p>In Go, on the other hand, it is not only perfectly acceptable to ignore errors
when it makes sense (for example, I will always ignore errors created from
writing to a <a href="https://godoc.org/bytes#Buffer.Write"><code>*bytes.Buffer</code></a>), it is
actually often the only sensible thing to do. It is fundamentally not only
okay, but 99% of times <em>correct</em> to just completely ignore the error returned
by <code>fmt.Println</code>. And while it makes sense to check the error returned from
<code>json.Marshal</code> in your HTTP handler against <code>*json.MarshalError</code> (to
panic/log/complain loudly, because your code is buggy), any other errors
<em>should 99% of the time just be ignored</em>. And that&rsquo;s fine.</p>
<p>I believe that to say Go encourages explicit error handling, it would need some
mechanism of checked exceptions, Result types, or a requirement to pass an
<a href="https://github.com/kisielk/errcheck">errcheck</a> like analysis in the compiler.</p>
<p>I think it would be closer to say, that Go encourages <em>local</em> error handling.
That is, the code that handles an error, is close to the code that produced it.
Exceptions encourages the two to be separated: There are usually several
or many lines of code in a single <code>try</code>-block, all of which share one
<code>catch</code>-block and it is hard to tell which of the lines produced it. And very
often, the actual error location is several stack frames deep. You could
contrast this with Go, where the error return is immediately obvious from the
code and if you have a line of error handling, it is usually immediately
attached to the function call that produced it.</p>
<p>However, that still seems to come short, in my view. After all, there is
nothing to force you to do that. And in fact, one of the most often <a href="https://blog.golang.org/errors-are-values">cited
articles about Go error handling</a> is
often interpreted to encourage exactly that. Plus, a lot of people end up
writing <code>return err</code> far too often, simply propagating the error to be
<em>handled</em> elsewhere. And the proliferation of error-wrapping libraries happens
in the same vein: What their proponents phrase as &ldquo;adding context to the error
value&rdquo;, I interpret as &ldquo;adding back some of the information as a crutch, that
you removed when passing the error to non-local handling code&rdquo;. Sadly, far too
often, the error then ends up not being handled at all, as everyone just takes
advantage of that crutch. This leaves the end-user with an error message that is
essentially a poorly formatted, non-contiguous stacktrace.</p>
<p>Personally, I&rsquo;d characterize Go&rsquo;s approach like this: In Go, error handling is
simply first-class code. By forcing you to use exactly the same control-flow
mechanisms and treat errors like any other data, Go encourages you to code your
error handling. Often that means a bunch of control flow to catch and recover
from any errors where they occur. But that&rsquo;s not &ldquo;clutter&rdquo;, just as it is not
&ldquo;clutter&rdquo; to write <code>if n &lt; 1 { return 1 }</code> when writing a Fibonacci function
(to choose a trivial example). It is just code. And yes, sometimes that code
might also store the error away or propagate it out-of-band to reduce
repetition <em>where it makes sense</em> - like in above blog post. But focussing on
the &ldquo;happy path&rdquo; is a bit of a distraction: Your <em>users</em> will definitely be
more happy about those parts of the control flow that make the errors disappear
or transform them into clean, actionable advise on how to solve the problem.</p>
<p>So, in my reading, the title of the Go blog post puts the emphasis in slightly
the wrong place - and often, people take the wrong message from it, in my
opinion. Not &ldquo;errors are values&rdquo;, but &ldquo;error handling is code&rdquo;.</p>
<hr>
<p>So, what <em>would</em> be my advise for handling errors? To be honest, I don&rsquo;t know
yet - and I&rsquo;m probably in no place to lecture anyone anyway.</p>
<p>Personally, I&rsquo;ve been trying for the last couple of months to take a page out
of <code>http.Handler</code>s playbook and try, as much as possible, to completely avoid
returning an error. Instead of thinking &ldquo;I should return an error here, in case
I ever do any operation that fails&rdquo;, I instead think &ldquo;is there <em>any way at
all</em> I can get away with not returning an error here?&rdquo;. It doesn&rsquo;t always work
and sometimes you <em>do</em> have to pass errors around or wrap them. But I am
forcing myself to think very hard about handling my errors and it encourages a
programming-style of isolating failing components. The constraint of not being
able to return an error tends to make you creative in how to handle it.</p>
<hr>
<p>I think <em>this</em> particular pattern is fine, though, personally, I don&rsquo;t
really see the point. Anything that builds an <code>appError</code> needs to provide
the complete response anyway, so you might as well just write it out
directly. YMMV.</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>You might be tempted to suggest, that you could
define an <code>HTTPError</code>, containing the necessary info. Indeed, that&rsquo;s what the
<a href="https://blog.golang.org/error-handling-and-go#TOC_3.">official Go blog</a> does,
so it can&rsquo;t be bad? And indeed, that <em>is</em> what they do, but note that they do
<em>not</em> actually return an <code>error</code> in the end - they return an <code>appError</code>, which
contains the necessary information. Exactly <em>because</em> they don&rsquo;t know how to
deal with general errors. So they translate any errors into a domain specific
type that carries the response. So, that is <em>not</em> the same as returning an
<code>error</code>.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
]]></content></entry><entry><title type="html">Generating entropy without imports in Go</title><link href="https://blog.merovius.de/posts/2018-01-15-generating_entropy_without_imports_in_go/" rel="alternate" type="text/html"/><id>https://blog.merovius.de//2018/01/15/generating_entropy_without_imports_in_go.html</id><published>2018-01-15T01:04:30+00:00</published><updated>2018-01-15T01:04:30+00:00</updated><content type="html"><![CDATA[<p><strong>tl;dr: I come up with a couple of useless, but entertaining ways to generate entropy without relying on any packages.</strong></p>
<p>This post is inspired by a <a href="https://www.reddit.com/r/golang/comments/7qb74r/can_golang_package_source_with_no_imports_be/dso7xsc/">comment on reddit</a>,
saying</p>
<blockquote>
<p>[…]given the constraints of no imports and the function signature:</p>
<p><code>func F(map[string]string) map[string]string { ... }</code></p>
<p>F must use a deterministic algorithm, since it is a deterministic algorithm
it can be represented in a finite state machine.</p>
</blockquote>
<p>Now, the point of this comment was to talk about how to then compile such a
function into a deterministic finite state machine, but it got me thinking
about a somewhat different question. If we disallow any imports and assume a
standard (gc) Go implementation - how many ways can we find to create a
non-deterministic function?</p>
<p>So, the challenge I set to myself was: Write a function <code>func() string</code> that a)
can not refer to any qualified identifier (i.e. no imports) and b) is
non-deterministic, that is, produces different outputs on each run. To start me
off, I did add a couple of helpers, to accumulate entropy, generate random
numbers from it and to format strings as hex, without any imports:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">rand</span> <span style="color:#66d9ef">uint32</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">r</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">rand</span>) <span style="color:#a6e22e">mix</span>(<span style="color:#a6e22e">v</span> <span style="color:#66d9ef">uint32</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">*</span><span style="color:#a6e22e">r</span> = ((<span style="color:#f92672">*</span><span style="color:#a6e22e">r</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">5</span>) <span style="color:#f92672">+</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">r</span>) <span style="color:#f92672">+</span> <span style="color:#a6e22e">rand</span>(<span style="color:#a6e22e">v</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">r</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">rand</span>) <span style="color:#a6e22e">rand</span>() <span style="color:#66d9ef">uint32</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mx</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">rand</span>(int32(<span style="color:#f92672">*</span><span style="color:#a6e22e">r</span>)<span style="color:#f92672">&gt;&gt;</span><span style="color:#ae81ff">31</span>) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xa8888eef</span>
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">*</span><span style="color:#a6e22e">r</span> = <span style="color:#f92672">*</span><span style="color:#a6e22e">r</span><span style="color:#f92672">&lt;&lt;</span><span style="color:#ae81ff">1</span> ^ <span style="color:#a6e22e">mx</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> uint32(<span style="color:#f92672">*</span><span style="color:#a6e22e">r</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">hex</span>(<span style="color:#a6e22e">v</span> <span style="color:#66d9ef">uint32</span>) <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">b</span> []<span style="color:#66d9ef">byte</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">v</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">:=</span> byte(<span style="color:#a6e22e">v</span> <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xf</span>); <span style="color:#a6e22e">x</span> &lt; <span style="color:#ae81ff">10</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">b</span> = append(<span style="color:#a6e22e">b</span>, <span style="color:#e6db74">&#39;0&#39;</span><span style="color:#f92672">+</span><span style="color:#a6e22e">x</span>)
</span></span><span style="display:flex;"><span>		} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">b</span> = append(<span style="color:#a6e22e">b</span>, <span style="color:#e6db74">&#39;a&#39;</span><span style="color:#f92672">+</span><span style="color:#a6e22e">x</span><span style="color:#f92672">-</span><span style="color:#ae81ff">10</span>)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">v</span> <span style="color:#f92672">&gt;&gt;=</span> <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> string(<span style="color:#a6e22e">b</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Obviously, these could be inlined, but separating them allows us to reuse them
for our different functions. Then I set about the actual task at hand.</p>
<h3 id="method-1-map-iteration">Method 1: Map iteration</h3>
<p>In Go, the iteration order of maps is <a href="https://golang.org/ref/spec#For_range">not specified</a>:</p>
<blockquote>
<p>The iteration order over maps is not specified and is not guaranteed to be
the same from one iteration to the next.</p>
</blockquote>
<p>But <code>gc</code>, the canonical Go implementation, actively
<a href="https://golang.org/doc/go1.3#map">randomizes</a> the map iteration order to
prevent programs from depending on it. We can use this, to receive some of
entropy from the runtime, by creating a map and iterating over it:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">MapIteration</span>() <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">r</span> <span style="color:#a6e22e">rand</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">m</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">uint32</span>]<span style="color:#66d9ef">bool</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> uint32(<span style="color:#ae81ff">0</span>); <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">100</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">m</span>[<span style="color:#a6e22e">i</span>] = <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">1000</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">k</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">m</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">mix</span>(<span style="color:#a6e22e">k</span>)
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">break</span> <span style="color:#75715e">// the rest of the loop is deterministic
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">hex</span>(<span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">rand</span>())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We first create a map with a bunch of keys. We then iterate over it a bunch of
times; each map iteration gives us a different start index, which we mix into
our entropy pool.</p>
<h3 id="method-2-select">Method 2: Select</h3>
<p>Go actually defines <a href="https://golang.org/ref/spec#Select_statements">a way</a> in
which the runtime is giving us access to entropy directly:</p>
<blockquote>
<p>If one or more of the communications can proceed, a single one that can
proceed is chosen via a uniform pseudo-random selection.</p>
</blockquote>
<p>So the spec guarantees that if we have multiple possible communications in a
select, the case <em>has</em> to be chosen non-deterministically. We can, again,
extract that non-determinism:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Select</span>() <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">r</span> <span style="color:#a6e22e">rand</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">ch</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">bool</span>)
</span></span><span style="display:flex;"><span>	close(<span style="color:#a6e22e">ch</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">1000</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">select</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">case</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ch</span>:
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">mix</span>(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">case</span> <span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ch</span>:
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">mix</span>(<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">hex</span>(<span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">rand</span>())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We create a channel and immediately close it. We then create a select-statement
with two cases and depending on which was taken, we mix a different value into
our entropy pool. The channel is closed, to guarantee that communication can
always proceed. This way, we extract one bit of entropy per iteration.</p>
<p>Note, that there is no racing or concurrency involved here: This is simple,
single-threaded Go code. The randomness comes directly from the runtime. Thus,
this should work in any compliant Go implementation. The <a href="https://play.golang.org/">playground</a>,
however, is not compliant with the spec in this regard, strictly speaking. It
is deliberately deterministic.</p>
<h3 id="method-3-race-condition">Method 3: Race condition</h3>
<p>This method exploits the fact, that on a multi-core machine at least, the Go
scheduler is non-deterministic. So, if we let two goroutines race to write a
value to a channel, we can extract some entropy from which one wins this race:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">RaceCondition</span>() <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">r</span> <span style="color:#a6e22e">rand</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">1000</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">ch</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">uint32</span>, <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">start</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">bool</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>			<span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">start</span>
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>		}()
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>			<span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">start</span>
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">ch</span> <span style="color:#f92672">&lt;-</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>		}()
</span></span><span style="display:flex;"><span>		close(<span style="color:#a6e22e">start</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">mix</span>(<span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">ch</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">hex</span>(<span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">rand</span>())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The <code>start</code> channel is there to make sure that both goroutines become runnable
concurrently. Otherwise, the first goroutine would be relatively likely to
write the value before the second is even spawned.</p>
<h3 id="method-4-allocationdata-races">Method 4: Allocation/data races</h3>
<p>Another thought I had, was to try to extract some entropy from the allocator or
GC. The basic idea is, that the address of an allocated value might be
non-deterministic - in particular, if we allocate a lot. We can then try use
that as entropy.</p>
<p>However, I could not make this work very well, for the simple reason that Go
does not allow you to actually do anything with pointers - except dereferencing
and comparing them for equality. So while you might get non-deterministic
values, those values can&rsquo;t be used to actually generate random numbers.</p>
<p>I thought I might be able to somehow get a string or integer representation of
some pointer without any imports. One way I considered was inducing a
runtime-panic and recovering that, in the hope that the error string would
contain a stacktrace or offending values. However, none of the error strings
created by the runtime actually seem to contain any values that could be used
here.</p>
<p>I also tried a workaround to interpret the pointer as an integer, by exploiting
<a href="https://research.swtch.com/gorace">race conditions</a> to do unsafe operations:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">DataRace</span>() <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">r</span> <span style="color:#a6e22e">rand</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">data</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">uintptr</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">addr</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">uintptr</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">j</span>, <span style="color:#a6e22e">k</span> <span style="color:#66d9ef">interface</span>{}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">i</span> = (<span style="color:#f92672">*</span><span style="color:#66d9ef">uintptr</span>)(<span style="color:#66d9ef">nil</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">j</span> = <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">data</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">done</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">for</span> !<span style="color:#a6e22e">done</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">k</span> = <span style="color:#a6e22e">i</span>
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">k</span> = <span style="color:#a6e22e">j</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">p</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">k</span>.(<span style="color:#f92672">*</span><span style="color:#66d9ef">uintptr</span>); <span style="color:#a6e22e">ok</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">p</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">addr</span> = <span style="color:#a6e22e">p</span>
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">done</span> = <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">data</span> = new(<span style="color:#66d9ef">uintptr</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">mix</span>(uint32(<span style="color:#f92672">*</span><span style="color:#a6e22e">addr</span>))
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">hex</span>(<span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">rand</span>())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>It turns out, however, that at least this particular instance of a data race
has been fixed since Russ Cox wrote that blog post. In Go 1.9, this code just
loops endlessly. I tried it in Go 1.5, though, and it works there - but we
don&rsquo;t get a whole lot of entropy (addresses are not <em>that</em> random). With other
methods, we could re-run the code to collect more entropy, but in this case,
I believe the escape analysis gets into our way by stack-allocating the
pointer, so it will be the same one on each run.</p>
<p>I like this method, because it uses several obscure steps to work, but on the
other hand, it&rsquo;s the least reliable and it requires an old Go version.</p>
<h3 id="your-methods">Your Methods?</h3>
<p>These are all the methods I could think of; but I&rsquo;m sure I missed a couple. If
you can think of any, feel free to let me know on
<a href="https://twitter.com/TheMerovius">Twitter</a>,
<a href="https://www.reddit.com/r/golang/comments/7qfvzu/generating_entropy_without_imports_in_go/">reddit</a>
or <a href="https://news.ycombinator.com/item?id=16147475">hackernews</a> :) I also posted
the code in a
<a href="https://gist.github.com/Merovius/283ff12a1186d001815485fca1094968">gist</a>, so
you can download and run it yourself, but keep in mind, that the last method
busy-loops in newer Go versions.</p>
]]></content></entry><entry><title type="html">Diminishing returns of static typing</title><link href="https://blog.merovius.de/posts/2017-09-12-diminishing-returns-of-static-typing/" rel="alternate" type="text/html"/><id>https://blog.merovius.de//2017/09/12/diminishing-returns-of-static-typing.html</id><published>2017-09-12T11:05:00+00:00</published><updated>2017-09-12T11:05:00+00:00</updated><content type="html"><![CDATA[<p>I often get into discussions with people, where the matter of strictness and
expressiveness of a static type system comes up. The most common one, by far,
is Go&rsquo;s lack of generics and the resulting necessity to use <code>interface{}</code> in
container types (the <a href="https://godoc.org/container">container-subpackages</a> are
obvious cases, but also <a href="https://godoc.org/context">context</a>). When I express
my view, that the lack of static type-safety for containers isn&rsquo;t a problem, I
am treated with condescending reactions ranging from disbelief to patronizing.</p>
<p>I also often take the <em>other</em> side of the argument. This happens commonly, when
talking to proponents of dynamically typed languages. In particular I got into
debates of whether Python would be suitable for a certain use-case. When the
lack of static type-safety is brought up, the proponents of Python defend it by
pointing out that it now features optional type hints. Which they say make it
possible, to reap the benefits of static typing even in a conventionally
dynamically typed language.</p>
<p>This is an attempt to write my thoughts on both of these (though they are not
in any way novel or creative) down more thoroughly. Discussions usually don&rsquo;t
provide the space for that. They are also often charged and parties are more
interested in “winning the argument”, than finding consensus.</p>
<hr>
<p>I don&rsquo;t think it&rsquo;s particularly controversial, that static typing in general
has advantages, even though actual data about those seems to be <a href="https://danluu.com/empirical-pl/">surprisingly
hard to come by</a>. <em>I</em> certainly believe that,
it is why I use Go in the first place. There is a difference of opinion though,
in how large and important those benefits are and how much of the behavior of a
program must be statically checked to reap those benefits.</p>
<p>To understand this, we should first make explicit <em>what</em> the benefits of static
type checking are. The most commonly mentioned one is to catch bugs as early in
the development process as possible. If a piece of code I write already
contains a rigorous proof of correctness in the form of types, just writing it
down and compiling it gives me assurance that it will work as intended in all
circumstances. At the other end of the spectrum, in a fully dynamic language I
will need to write tests exercising all of my code to find bugs. Running tests
takes time. Writing <em>good</em> tests that actually cover all intended behavior is
hard. And as it&rsquo;s in general impossible to cover <em>all</em> possible execution
paths, there will always be the possibility of a rare edge-case that we didn&rsquo;t
think of testing to trigger a bug in production.</p>
<p>So, we can think of static typing as increasing the proportion of bug-free
lines of code deployed to production. This is of course a simplification. In
practice, we would still catch a lot of the bugs via more rigorous testing,
QA, canarying and other practices. To a degree we can still subsume these in
this simplification though. If we catch a buggy line of code in QA or the
canary phase, we are going to roll it back. So in a sense, the proportion of
code we wrote that makes it as bug-free into production will still go down.
Thus:</p>
<img class="small" src="/assets/static_typing_v_good_code.png">
<p>This is usually the understanding, that the “more static typing is always
better” argument is based on. Checking more behavior at compile time means less
bugs in production means more satisfied customers and less being woken up at
night by your pager. Everybody&rsquo;s happy.</p>
<p>Why then is it, that we don&rsquo;t all code in Idris, Agda or a similarly strict
language? Sure, the graph above is suggestively drawn to taper off, but it&rsquo;s
still monotonically increasing. You&rsquo;d think that this implies more is better.
The answer, of course, is that static typing has a cost and that there is no
free lunch.</p>
<p>The costs of static typing again come in many forms. It requires more upfront
investment in thinking about the correct types. It increases compile times and
thus the change-compile-test-repeat cycle. It makes for a steeper learning
curve. And more often than we like to admit, the error messages a compiler will
give us will decline in usefulness as the power of a type system increases.
Again, we can oversimplify and subsume these effects in saying that it reduces
our speed:</p>
<img class="small" src="/assets/static_typing_v_speed.png">
<p>This is what we mean when we talk about dynamically typed languages being good
for rapid prototyping. In the end, however, what we are usually interested in,
is what I&rsquo;d like to call <em>velocity</em>: The speed with which we can deploy new
features to our users. We can model that as the speed with which we can roll
out bug-free code.  Graphically, that is expressed as the product of the
previous two graphs:</p>
<img class="small" src="/assets/static_typing_v_velocity.png">
<p>In practice, the product of these two functions will have a maximum, a sweet
spot of maximum velocity. Designing a type system for a programming language
is, at least in part, about finding that sweet spot<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>.</p>
<p>Now if we are to accept all of this, that opens up a different question: If we
are indeed searching for that sweet spot, how do we explain the vast
differences in strength of type systems that we use in practice? The answer of
course is simple (and I&rsquo;m sure many of you have already typed it up in an angry
response). The curves I drew above are completely made up. Given how hard it is
to do empirical research in this space and to actually quantify the measures I
used here, it stands to reason that their shape is very much up for
interpretation.</p>
<p>A Python developer might very reasonably believe that optional type-annotations
are more than enough to achieve most if not all the advantages of static
typing. While a Haskell developer might be much better adapted to static typing
and not be slowed down by it as much (or even at all). As a result, the
perceived sweet spot can vary widely:</p>
<img src="/assets/static_typing_pythonista_v_haskeller.png">
<p>What&rsquo;s more, the importance of these factors might vary a lot too. If you are
writing avionics code or are programming the control unit for a space craft,
you probably want to be pretty darn sure that the code you are deploying is
correct. On the other hand, if you are a Silicon Valley startup in your
growth-phase, user acquisition will be of a very high priority and you get
users by deploying features quicker than your competitors. We can model that,
by weighing the factors differently:</p>
<img src="/assets/static_typing_startup_v_nasa.png">
<p>Your use case will determine the sweet spot you are looking for and thus the
language you will choose. But a language is also designed with a set of use
cases in mind and will set its own sweet spot according to that.</p>
<p>I think when we talk about how strict a type system should be, we need to
acknowledge these subjective factors. And it is fine to believe that your
perception of one of those curves or how they should be weighted is closer to
a hypothetical objective reality than another persons. But you should make that
belief explicit and provide a justification of <em>why</em> your perception is more
realistic. Don&rsquo;t just assume that other people view them the same way and then
be confused that they do not come to the same conclusions as you.</p>
<hr>
<p>Back to Go&rsquo;s type system. In my opinion, Go manages to hit a good sweet spot
(that is, its design agrees with my personal preferences on this). To me it
seems that Go reaps probably upwards of 90% of the benefits you can get from
static typing while still being not too impeding. And while I definitely agree
static typing is beneficial, the <em>marginal</em> benefit of making user-defined
containers type-safe simply seems pretty low (even if it&rsquo;s positive). In the
end, it would probably be less than 1% of Go code that would get this additional
type-checking and it is probably pretty obvious code. And meanwhile, I perceive
generics as a language feature pretty costly. So I find it hard to justify a
large perceived cost with a small perceived benefit.</p>
<p>Now, that is not to say I&rsquo;m not open to be convinced. Just that simply saying
“but more type-safety!” is only looking at one side of the equation and isn&rsquo;t
enough. You need to acknowledge that there is no free lunch and that this is a
tradeoff. You need to accept that your perceptions of how big the benefit of
adding static typing is, how much it costs and how important it is are all
subjective. If you want to convince me that my perception of their benefit is
wrong, the best way would be to provide specific instances of bugs or
production crashes caused by a type-assertion on an <code>interface{}</code> taken out of
a container. Or a refactoring you couldn&rsquo;t make because of the lack of
type-safety with a specific container. Ideally, this takes the form of an
<a href="https://github.com/golang/go/wiki/ExperienceReports">experience report</a>, which
I consider an excellent way to talk about engineered tradeoffs.</p>
<p>Of course you can continue to roll your eyes whenever someone questions your
perception of the value-curve of static typing. Or pretend that when I say the
<em>marginal</em> benefit of type-safe containers is small, I am implying that the
<em>total</em> benefit of static typing is small. It&rsquo;s an effective debate-tactic, if
your goal is to shut up your opposition. But not if your goal is to convince
them and build consensus.</p>
<hr>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>There is a generous and broad exception for research
languages here. If the point of your design is to explore the possibility space
of type-systems, matters of practicality can of course often be ignored.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
]]></content></entry><entry><title type="html">Why context.Value matters and how to improve it</title><link href="https://blog.merovius.de/posts/2017-08-14-why-context-value-matters-and-how-to-improve-it/" rel="alternate" type="text/html"/><id>https://blog.merovius.de//2017/08/14/why-context-value-matters-and-how-to-improve-it.html</id><published>2017-08-14T00:17:25+00:00</published><updated>2017-08-14T00:17:25+00:00</updated><content type="html"><![CDATA[<p><strong>tl;dr: I think context.Value solves the important use case of writing
stateless - and thus scalable - abstractions. I believe
<a href="https://en.wikipedia.org/wiki/Scope_(computer_science)#Dynamic_scoping">dynamic scoping</a>
could provide the same benefits while solving most of the criticism of the
current implementation. I thus try to steer the discussion away from the
concrete implementation and towards the underlying problem.</strong></p>
<p><em>This blog post is relatively long. I encourage you to skip sections you find boring</em></p>
<p><strong>Update: I wrote a new post, detailing how the type-safety concerns of
context.Value in light of the new design for generics. <a href="/posts/2020-07-20-parametric-context/">You can check it out
here</a></strong></p>
<hr>
<p>Lately <a href="https://faiface.github.io/posts/context-should-go-away-go2/">this
blogpost</a> has been
discussed in several Go forums. It brings up several good arguments against the
<a href="http://godoc.org/context">context-package</a>:</p>
<ul>
<li>It requires every intermediate functions to include a <code>context.Context</code> even
if they themselves do not use it. This introduces clutter into APIs and
requires extensive plumbing.  Additionally, <code>ctx context.Context</code> &ldquo;stutters&rdquo;.</li>
<li><code>context.Value</code> is not statically type-safe, requiring type-assertions.</li>
<li>It does not allow you to express critical dependencies on context-contents
statically.</li>
<li>It&rsquo;s susceptible to name collisions due to requiring a global namespace.</li>
<li>It&rsquo;s a map implemented as a linked list and thus inefficient.</li>
</ul>
<p>However, I don&rsquo;t think the post is doing a good enough job to discuss the
problems context was designed to <em>solve</em>. It explicitly focuses on cancellation.
<code>Context.Value</code> is discarded by simply stating that</p>
<blockquote>
<p>[…] designing your APIs without ctx.Value in mind at all makes it always
possible to come up with alternatives.</p>
</blockquote>
<p>I think this is not doing this question justice. To have a reasoned argument
about context.Value there need to be consideration for both sides involved.
No matter what your opinion on the current API is: The fact that seasoned,
intelligent engineers felt the need - after significant thought - for
<code>Context.Value</code> should already imply that the question deserves more attention.</p>
<p>I&rsquo;m going to try to describe my view on what kind of problems the context
package tries to address, what alternatives currently exist and why I find them
insufficient and I&rsquo;m trying to describe an alternative design for a future
evolution of the language. It would solve the same problems while avoiding some
of the learned downsides of the context package. It is not meant as a specific
proposal for Go 2 (I consider that way premature at this point) but just to
show that a balanced view can show up alternatives in the design space and make
it easier to consider all options.</p>
<hr>
<p>The problem context sets out to solve is one of abstracting a problem into
independently executing units handled by different parts of a system. And how
to scope data to one of these units in this scenario. It&rsquo;s hard to clearly
define the abstraction I am talking about. So I&rsquo;m instead going to give some
examples.</p>
<ul>
<li>When you build a scalable web service you will probably have a stateless
frontend server that does things like authentication, verification and
parsing for you. This allows you to scale up the external interface
effortlessly and thus also gracefully fall back if the load increases past
what the backends can handle. By treating requests as independent from each
other you can load-balance them freely between your frontends.</li>
<li><a href="https://en.wikipedia.org/wiki/Microservices">Microservices</a> split a large
application into small individual pieces that each process individual
requests, each potentially branching out into more requests to other
services. The requests will usually be independent, making it easy to scale
individual microservices up and down based on demand, to load-balance between
instances and to solve problems in <a href="https://istio.io/">transparent proxies</a>.</li>
<li><a href="https://en.wikipedia.org/wiki/Serverless_computing">Functions as a Service</a>
goes one step further: You write single stateless functions that transform
data and the platform will make them scale and execute efficiently.</li>
<li>Even <a href="https://en.wikipedia.org/wiki/Communicating_sequential_processes">CSP</a>,
the concurrency model built into Go, can be viewed through that lens. The
programmer expresses her problem as individually executing &ldquo;processes&rdquo; and
the runtime will execute them efficiently.</li>
<li><a href="https://en.wikipedia.org/wiki/Functional_programming">Functional Programming</a>
as a paradigm calls this &ldquo;purity&rdquo;. The concept that a functions result may
only depend on its input parameters means not much more than the absence of
shared state and independent execution.</li>
<li>The design of a <a href="https://docs.google.com/document/d/1gCsFxXamW8RRvOe5hECz98Ftk-tcRRJcDFANj2VwCB0/edit">Request Oriented Collector</a>
for Go plays exactly into the same assumptions and ideas.</li>
</ul>
<p>The idea in all these cases is to increase scaling (whether distributed among
machines, between threads or just in code) by reducing shared state while
maintaining shared usage of resources.</p>
<p>Go takes a measured approach to this. It doesn&rsquo;t go as far as some functional
programming languages to forbid or discourage mutable state. It allows sharing
memory between threads and synchronizing with mutexes instead of relying purely
on channels. But it also definitely tries to be a (if not <em>the</em>) language to
write modern, scalable services in. As such, it <em>needs</em> to be a good language
to write this kind of stateless services. It needs to be able to make
<em>requests</em> the level of isolation instead of the process. At least to a degree.</p>
<p><em>(Side note: This seems to play into the statement of the author of above
article, who claims that context is mainly useful for server authors. I
disagree though. The general abstraction happens on many levels. E.g. a click
in a GUI counts just as much as a &ldquo;request&rdquo; for this abstraction as an HTTP
request)</em></p>
<p>This brings with it the requirement of being able to store some data on a
request-level. A simple example for this would be authentication in an <a href="https://grpc.io/">RPC
framework</a>. Different requests will have different
capabilities. If a request originates from an administrator it should have
higher privileges than if it originates from an unauthenticated user. This is
fundamentally <em>request scoped</em> data. Not process, service or application
scoped. And the RPC framework should treat this data as opaque. It is
application specific not only how that data looks en détail but also <em>what
kinds</em> of data it requires.</p>
<p>Just like an HTTP proxy or framework should not need to know about request
parameters or headers it doesn&rsquo;t consume, an RPC framework shouldn&rsquo;t know about
request scoped data the application needs.</p>
<hr>
<p>Let&rsquo;s try to look at specific ways this problem is (or could be) solved without
involving context. As an example, let&rsquo;s look at the problem of writing an HTTP
middleware. We want to be able to wrap an
<a href="http://godoc.org/net/http#Handler">http.Handler</a> (or a variation thereof) in a
way that allows the wrapper to attach data to a request.</p>
<p>To get static type-safety we could try to add some type to our handlers. We
could have a type containing all the data we want to keep request scoped and
pass that through our handlers:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Data</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Username</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Log</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Logger</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// …
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">HandleA</span>(<span style="color:#a6e22e">d</span> <span style="color:#a6e22e">Data</span>, <span style="color:#a6e22e">res</span> <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">ResponseWriter</span>, <span style="color:#a6e22e">req</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Request</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// …
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">Username</span> = <span style="color:#e6db74">&#34;admin&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">HandleB</span>(<span style="color:#a6e22e">d</span>, <span style="color:#a6e22e">req</span>, <span style="color:#a6e22e">res</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// …
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">HandleB</span>(<span style="color:#a6e22e">d</span> <span style="color:#a6e22e">Data</span>, <span style="color:#a6e22e">res</span> <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">ResponseWriter</span>, <span style="color:#a6e22e">req</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Request</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// …
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>However, this would prevent us from writing reusable Middleware. Any such
middleware would need to make it possible to wrap <code>HandleA</code>. But as it&rsquo;s
supposed to be reusable, it can&rsquo;t know the type of the Data parameter. You
could make the <code>Data</code> parameter an <code>interface{}</code> and require type-assertion.
But that wouldn&rsquo;t allow the middleware to inject its own data. You might think
that interface type-assertions could solve this, but they have <a href="/posts/2017-07-30-the-trouble-with-optional-interfaces/">their own set
of problems</a>.
In the end, this approach won&rsquo;t bring you actual additional type safety.</p>
<p>We could store our state keyed by requests. For example, an authentication
middleware could do</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Authenticator</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">mu</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">Mutex</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">users</span> <span style="color:#66d9ef">map</span>[<span style="color:#f92672">*</span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Request</span>]<span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">wrapped</span> <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Handler</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">a</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Authenticator</span>) <span style="color:#a6e22e">ServeHTTP</span>(<span style="color:#a6e22e">res</span> <span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">ResponseWriter</span>, <span style="color:#a6e22e">req</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Request</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// …
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Lock</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">users</span>[<span style="color:#a6e22e">req</span>] = <span style="color:#e6db74">&#34;admin&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Unlock</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">defer</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Lock</span>()
</span></span><span style="display:flex;"><span>		delete(<span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">users</span>, <span style="color:#a6e22e">req</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Unlock</span>()
</span></span><span style="display:flex;"><span>	}()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">wrapped</span>.<span style="color:#a6e22e">ServeHTTP</span>(<span style="color:#a6e22e">res</span>, <span style="color:#a6e22e">req</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">a</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Authenticator</span>) <span style="color:#a6e22e">Username</span>(<span style="color:#a6e22e">req</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">Request</span>) <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Lock</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">mu</span>.<span style="color:#a6e22e">Unlock</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">users</span>[<span style="color:#a6e22e">req</span>]
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This has <em>some</em> advantages over context:</p>
<ul>
<li>It is more type-safe.</li>
<li>While we still can&rsquo;t express a requirement on an authenticated user
statically, we <em>can</em> express a requirement on an <code>Authenticator</code></li>
<li>It&rsquo;s not susceptible to name-collisions anymore.</li>
</ul>
<p>However, we bought this with shared mutable state and the associated lock
contention. It can also break in subtle ways, if one of the intermediate
handlers decides to create a new Request - as
<a href="https://github.com/golang/go/blob/816deacc70f48d14638104e284b3b75d5b1e8036/src/net/http/server.go#L1946">http.StripPrefix</a>
is going to do soon.</p>
<p>Lastly, we might consider to store this data in the
<a href="http://godoc.org/net/http#Request">*http.Request</a> itself, for example by
adding it as a stringified <a href="http://godoc.org/net/url#URL.RawQuery">URL parameter</a>.
This too has several downsides, though. In fact it checks almost every single
item from our list of downsides of <code>context.Context</code>. The exception is being a
linked list. But even that advantage we buy with a lack of thread safety. If
that request is passed to a handler in a different goroutine we get into
trouble.</p>
<p><em>(Side note: All of this also gives us a good idea of why the context package
is implemented as a linked list. It allows all the data stored in it to be
read-only and thus inherently thread-safe. There will never be any
lock-contention around the shared state saved in a context.Context, because
there will never be any need for locks)</em></p>
<p>So we see that it is really hard (if not impossible) to solve this problem of
having data attached to requests in independently executing handlers while also
doing significantly better than with <code>context.Value</code>. Whether you believe this
a problem worth solving or not is debatable. But <em>if</em> you want to get this kind
of scalable abstraction you will have to rely on <em>something</em> like
<code>context.Value</code>.</p>
<hr>
<p>No matter whether you are now convinced of the usefulness of <code>context.Value</code> or
still doubtful: The disadvantages can clearly not be ignored in either case.
But we can try to find a way to improve on it. To eliminate some of the
disadvantages while still keeping its useful attributes.</p>
<p>One way to do that (in Go 2) would be to introduce <a href="https://en.wikipedia.org/wiki/Scope_(computer_science)#Dynamic_scoping">dynamically scoped</a>
variables. Semantically, each dynamically scoped variable represents a separate
stack. Every time you change its value the new one is pushed to the stack.  It
is pop&rsquo;ed off again after your function returns. For example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// Let&#39;s make up syntax! Only a tiny bit, though.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">dyn</span> <span style="color:#a6e22e">x</span> = <span style="color:#ae81ff">23</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Foo</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Foo:&#34;</span>, <span style="color:#a6e22e">x</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Bar</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Bar:&#34;</span>, <span style="color:#a6e22e">x</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">x</span> = <span style="color:#ae81ff">42</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Bar:&#34;</span>, <span style="color:#a6e22e">x</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Baz</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Bar:&#34;</span>, <span style="color:#a6e22e">x</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Baz</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Baz:&#34;</span>, <span style="color:#a6e22e">x</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">x</span> = <span style="color:#ae81ff">1337</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Baz:&#34;</span>, <span style="color:#a6e22e">x</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;main:&#34;</span>, <span style="color:#a6e22e">x</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Foo</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Bar</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Baz</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;main:&#34;</span>, <span style="color:#a6e22e">x</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Output:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">main</span>: <span style="color:#ae81ff">23</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Foo</span>: <span style="color:#ae81ff">23</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Bar</span>: <span style="color:#ae81ff">23</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Bar</span>: <span style="color:#ae81ff">42</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Baz</span>: <span style="color:#ae81ff">42</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Baz</span>: <span style="color:#ae81ff">1337</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Bar</span>: <span style="color:#ae81ff">42</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Baz</span>: <span style="color:#ae81ff">23</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">Baz</span>: <span style="color:#ae81ff">1337</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">main</span>: <span style="color:#ae81ff">23</span>
</span></span></code></pre></div><p>There are several notes about what I would imagine the semantics to be here.</p>
<ul>
<li>I would only allow <code>dyn</code>-declarations at package scope. Given that there is
no way to refer to a local identifier of a different function, that seems
logical.</li>
<li>A newly spawned goroutine would inherit the dynamic values of its parent
function. If we implement them (like <code>context.Context</code>) via linked lists, the
shared data will be read-only. The head-pointer would need to be stored in
some kind of goroutine-local storage. Thus, writes only ever modify this
local storage (and the global heap), so wouldn&rsquo;t need to be synchronized
specifically.</li>
<li>The dynamic scoping would be independent of the package the variable is
declared in. That is, if <code>foo.A</code> modifies a dynamic <code>bar.X</code>, then that
modification is visible to all subsequent callees of <code>foo.A</code>, whether they
are in <code>bar</code> or not.</li>
<li>Dynamically scoped variables would likely not be addressable. Otherwise we&rsquo;d
loose concurrency safety and the clear &ldquo;down-stack&rdquo; semantics of dynamic
scoping. It would still be possible to declare <code>dyn x *int</code> though and thus
get mutable state to pass on.</li>
<li>The compiler would allocate the necessary storage for the stacks, initialized
to their initializers and emit the necessary instructions to push and pop
values on writes and returns. To account for panics and early returns, a
mechanism like <code>defer</code> would be needed.</li>
<li>There is some confusing overlap with package-scoped variables in this design.
Most notably, from seeing <code>foo.X = Y</code> you wouldn&rsquo;t be able to tell whether
<code>foo.X</code> is dynamically scoped or not. Personally, I would address that by
removing package-scoped variables from the language. They could still be
emulated by declaring a dynamically-scoped pointer and never modifying it.
Its pointee is then a shared variable. But most usages of package-scoped
variables would probably just use dynamically scoped variables.</li>
</ul>
<p>It is instructive to compare this design against the list of disadvantages
identified for <code>context</code>.</p>
<ul>
<li>API clutter would be removed, as request-scoped data would now be
part of the language without needing explicit passing.</li>
<li>Dynamically scoped variables are statically type-safe. Every <code>dyn</code>
declaration has an unambiguous type.</li>
<li>It would still not be possible to express critical dependencies on
dynamically scoped variables but they also couldn&rsquo;t be <em>absent</em>. At worst
they&rsquo;ll have their zero value.</li>
<li>Name collision is eliminated. Identifiers are, just like variable names,
properly scoped.</li>
<li>While a naive implementation would still use linked lists, they wouldn&rsquo;t be
inefficient. Every <code>dyn</code> declaration gets its own list and only the
head-pointer ever needs to be operated on.</li>
<li>The design is still &ldquo;magic&rdquo; to a degree. But that &ldquo;magic&rdquo; is problem-inherent
(at least if I understand the criticism correctly). The magic is exactly the
possibility to pass values transparently through API boundaries.</li>
</ul>
<p>Lastly, I&rsquo;d like to mention cancellation. While the author of above post
dedicates most of it to cancellation, I have so far mostly ignored it.  That&rsquo;s
because I believe cancellation to be trivially implementable on top of a good
<code>context.Value</code> implementation. For example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// $GOROOT/src/done
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">package</span> <span style="color:#a6e22e">done</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// C is closed when the current execution context (e.g. request) should be
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// cancelled.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">dyn</span> <span style="color:#a6e22e">C</span> <span style="color:#f92672">&lt;-</span><span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">struct</span>{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// CancelFunc returns a channel that gets closed, when C is closed or cancel is
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// called.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">CancelFunc</span>() (<span style="color:#a6e22e">c</span> <span style="color:#f92672">&lt;-</span><span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">struct</span>, <span style="color:#a6e22e">cancel</span> <span style="color:#66d9ef">func</span>()) {
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Note: We can&#39;t modify C here, because it is dynamically scoped, which is
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#75715e">// why we return a new channel that the caller should store.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#a6e22e">ch</span> <span style="color:#f92672">:=</span> make(<span style="color:#66d9ef">chan</span> <span style="color:#66d9ef">struct</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">o</span> <span style="color:#a6e22e">sync</span>.<span style="color:#a6e22e">Once</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">cancel</span> = <span style="color:#66d9ef">func</span>() { <span style="color:#a6e22e">o</span>.<span style="color:#a6e22e">Do</span>(close(<span style="color:#a6e22e">ch</span>)) }
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">C</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>			<span style="color:#f92672">&lt;-</span><span style="color:#a6e22e">C</span>
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">cancel</span>()
</span></span><span style="display:flex;"><span>		}()
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ch</span>, <span style="color:#a6e22e">cancel</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// $GOPATH/example.com/foo
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">package</span> <span style="color:#a6e22e">foo</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Foo</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">cancel</span> <span style="color:#66d9ef">func</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">done</span>.<span style="color:#a6e22e">C</span>, <span style="color:#a6e22e">cancel</span> = <span style="color:#a6e22e">done</span>.<span style="color:#a6e22e">CancelFunc</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">cancel</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// Do things
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>This cancellation mechanism would now be usable from any library that wants it
without needing any explicit support in its API. This would also make it easy
to add cancellation capabilities retroactively.</p>
<hr>
<p>Whether you <em>like</em> this design or not, it demonstrates that we shouldn&rsquo;t rush
to calling for the removal of <code>context</code>. Removing it is only one possible
solution to its downsides.</p>
<p>If the removal of <code>context.Context</code> actually comes up, the question we should
ask is &ldquo;do we want a canonical way to manage request-scoped values and at what
cost&rdquo;.  Only then should we ask what the best implementation of this would be
or whether to remove the current one.</p>
]]></content></entry></feed>